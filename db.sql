--
-- PostgreSQL database dump
--

-- Dumped from database version 9.6.3
-- Dumped by pg_dump version 9.6.3

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET search_path = public, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: exercise_history; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE exercise_history (
    user_id integer NOT NULL,
    exercise_id character varying(42) NOT NULL,
    solution jsonb,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


ALTER TABLE exercise_history OWNER TO turtleprogrammer;

--
-- Name: exercises; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE exercises (
    uuid character varying(36) NOT NULL,
    type character varying(64) NOT NULL,
    markdown text NOT NULL,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


ALTER TABLE exercises OWNER TO turtleprogrammer;

--
-- Name: quizes; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE quizes (
    uuid character varying(36) NOT NULL,
    markdown text,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


ALTER TABLE quizes OWNER TO turtleprogrammer;

--
-- Name: topic_drafts; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE topic_drafts (
    topic_id integer NOT NULL,
    author_id integer NOT NULL,
    title character varying(256) NOT NULL,
    markdown text NOT NULL,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


ALTER TABLE topic_drafts OWNER TO turtleprogrammer;

--
-- Name: topic_edit_history; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE topic_edit_history (
    id integer NOT NULL,
    topic_id integer,
    author_id integer,
    slug character varying(256) NOT NULL,
    title character varying(256) NOT NULL,
    version_number integer NOT NULL,
    markdown text NOT NULL,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


ALTER TABLE topic_edit_history OWNER TO turtleprogrammer;

--
-- Name: topic_edit_history_id_seq; Type: SEQUENCE; Schema: public; Owner: turtleprogrammer
--

CREATE SEQUENCE topic_edit_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE topic_edit_history_id_seq OWNER TO turtleprogrammer;

--
-- Name: topic_edit_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: turtleprogrammer
--

ALTER SEQUENCE topic_edit_history_id_seq OWNED BY topic_edit_history.id;


--
-- Name: topic_history; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE topic_history (
    user_id integer NOT NULL,
    topic_id integer NOT NULL,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


ALTER TABLE topic_history OWNER TO turtleprogrammer;

--
-- Name: topics; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE topics (
    id integer NOT NULL,
    slug character varying(256),
    title character varying(256) NOT NULL,
    version_number integer NOT NULL,
    markdown text NOT NULL,
    author_id integer,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    content_list jsonb DEFAULT '[]'::json
);


ALTER TABLE topics OWNER TO turtleprogrammer;

--
-- Name: topics_id_seq; Type: SEQUENCE; Schema: public; Owner: turtleprogrammer
--

CREATE SEQUENCE topics_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE topics_id_seq OWNER TO turtleprogrammer;

--
-- Name: topics_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: turtleprogrammer
--

ALTER SEQUENCE topics_id_seq OWNED BY topics.id;


--
-- Name: users; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE users (
    id integer NOT NULL,
    email character varying(256) NOT NULL,
    name character varying(256),
    avatar character varying(256),
    active boolean,
    superuser boolean,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


ALTER TABLE users OWNER TO turtleprogrammer;

--
-- Name: users_id_seq; Type: SEQUENCE; Schema: public; Owner: turtleprogrammer
--

CREATE SEQUENCE users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE users_id_seq OWNER TO turtleprogrammer;

--
-- Name: users_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: turtleprogrammer
--

ALTER SEQUENCE users_id_seq OWNED BY users.id;


--
-- Name: topic_edit_history id; Type: DEFAULT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topic_edit_history ALTER COLUMN id SET DEFAULT nextval('topic_edit_history_id_seq'::regclass);


--
-- Name: topics id; Type: DEFAULT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topics ALTER COLUMN id SET DEFAULT nextval('topics_id_seq'::regclass);


--
-- Name: users id; Type: DEFAULT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY users ALTER COLUMN id SET DEFAULT nextval('users_id_seq'::regclass);


--
-- Data for Name: exercise_history; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY exercise_history (user_id, exercise_id, solution, created_at, updated_at) FROM stdin;
1	f9965145-d7b0-46a5-a506-47afb703ffb0	{"code": "import re\\n\\nre.split('')"}	2017-08-20 21:52:00.928	2017-08-20 22:01:05.564
\.


--
-- Data for Name: exercises; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY exercises (uuid, type, markdown, created_at, updated_at) FROM stdin;
e1043574-1cbd-46b0-8183-815ebe1daad2	regexquiz	\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n\r\nSolution: Star Trek:\r\n	2017-08-15 22:14:15.215	2017-08-17 21:38:35.501
f1de4844-1927-4b7e-a687-43ba797f1779	mcquiz	\nHere are some movie names.  Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n	2017-08-15 22:14:15.215	2017-08-17 21:38:35.502
6c410957-58ab-4b59-9ebf-5b3c81ce178a	regexquiz	\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n\r\nSolution: Star Wars:\r\n	2017-08-15 22:14:15.215	2017-08-17 21:38:35.506
\.


--
-- Data for Name: quizes; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY quizes (uuid, markdown, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: topic_drafts; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY topic_drafts (topic_id, author_id, title, markdown, created_at, updated_at) FROM stdin;
4	1	Regex - Gibberish to Rescue	To an untrained eye, regular expressions look like gibberish and that's how we'll treat them in this section. Once you are done with the entire material, they'll not be gibberish anymore. We'll get there...\n\n#### Revisiting the Problem\n\nWe want to extract the website name (i.e. `wattpad`) from different ways in which it is given to us (i.e. `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children`).\n\n#### The Solution\n\nThe solution has two parts to it:\n\n* First, we define a pattern that would match all variations in which people mentioned the site name (i.e. `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children`)\n* Next, we'll use the pattern to extract the actual site name (i.e. `wattpad`) from its variations.\n\nHere is the gibberish (aka regular expression) that describes the pattern we are looking for. Don't even try to understand it for now. Just take it as it is.\n\n```Python\nREGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\n```\n\nHere is the code that makes use of `REGEX_GIBBERISH`, applies it to the site name as entered by the students and gives us the bare bone site name as we want to see.\n\n```Python\n# Import the regular expression module\nimport re\n\n# Define the regex pattern\nREGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\n\n# Apply the pattern to whatever site name was entered by students \n# and get the barebone site name.\nre.search(REGEX_GIBBERISH, "...site name...").group("site")\n```\n\nLet's see this code in action now.\n\n```Python\n>>> import re\n>>> REGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\n>>> \n>>> re.search(REGEX_GIBBERISH, "wattpad").group("site")\n'wattpad'\n>>> re.search(REGEX_GIBBERISH, "wattpad.com").group("site")\n'wattpad'\n>>> re.search(REGEX_GIBBERISH, "www.wattpad.com").group("site")\n'wattpad'\n>>> re.search(REGEX_GIBBERISH, "http://www.wattpad.com").group("site")\n'wattpad'\n>>> re.search(REGEX_GIBBERISH, "https://www.wattpad.com").group("site")\n'wattpad'\n>>> re.search(REGEX_GIBBERISH, "https://www.wattpad.com/tags/children").group("site")\n'wattpad'\n>>> \n```\n\nFascinating. Isn't it?	2017-07-04 00:32:00.208968	2017-07-04 01:07:16.796018
\.


--
-- Data for Name: topic_edit_history; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY topic_edit_history (id, topic_id, author_id, slug, title, version_number, markdown, created_at, updated_at) FROM stdin;
1	10	1	regex-matching-one-of-many-characters	Regex - Matching One of Many Characters	11	An interesting problem to solve is to match movies that mention a year in their name. Sample movie names are: `2001: A Space Odyssey`, `Dream Team 1935`, `Class of 1999` etc. To keep it simple for now, a year is four digits out of which first digit could be 1 or 2 and rest of the digits could go from 0 to 9. From what we have learnt so far, we could define a pattern like this for our purpose.\r\n\r\n```Python\r\nREGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n```\r\n\r\nLet's put it to use and see it working.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nThe pattern works but it's quite cumbersome. Regex provides another expression that we can use here. `(0|1|2|3|4|5|6|7|8|9)` could be written as `[0123456789]`. When you put multiple characters in `[]`, regex would look for matching one of these.\r\n\r\nWe can now rewrite the previous expression as:\r\n\r\n```Python\r\nREGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n```\r\n\r\nLet's try out the new pattern.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nIn fact, such needs are so common that there is a further shortcut to matching digits 0-9: `[0-9]`. So, we can once again re-write the expression as `[12][0-9][0-9][0-9]`. Here is how we use it:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0-9][0-9][0-9]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nNice. Isn't it?\r\n\r\n--regexquiz:4eb7e560-d86d-4eee-9f3f-3be7a381617f\r\nTry different regex variations that we discussed just now to select movie names that have a year in their name.\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] 1984\r\n  [ ] Gone With The Wind\r\n  [ ] Star Wars: The Last Jedi\r\n--\r\n\r\n## Ranges and Alphabets\r\n\r\nRanges work not only for digits but also for alphabets. So, you could say `r"[A-Z]"` to match any upper case letter, `r"[a-z]"` to match any lower case letter, `r"[A-Za-z]"` to match all English alphabet letters, `r"[A-Za-z0-9]"` to match any alphanumeric characters. In fact, you can also say `r"[AM-PZ]"` and it would match letters A, M, N, O, P, Z.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> re.search(r"[A-Z]", "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(6, 7), match='A'>\r\n>>> \r\n>>> re.search(r"[A-Z]", "1984")\r\n>>>\r\n```\r\n\r\nHere, we are looking for a movie name with an uppercase letter. The movie `2001: A Space Odyssey` is a match, whereas, the movie `1984` is not a match.\r\n\r\n--mcquiz:3de214bf-d472-4dfd-a05e-3552496a9394\r\nHere are some movie names. Which ones would match the regex `r"[0-9][0-9][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz:50b56794-b819-4fc9-b5ab-8f7db62f3236\r\nHere are some movie names. Which ones would match the regex `r"[0-29][0-5][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz:f021d060-5ae6-4042-b6a0-87172f94be87\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [ ] `r"Super[mg][ai][nrl]"`\r\n  [#] `r"Super[mg][ai][nr]l"`\r\n  [#] `r"Super[mg][ai](n|rl)"`\r\n  [ ] `r"Super[mangirl]"`\r\n--\r\n\r\n--regexquiz:c562b1db-5dd5-49dc-b821-b25dc821dcde\r\nHere is a list of movie names. Select the ones that have at least one 4 letter word in the middle of movie name.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz:7ab96916-ae7b-43ba-a620-a07d017db875\r\nHere is a list of movie names. Select the ones that use a number within a word.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz:7f8920cf-32e5-41d4-ba2a-01766a2b8c07\r\nHere is a list of movie names. Select the ones that have a bat, cat or rat in the name. Use the shortest possible regex.\r\n  [#] Bat Whispers\r\n  [#] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n## Matching absence of characters\r\n\r\nJust like you can match for presence of certain characters, you can also match for their absence. `[^A-Z]` will match all characters except uppercase letters. `[^BCR]at` will match `Sat` but it will not match `Bat`, `Cat` and `Rat`. Simple trick here is to use `^`. `[BCR]` means match B, C or R but `[^BCR]` means match anything other than B, C or R.\r\n\r\n--mcquiz:4148011c-203d-4568-90d8-d868f0bbc517\r\nWhich of the following match regex `[0-1][0-9]:[0-6][0-9] [^P]M`:\r\n  [#] 04:00 AM\r\n  [#] 11:59 AM\r\n  [ ] 06:00 PM\r\n  [ ] 09:23 PM\r\n--\r\n\r\n--mcquiz:3233168c-7e35-471a-9f82-0bf10d884931\r\nHere are some movie names. Which ones would match the regex `[^3-9][0-5][0-9][0-9]:`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [ ] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n	2017-08-13 21:50:14.721	2017-08-13 21:50:14.721
2	6	1	regex-matching-characters	Regex - Matching Characters	3	In this section, we'll solve problems that revolve around presence or absence of certain characters in the text. For most of the problems, we'll use Hollywood movie names as the dataset where we do our pattern matching. It looks like the following:\r\n\r\nOk?\r\n\r\n```\r\nAbandoned\r\nAbbott and Costello Meet the Killer\r\nAbominable Dr. Phibes\r\nAbominable Snowman\r\nAbove the Street\r\nAbsent-Minded Professor\r\nAbyss\r\n...\r\nZoom \r\nZoot Suit \r\nZorba the Greek \r\nZorn's Lemma \r\nZorro \r\nZotz! \r\nZouzou \r\nZozo\r\n```\r\n\r\nHere are the kind of problems we'll solve around the movie names:\r\n\r\n* Finding movies that belong to a specific franchise (e.g. `Star Wars`).\r\n* Finding movies from multiple franchise (e.g. all movies from `Star Wars` as well as `Star Trek`).\r\n* Skipping movies from a specific franchise (e.g. all movies other than `Superman`). Or even all `Super` movies that are not `Superman`.\r\n* Finding movies that use a year in their name (e.g. `2001: A Space Odyssey`).\r\n* Finding movies with at least one five letter word (e.g. `Superman` is ok but `Cat and Dog` is not).\r\n	2017-08-13 21:54:50.117	2017-08-13 21:54:50.117
3	6	1	regex-matching-characters	Regex - Matching Characters	4	In this section, we'll solve problems that revolve around presence or absence of certain characters in the text. For most of the problems, we'll use Hollywood movie names as the dataset where we do our pattern matching. It looks like the following:\r\n\r\n```\r\nAbandoned\r\nAbbott and Costello Meet the Killer\r\nAbominable Dr. Phibes\r\nAbominable Snowman\r\nAbove the Street\r\nAbsent-Minded Professor\r\nAbyss\r\n...\r\nZoom \r\nZoot Suit \r\nZorba the Greek \r\nZorn's Lemma \r\nZorro \r\nZotz! \r\nZouzou \r\nZozo\r\n```\r\n\r\nHere are the kind of problems we'll solve around the movie names:\r\n\r\n* Finding movies that belong to a specific franchise (e.g. `Star Wars`).\r\n* Finding movies from multiple franchise (e.g. all movies from `Star Wars` as well as `Star Trek`).\r\n* Skipping movies from a specific franchise (e.g. all movies other than `Superman`). Or even all `Super` movies that are not `Superman`.\r\n* Finding movies that use a year in their name (e.g. `2001: A Space Odyssey`).\r\n* Finding movies with at least one five letter word (e.g. `Superman` is ok but `Cat and Dog` is not).\r\n	2017-08-13 21:55:06.046	2017-08-13 21:55:06.046
4	7	1	regex-matching-literals	Regex - Matching Literals	10	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 18:56:35.724	2017-08-15 18:56:35.724
5	7	1	regex-matching-literals	Regex - Matching Literals	11	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 18:56:58.827	2017-08-15 18:56:58.827
6	7	1	regex-matching-literals	Regex - Matching Literals	12	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 18:57:27.446	2017-08-15 18:57:27.446
7	7	1	regex-matching-literals	Regex - Matching Literals	13	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 19:00:10.943	2017-08-15 19:00:10.943
8	7	1	regex-matching-literals	Regex - Matching Literals	14	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 19:01:09.237	2017-08-15 19:01:09.237
9	7	1	regex-matching-literals	Regex - Matching Literals	15	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 19:02:26.019	2017-08-15 19:02:26.019
10	7	1	regex-matching-literals	Regex - Matching Literals	16	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 19:03:06.249	2017-08-15 19:03:06.249
11	7	1	regex-matching-literals	Regex - Matching Literals	17	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 19:07:29.673	2017-08-15 19:07:29.673
12	7	1	regex-matching-literals	Regex - Matching Literals	18	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 19:08:33.226	2017-08-15 19:08:33.226
13	7	1	regex-matching-literals	Regex - Matching Literals	19	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 19:09:21.71	2017-08-15 19:09:21.71
14	7	1	regex-matching-literals	Regex - Matching Literals	20	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 19:10:23.451	2017-08-15 19:10:23.451
15	7	1	regex-matching-literals	Regex - Matching Literals	21	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 21:36:29.154	2017-08-15 21:36:29.154
16	7	1	regex-matching-literals	Regex - Matching Literals	22	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 21:38:16.534	2017-08-15 21:38:16.534
17	7	1	regex-matching-literals	Regex - Matching Literals	23	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 21:57:19.76	2017-08-15 21:57:19.76
18	7	1	regex-matching-literals	Regex - Matching Literals	24	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names.  Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 21:57:49.693	2017-08-15 21:57:49.693
19	7	1	regex-matching-literals	Regex - Matching Literals	25	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names.  Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 21:58:53.295	2017-08-15 21:58:53.295
20	7	1	regex-matching-literals	Regex - Matching Literals	26	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names.  Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 21:59:38.249	2017-08-15 21:59:38.249
21	7	1	regex-matching-literals	Regex - Matching Literals	27	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names.  Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 22:00:43.466	2017-08-15 22:00:43.466
22	7	1	regex-matching-literals	Regex - Matching Literals	28	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names.  Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 22:03:10.308	2017-08-15 22:03:10.308
23	7	1	regex-matching-literals	Regex - Matching Literals	29	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names.  Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-15 22:14:15.145	2017-08-15 22:14:15.145
24	7	1	regex-matching-literals	Regex - Matching Literals	30	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names.  Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-16 16:28:45.823	2017-08-16 16:28:45.823
25	7	1	regex-matching-literals	Regex - Matching Literals	31	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names.  Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n\r\nSolution: Star Wars:\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-08-17 21:37:50.345	2017-08-17 21:37:50.345
26	7	1	regex-matching-literals	Regex - Matching Literals	32	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names.  Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n\r\nSolution: Star Wars:\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n\r\nSolution: Star Trek:\r\n--\r\n	2017-08-17 21:38:35.468	2017-08-17 21:38:35.468
\.


--
-- Name: topic_edit_history_id_seq; Type: SEQUENCE SET; Schema: public; Owner: turtleprogrammer
--

SELECT pg_catalog.setval('topic_edit_history_id_seq', 26, true);


--
-- Data for Name: topic_history; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY topic_history (user_id, topic_id, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: topics; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY topics (id, slug, title, version_number, markdown, author_id, created_at, updated_at, content_list) FROM stdin;
1	regex-introduction	Regex Introduction	20	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or to understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.	1	2017-07-03 05:15:56.703792	2017-07-04 01:05:22.929537	[]
5	regex-the-plan	Regex - The Plan	1	Here is what we are going to do now. We are going to learn regular expressions one bit at a time. Here is the broad outline:\r\n\r\n* How to write patterns in regular expressions and use these patterns to `match` text. This is where you learn pretty much 80% of this language.\r\n* How to extract the text that matches the pattern. This is really a small bit once you have a pattern in hand.\r\n* How to replace the matching text with some other text. This is also a small bit once the language itself has been learnt.	1	2017-07-04 13:34:51.763413	2017-07-04 13:34:51.763455	[]
12	regex-matching-occurrences-or-repetitions	Regex - Matching Occurrences or Repetitions	1	So far, we have looked at specifying *which characters* are allowed and which ones are not allowed in the pattern. Now, we'll look at specifying *how many* are allowed.\r\n\r\nLet's revisit the problem of matching movie names with at least 6 letters. We know that `1984` is not a match and `Superman` is a match. The pattern we wrote was `......`. Basically, a `.` (which matches all characters) repeated 6 times.\r\n\r\nRegex has mechanisms to say precisely how many times a match should occur. This is what we'll study in this section.	1	2017-07-05 00:01:35.564596	2017-07-05 00:01:35.564626	[]
14	regex-repetition-count-symbols	Regex - ?, * and +	2	Some of the `{m,n}` are so commonly used that there are special symbols for them. Here is the list:\r\n\r\n* `?` is same as `{0,1}`. `\\d?` means a digit may or may not be there.\r\n* `*` is same as `{0,}`. `\\d*` means a digit may not be there or there may be infinite occurrences of the same.\r\n* `+` is same as `{1,}`. `\\d+` means that at least one digit is present and it may repeat infinitely.\r\n\r\nLet's put them to some use.\r\n\r\n## ? or {0,1}\r\n\r\nIf you want to match numbers 0 to 99, you can do it with `\\d{1,2}` or `\\d?\\d`. Let's try:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search("\\d?\\d", "43")\r\n<_sre.SRE_Match object; span=(0, 2), match='43'>\r\n>>>\r\n>>> re.search("\\d?\\d", "4")\r\n<_sre.SRE_Match object; span=(0, 1), match='4'>\r\n```\r\n\r\nNote: the pattern `r"\\d?\\d"` would always try to look for two digits as a first thing. However, if it doesnt find two, it would settle for one. Thats different from `r"\\d"` which would always try to match one digit.\r\n\r\n--mcquiz\r\nWhich of the following would match regex `[+-]\\d?\\d`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -99 to 99. So, it should match -99, -98, , 98, 99.\r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [ ] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -99 to 99. The +ve numbers may be written with or without a `+` prefix. For example, 98 could be written as 98 or +98. \r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n## * or {0,}\r\n\r\nJust like `?` matches something thats optional, `*` matches something thats optional and yet it can have more than 1 occurrences. So, `r"BA*T"` will match `"BT"`, `"BAT"` as well as `"BAAAAAAAAT"`.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "BA*T", "BT")\r\n<_sre.SRE_Match object; span=(0, 2), match='BT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAT")\r\n<_sre.SRE_Match object; span=(0, 3), match='BAT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAAAAAT")\r\n<_sre.SRE_Match object; span=(0, 7), match='BAAAAAT'>\r\n```\r\n\r\n--mcquiz\r\nWhich of the following would match regex `\\w\\s*:\\s*\\w`:\r\n  [#] Potatoes: 4\r\n  [#] Potatoes:4\r\n  [#] Potatoes    :     4\r\n  [#] 4: Potatoes\r\n  [ ] Potatoes ~::~ 4\r\n  [ ] :Potatoes:\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match the sentences that mention cat followed by dog. Hint: use repetition of `.` to match word & space characters.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [ ] The dog looked at the cat with confusion.\r\n  [ ] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match sentences that mention cat and dog in any order (i.e. word cat could come before or after the word dog). Hint: Use the `|` operator.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [#] The dog looked at the cat with confusion.\r\n  [#] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n  [ ] The dog went wild.\r\n--\r\n\r\n## + or {1,}\r\n\r\nJust like `*` matches 0 or more occurrences, `+` matches 1 or more occurrences. That means the preceding pattern is not optional. There has to be at least one instance but it can repeat any number of times. Where is it useful? Lets say we want to match `Yikes` as well as `Yiiiiiiiikkkkkes` in our text. They eventually mean the same thing with different intensity. We could do something like this:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "Yi+k+es", "Yikes" )\r\n<_sre.SRE_Match object; span=(0, 5), match='Yikes'>\r\n>>>\r\n>>> re.search( "Yi+k+es", "Yiiiiiiiiikkkkkes" )\r\n<_sre.SRE_Match object; span=(0, 17), match='Yiiiiiiiiikkkkkes'>\r\n>>>\r\n```\r\n\r\nHow do you find out the names of movies that have at least 2 words? Something along the lines of `\\w+\\s+\\w+` would do the trick.\r\n\r\n--regexquiz\r\nWrite a regex to match movies with at least three words in their name.\r\n  [#] Gone With The Wind\r\n  [ ] Superman\r\n  [#] La La Land\r\n  [#] The Sixth Sense\r\n  [ ] Braveheart\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match movies with at least four words in their name. Note: you have to match `:` as part of characters between words. Hint: you can use `[]` or `|` for matching characters between words.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n  [ ] Shawshank Redemption\r\n  [#] 2001: A Space Odyssey\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match the sentences that mention two years.\r\n  [#] 1984 comes before 1999.\r\n  [#] 2004 comes after 2001.\r\n  [ ] In 2015, I bought 2 cars.\r\n  [ ] There was a flood in 1999.\r\n--\r\n\r\n\r\n\r\n	1	2017-07-05 00:01:35.564596	2017-07-05 01:29:06.086429	[]
3	regex-problem-statement	Regex - Problem Statement	5	Continuing from the previous section, here is the sample information you received from the students of your school:\r\n\r\n```\r\nGoogle\r\nFacebook\r\nInstagram\r\nWattPad\r\ngoogle.com\r\nfacebook.com\r\nwattpad.com\r\nwww.google.com\r\nwww.facebook.com\r\nwww.wattpad.com\r\nhttps://www.wattpad.com/tags/children\r\nhttps://www.facebook.com/home\r\nhttps://www.instagram.com\r\n```\r\n\r\nEven though there is quite a variety in the way information is represented, there is a pattern here. You intuitively know that `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children` mean the same thing in this context. They all mean that the student has singled out `wattpad` as the favorite site.\r\n\r\nThis is where the problem is: how do you map all these variations of `wattpad` to just what it is (i.e. `wattpad`)? To your mind, the pattern is clear and you can easily see the mapping. However, if you were to write a program for this purpose, it would be a fairly involved task.\r\n\r\nThis is where regular expresions shine. They give you a powerful language to describe the pattern (or the variations thereof).\r\n\r\n\r\n	1	2017-07-03 23:57:09.421612	2017-07-06 00:47:48.233946	[]
17	regex-matching-1-or-more-occurrences	Regex - + (Match 1 or More Occurrences)	2	`+` stands for `{1,}` which matches at least 1 and at most infinite times.\r\n\r\nHow do you match the movies with at least 2 words in their name? `\\w+\\s+\\w+` would do the trick. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\w+\\s+\\w+"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Spiderman Returns")\r\n<_sre.SRE_Match object; span=(0, 17), match='Spiderman Returns'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Spiderman")\r\n>>> \r\n```\r\n\r\n--regexquiz:3cacba35-8a65-4acb-b1fc-1cf375c8b55c\r\nWrite a regex to match movies with at least three words in their name.\r\n  [#] Gone With The Wind\r\n  [ ] Superman\r\n  [#] La La Land\r\n  [#] The Sixth Sense\r\n  [ ] Braveheart\r\n--\r\n\r\n--regexquiz:d5ee27df-3581-4b7e-aa2d-354be285db74\r\nWrite a regex to match movies with at least four words in their name. Note: you have to match `:` as part of characters between words. Hint: you can use `[]` or `|` for matching characters between words.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n  [ ] Shawshank Redemption\r\n  [#] 2001: A Space Odyssey\r\n--\r\n\r\n--regexquiz:20698e4a-4f06-4eec-adc7-8c69cac3808b\r\nWrite a regex to match the sentences that mention two years.\r\n  [#] 1984 comes before 1999.\r\n  [#] 2004 comes after 2001.\r\n  [ ] In 2015, I bought 2 cars.\r\n  [ ] There was a flood in 1999.\r\n--\r\n	1	2017-07-06 00:43:32.697962	2017-07-09 01:18:11.332015	[]
21	regex-beyond-match	Regex - Beyond Match	1	So far, our focus was to become proficient at writing regex patterns. We'll learn a few more things about writing patterns but before that, let's take a break and focus on what you can do *after* you have found a match.	1	2017-07-08 01:50:57.984556	2017-07-08 01:50:57.984593	[]
2	regex-setting-the-stage	Regex - Setting the Stage	11	## Stage 1\r\n\r\n<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 2\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated small image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 3\r\n\r\n<img src="/static/img/regex/favorite-websites-2.png" class="ui left floated small image"/>\r\n\r\nWhile you were waiting for all the results to come in, you find that some people entered just the simple name (e.g. `google`), some others prefer to provide domain name (e.g. `google.com`). You were still wondering how you would handle that when (as they say) all hell broke loose.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 4, 5 and so on so forth\r\n\r\n<img src="/static/img/regex/favorite-websites-3.png" class="ui right floated medium image"/>\r\n\r\nYou find that students are entering information in all sorts of format. Some are providing the domain names (`google.com`), some are providing the full url (`https://www.google.com`) and some are even providing links to specific sections of the website (`https://www.wattpad.com/tags/children`). How are you ever going to sort through all of this?\r\n\r\n\r\n\r\n\r\n\r\n	1	2017-07-03 23:19:12.44864	2017-07-03 23:55:56.184578	[]
4	regex-enters-the-gibberish	Regex - Gibberish to Rescue	2	To an untrained eye, regular expressions look like gibberish and that's how we'll treat them in this section. Once you are done with the entire material, they'll not be gibberish anymore. We'll get there...\r\n\r\n#### Revisiting the Problem\r\n\r\nWe want to extract the website name (i.e. `wattpad`) from different ways in which it is given to us (i.e. `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children`).\r\n\r\n#### The Solution\r\n\r\nThe solution has two parts to it:\r\n\r\n* First, we define a pattern that would match all variations in which people mentioned the site name (i.e. `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children`)\r\n* Next, we'll use the pattern to extract the actual site name (i.e. `wattpad`) from its variations.\r\n\r\nHere is the gibberish (aka regular expression) that describes the pattern we are looking for. Don't even try to understand it for now. Just take it as it is.\r\n\r\n```Python\r\nREGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\r\n```\r\n\r\nHere is the code that makes use of `REGEX_GIBBERISH`, applies it to the site name as entered by the students and gives us the bare bone site name as we want to see.\r\n\r\n```Python\r\n# Import the regular expression module\r\nimport re\r\n\r\n# Define the regex pattern\r\nREGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\r\n\r\n# Apply the pattern to whatever site name was entered by students \r\n# and get the barebone site name.\r\nre.search(REGEX_GIBBERISH, "...site name...").group("site")\r\n```\r\n\r\nLet's see this code in action now.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\r\n>>> \r\n>>> re.search(REGEX_GIBBERISH, "wattpad").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "www.wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "http://www.wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "https://www.wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "https://www.wattpad.com/tags/children").group("site")\r\n'wattpad'\r\n>>> \r\n```\r\n\r\nFascinating. Isn't it?	1	2017-07-04 00:32:00.205196	2017-07-04 01:07:13.272998	[]
25	regex-extract-content-nested-groups	Regex - Extract Content (Nested Groups)	3	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r"\\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n'Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person with middle name\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person without middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n--offline-exercise:8a9f5ede-33d8-4d92-a0b1-94dc9c8170af\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and match groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise:f2017509-009a-42a7-b33b-3c68b915d971\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and match groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise:78b449f4-fc02-457b-ab44-d499418324c0\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `<proto>://<host>.<site>.com`. Using regex (and match groups), you need to extract the proto, host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `http`, `www` and `google`.\r\n* `https://en.wikipedia.org` should give you `https`, `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `http`, `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise:31c2764d-e0bb-4a22-8da7-21654f58abcf\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of ingredients and quantity for a recipe. It's in the format `<ingredient>: <quantity> <metric>`. Using regex (and match groups), you need to extract the ingredient, quantity and metric. Metric is optional.\r\n\r\nHere is how you can test it:\r\n\r\n* `Onion: 2` should give you `Onion` and `2`.\r\n* `Olive Oil: 1 tbsp` should give you `Olive Oil`, `1` and `tbsp`.\r\n* `Salt  :   1    tbsp` should give you `Salt`, `1` and `tbsp`.\r\n* `Water:`, `Pepper: tbsp` should not match.\r\n--\r\n\r\n	1	2017-07-08 21:01:24.41188	2017-07-09 01:20:32.66126	[]
9	regex-matching-special-characters	Regex - Matching Special Characters	2	Some characters have special meaning in regex (e.g. `.`, `?`, `(`, `)`, `*`, `+`, `^`, `$`, `\\`, `[`, `]`) . We'll look at their use later in the game. For now, suffice it to say that if you want to match any of these, you have to precede them with `\\` to find a match. For example, if you want to match movie names that have a full stop, you have to use `\\.` as regex pattern and not `.`.\r\n\r\nLet's solve the problem of matching movie names that have a full stop. Here is the wrong pattern:\r\n\r\n```Python\r\n>>> import re\r\n>>> INCORRECT_REGEX_PATTERN = r'.'\r\n>>> \r\n>>> re.search(INCORRECT_REGEX_PATTERN, 'Mr. Average')\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(INCORRECT_REGEX_PATTERN, 'Stardust')\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> # should not have matched Stardust but it did.\r\n```\r\n\r\nHere is the same exercise with the right regex pattern:\r\n\r\n```Python\r\n>>> import re\r\n>>> CORRECT_REGEX_PATTERN = r'\\.'\r\n>>> \r\n>>> re.search(CORRECT_REGEX_PATTERN, 'Mr. Average')\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(CORRECT_REGEX_PATTERN, 'Stardust')\r\n>>> # did not match Stardust\r\n```\r\n\r\n--regexquiz:ffb4f681-4808-439c-bb43-23727c19e013\r\nWrite the regex pattern that matches movies with `.` in their name:\r\n  [#] Mr. Pip\r\n  [#] The D.I.\r\n  [ ] Stardust\r\n  [ ] Superman\r\n--\r\n\r\n\r\n\r\n	1	2017-07-04 18:03:20.665585	2017-07-09 01:13:03.252865	[]
8	regex-matching-this-or-that	Regex - Matching This or That	11	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we could define the pattern as `Star Wars:|Star Trek:`. This pattern would match either `Star Wars:` or `Star Trek:`. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\nThe regex `Star Wars:|Star Trek:` has multiple duplicate elements. We can make it more concise with `Star (Wars|Trek):`. It means look for `Star`, followed by a space followed by either `Wars` or `Trek`, followed by a `:`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star (Wars|Trek):"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n--mcquiz:2b151f26-94fd-4932-bab8-349427ce848d\r\nHere are some movie names. Which of these would match the regex `Force|Jedi`:\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Discovery\r\n  [ ] Star Trek: Voyager\r\n--\r\n\r\n--regexquiz:4007c758-69cf-46a6-928e-4b7cd55bf4fd\r\nWhat's the regex to select movies from Star Wars as well as Star Trek franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [#] Star Trek: Discovery\r\n  [#] Star Trek: Voyager\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n--\r\n\r\n--mcquiz:fa5b08c2-b54d-4547-9a6d-eb4ff46f2b4c\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [#] `Superman|Supergirl`\r\n  [#] `Super(man|girl)`\r\n  [ ] `Super(m|g)(a|i)(n|r)l`\r\n  [#] `Super(m|g)(a|i)(n|rl)`\r\n  [#] `Super((man|girl))`\r\n  [#] `Super((man)|girl)`\r\n--\r\n\r\n--mcquiz:a16209cb-a012-4ce5-8f0a-d30ffbaa3a5c\r\nWhich of the following movies will be matched by regex `(Star (Wars|Trek):)|(Super(man|girl))`\r\n  [#] Star Wars: The Last Jedi\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n  [#] Star Trek: Voyager\r\n  [#] Superman Returns\r\n  [#] Supergirl\r\n--\r\n\r\n--regexquiz:9cb8a852-cfbd-491b-af75-47edc4c229a9\r\nWrite a regex that would match all the Star Wars, Star Trek and Space related movies.\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n  [#] Star Trek: Voyager\r\n  [ ] Superman\r\n  [#] Alien Space Avenger\r\n--\r\n\r\n	1	2017-07-04 17:16:11.331039	2017-07-09 01:13:44.718424	[]
16	regex-matching-0-or-more-occurrences	Regex - * (Matching 0 or More Occurrences)	3	`*` stands for `{0,}` which means at least 0 and at most infinite matches. `BA*T` would match `BT`, `BAT`, `BAAAAAAAAAAAAAAAAAAAAAT` etc.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "BA*T", "BT")\r\n<_sre.SRE_Match object; span=(0, 2), match='BT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAT")\r\n<_sre.SRE_Match object; span=(0, 3), match='BAT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAAAAAT")\r\n<_sre.SRE_Match object; span=(0, 7), match='BAAAAAT'>\r\n```\r\n\r\n--mcquiz:14376373-e7c1-494e-a8f2-531f565e2bf7\r\nWhich of the following would match regex `\\w\\s*:\\s*\\w`:\r\n  [#] Potatoes: 4\r\n  [#] Potatoes:4\r\n  [#] Potatoes    :     4\r\n  [#] 4: Potatoes\r\n  [ ] Potatoes ~::~ 4\r\n  [ ] :Potatoes:\r\n--\r\n\r\n--regexquiz:dc76c54b-5968-4a3b-a02f-260a10651451\r\nWrite a regex that matches `http` and `https` urls that end with `.com` or `.org` domains. Hint: you'll need `.*`.\r\n  [#] http://www.google.com\r\n  [#] http://yahoo.org\r\n  [#] http://www.facebook.com/profile\r\n  [#] http://www.wattpad.com/tags/fiction\r\n  [ ] ftp://www.google.com\r\n  [ ] http://www.yahoo.net\r\n  [#] https://www.facebook.com\r\n  [ ] https://www.photo.net\r\n--\r\n\r\n--regexquiz:dba74cbc-9b45-4215-8603-2f519c3d0bae\r\nWrite a regex that would match the sentences that mention cat followed by dog. Hint: use repetition of `.` to match word & space characters.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [ ] The dog looked at the cat with confusion.\r\n  [ ] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n--\r\n\r\n--regexquiz:5ee02aed-22c0-48de-a012-f393b69c9bee\r\nWrite a regex that would match sentences that mention cat and dog in any order (i.e. word cat could come before or after the word dog). Hint: Use the `|` operator.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [#] The dog looked at the cat with confusion.\r\n  [#] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n  [ ] The dog went wild.\r\n--\r\n	1	2017-07-06 00:43:32.697962	2017-07-09 01:17:54.956073	[]
11	regex-matching-types-of-characters	Regex - Matching Types of Characters	6	Let's revisit the problem of identifying movies that have a year in their name. We looked at set of characters (i.e. `[0-9]`) as a solution. Some of these sets are so commonly used that there are special symbols for them. These symbols are:\r\n\r\n* `\\w` is equivalent to `[A-Za-z0-9_]`\r\n* `\\W` is opposite of `\\w` i.e. `[^A-Za-z0-9_]`\r\n* `\\s` is equivalent to `[ \\t\\r\\n]`\r\n* `\\S` is opposite of `\\s` i.e. `[^ \\t\\r\\n]`\r\n* `\\d` is equivalent to `[0-9]`\r\n* `\\D` is opposite of `\\d` i.e. `[^0-9]`\r\n* `.` is the most interesting shortcut and it matches all characters without exception.\r\n\r\nSo, we had earlier used regex `[12][0-9][0-9][0-9]` to find movies with a year in their name. This regex could also be written as `[12]\\d\\d\\d`. In this, `\\d` stands for a digit. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12]\\d\\d\\d"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nSimilarly, let's say if we want to find out if a movie name has at least 1 word that is five letters long (or even longer). Instead of writing `[A-Za-z][A-Za-z][A-Za-z][A-Za-z][A-Za-z]`, we could write `\\w\\w\\w\\w\\w`. The `\\w` based regex is more concise and readable. Here it is in action:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\w\\w\\w\\w\\w"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1995")\r\n<_sre.SRE_Match object; span=(0, 5), match='Dream'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 5), match='Super'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Cat And Dog")\r\n>>> \r\n```\r\n\r\n\r\nWhat if we want to find out movies whose name is at least 6 letter long? The regex `......` will do the trick for us:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"......"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 6), match='Superm'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1984")\r\n>>> \r\n```\r\n\r\nExpression `r"\\w\\w\\w\\w\\s\\w\\w\\w\\w"` would match a movie name that has at least two words and both the words have at least 4 letters.\r\n\r\n```Python\r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Gone With The Wind")\r\n<_sre.SRE_Match object; span=(0, 9), match='Gone With'>\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "The Ghosts")\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Cat And Dog")\r\n>>>\r\n```\r\n\r\n--regexquiz:2b4d6694-3281-4d0a-b663-a9f089f7a081\r\nWrite a regex that matches movies with at least 8 characters in their name.\r\n  [ ] Se7en\r\n  [ ] Thr3e\r\n  [ ] E=mc2\r\n  [#] 2001: A Space Odyssey\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz:a1c91f6f-0aa9-48b2-9f36-fb20beba582b\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz:cd83f62d-4944-4a63-af26-98da4fbd50b9\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n--regexquiz:bccd002e-ecfa-4006-bf3f-3d404c607381\r\nFind movies which have a number surrounded by one letters on each side.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz:08dbdec3-eb4a-492f-9548-ff7e5c1e7b5b\r\nFind movies which have two consecutive non-word letters. Hint: use `\\W`.\r\n  [#] Star Wars: Return of the Jedi\r\n  [#] Star Trek: Voyager\r\n  [#] Erkan & Stefan 2\r\n  [ ] Cat And Dog\r\n  [ ] Alice in Wonderland\r\n  [ ] Pirates of the Carribean\r\n--\r\n\r\n\r\n	1	2017-07-04 18:03:20.665585	2017-07-09 01:15:49.2823	[]
15	regex-matching-0-or-1-occurrences	Regex - ? (Matching 0 or 1 Occurrence)	3	`?` stands for `{0,1}`. A pattern should match at least 0 and at most 1 time. Effectively, it's another way of saying that the pattern may or may not be there. It's used very frequently.\r\n\r\nLet's revisit the problem of matching numbers from -9 to 9. Also, 7 could be written as 7 as well as +7. We could re-write the previous regex (`[+-]{0,1}\\d`) as `[+-]?\\d`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[+-]?\\d"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "-7")\r\n<_sre.SRE_Match object; span=(0, 2), match='-7'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "7")\r\n<_sre.SRE_Match object; span=(0, 1), match='7'>\r\n>>> re.search(REGEX_PATTERN, "+7")\r\n>>> \r\n<_sre.SRE_Match object; span=(0, 2), match='+7'>\r\n>>> \r\n```\r\n\r\n--mcquiz:c1e4f09c-8569-4d35-aac9-018ff5b6cfaa\r\nWhich of the following would match regex `[+-]\\d?\\d`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz:62aeb766-20d9-4021-a140-618342d4ff16\r\nWrite a regex that would match numbers -99 to 99. The +ve numbers may be written with or without a `+` prefix. For example, 98 could be written as 98 or +98. \r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz:ae9c9584-2889-44ff-95f3-f9fa831a0e31\r\nWrite a regex that would match `http://` as well as `https://` urls.\r\n  [#] https://www.google.com\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] http://www.yahoo.com\r\n  [ ] ftp://www.google.com\r\n  [ ] scp://www.yahoo.com\r\n  [ ] http-proto\r\n  [ ] https is a protocol\r\n--\r\n  \r\n  \r\n  \r\n  \r\n  \r\n\r\n	1	2017-07-06 00:43:32.697962	2017-07-09 01:16:57.550549	[]
28	regex-split-findall-content	Regex - Split/FindAll	2	We'll run through a few more methods in the `re` module.\r\n\r\n## re.split()\r\n\r\nThe `re.split()` method splits a strings based on a regex. Example:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.split(r"\\W+", "apple banana mango pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana, mango, pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana , mango   , pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n```\r\n\r\nWhile you can use the string's `split()` method, the regex one just becomes more powerful since it can handle so many variations of the separator.\r\n\r\n--offline-exercise:f9965145-d7b0-46a5-a506-47afb703ffb0\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nUse the `re.split()` mmethod to split a string that has list of ingredients and their quantity for a recipe. The format is `ingredient: quantity`.\r\n\r\nHere is what you can use for testing:\r\n\r\n* `Onion: 2` should give you `['Onion', '2']`.\r\n* `Onion  :   2` should give you `['Onion', '2']`.\r\n* `Onion:2` should give you `['Onion', '2']`.\r\n* `Onion: `, `:2` and `Onion` should not match.\r\n--\r\n\r\n## re.findall()\r\n\r\nThe method `re.findall()` is useful when you are trying to find multiple occurrences of a pattern within text. For example, if we want to find all years mentioned in a given text, `findall()` would be pretty helpful. Example:\r\n\r\n```Python\r\n>>> text = "The growth was more in 2001 compred to 2002."\r\n>>> re.findall(r"\\d+", text)\r\n['2001', '2002']\r\n```\r\n\r\n--offline-exercise:f84447b8-31cf-489c-8e6f-017263fa859e\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nUse the `re.findall()` method to find all five letter words in given text. Here is how you can test your code:\r\n\r\n* `There was less death in 2004.` should give you `['There', 'death']`.\r\n* `This is superb.` should give you nothing.\r\n--\r\n\r\n	1	2017-07-08 22:04:22.346269	2017-07-09 01:21:08.054637	[]
18	regex-matching-boundaries	Regex - Matching Boundaries	1	Let's say, we want to match the text which has the word `cat` in it. We could use the regex `cat`. This regex would match `cat is fat`, `the cat jumped over the wall` etc. But it would also match `he was herding the cattle` :(\r\n\r\nIf we modify the regex to `cat\\s`, we can avoid matching `he was herding the cattle`. But it would still match `this muscat is funny`.\r\n\r\nHow about `\\scat\\s` as the regex? The problem is that it would not match `cat jumped` or `this is my cat.`.\r\n\r\nRegex has the ability to match boundaries of words & lines that would help us in this scenario. Let's see how...	1	2017-07-06 02:12:44.261177	2017-07-06 02:12:44.261226	[]
13	regex-matching-m-to-n-occurrence	Regex - Matching m To n Occurrences	7	In regex, the general purpose method of matching certain number of occurrences is to use `{m,n}`. `\\d{2,4}` would match at least 2 and at most 4 occurrences of `\\d`.\r\n\r\nEarlier, we wrote the regex `\\d\\d\\d\\d` for matching a year in movie name. The same could be re-written as `\\d{4,4}` which matches at least 4 and at most 4 occurrences of `\\d`. It could be further shortened to `\\d{4}`.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{4}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n<_sre.SRE_Match object; span=(11, 15), match='1992'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Gone With The Wind")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "E=mc2")\r\n>>> \r\n```\r\n\r\n--regexquiz:2e62b6a3-6843-446e-b199-b2cff2277ead\r\nWrite a regex that matches movie names that have at least 12 letters. Use the `{}` syntax.\r\n  [ ] 1984\r\n  [ ] Superman\r\n  [#] Spiderman Returns\r\n  [#] Star Wars: Return of the Jedi\r\n--\r\n\r\nLet's look at a different problem this time. You want to match numbers 0 to 999. How would you do that? `\\d{1,3}` would do the trick.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{1,3}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "8")\r\n<_sre.SRE_Match object; span=(0, 1), match='8'>\r\n>>> # Matches 1 \\d because only 1 is available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "64")\r\n<_sre.SRE_Match object; span=(0, 2), match='64'>\r\n>>> # Matches 2 \\d because only 2 are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "256")\r\n<_sre.SRE_Match object; span=(0, 3), match='256'>\r\n>>> # Matches 3 \\d because all three are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1024")\r\n<_sre.SRE_Match object; span=(0, 3), match='102'>\r\n>>> # Matches 3 \\d and stops looking for more.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "abcdef")\r\n>>> # Not even 1 \\d found. So, not a match.\r\n```\r\n\r\nLet's re-work some of the older problems but this time, make use of `{}` operators to specify number of occurrences.\r\n\r\n--mcquiz:4b2aa2ca-eca9-4721-9a87-fa67219966ad\r\nWhich of the following would match regex `[+-]\\d{1,2}`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz:f8f71c16-f771-4ed5-afeb-43858df03a07\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, , 998, 999. Use the `{m,n}` convention to specify occurrences. Hint: `-` has 0 to 1 occurrence while `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [ ] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz:123cc9d9-c4a1-43c4-9394-225b1ab1d76f\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, , 998, 999. The positive numbers could be prefixed with +. So, 64 could also be written as +64. Use the `{m,n}` convention to specify occurrences. Hint: in this case, `[+-]` have 0 to 1 occurrence and `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz:cf65ce5a-a047-400f-a31a-a33629f832ab\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] Spinderman Returns\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz:10edf34a-f317-42ca-98a0-cb1d6995c7c8\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n## m To n Roundup\r\n\r\n`{m,n}` has four variations:\r\n\r\n* `{m,n}` matches at least m and at most n occurrences.\r\n* `{m}` matches exactly m occurrences.\r\n* `{m,}` matches at least m occurrneces (no upper bound).\r\n* `{,n}` matches at least 0 and at most n occurrences.\r\n\r\n	1	2017-07-05 00:01:35.564596	2017-07-09 01:16:35.789319	[]
19	regex-matching-word-boundaries	Regex - Matching Word Boundaries	5	In regex, `\\b` matches word boundary. What does it mean? Let's first define what a word is.\r\n\r\nIn regex, a word is an unbroken sequence of `[A-Za-z0-9_]` or `\\w`. The sentence `cat jumped` has two words: `cat` and `jumped`. OTOH, `key:value` has two words: `key` and `value`. Even `http-proto` has two words: `http` and `proto`.\r\n\r\nSymbol `\\b` matches at the start and end of word boundary. The regex `\\bcat\\b` would match sentences that have word `cat`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\bcat\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "cat is fat")\r\n<_sre.SRE_Match object; span=(0, 3), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "the cat jumped over the wall.")\r\n<_sre.SRE_Match object; span=(4, 7), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this is my cat.")\r\n<_sre.SRE_Match object; span=(11, 14), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "he was herding the cattle.")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this muscat is funny.")\r\n>>> \r\n```\r\n\r\n--mcquiz:66532415-dbad-42db-8664-17bb962fd21c\r\nHow many words (as per regex definition) are there in `http://www.google.com/search`?\r\n  [ ] 3\r\n  [ ] 4\r\n  [#] 5\r\n  [ ] 6\r\n--\r\n\r\n--regexquiz:67d4ece9-9a4b-4f0e-b733-5ced60ce9bb8\r\nWrite a regex to match sentences that mention animal dog.\r\n  [#] a dog was barking.\r\n  [#] dog is a loyal animal.\r\n  [#] this is my dog.\r\n  [ ] is it a dogfish?\r\n  [ ] dogfood is about using your own software.\r\n--\r\n\r\n--regexquiz:de6b8d33-1db6-4bd4-92dc-51856f2eb37b\r\nWrite a regex that matches sentences with at least one word that has exactly 5 letters.\r\n  [#] I am a super human.\r\n  [#] Spice route is not spicy.\r\n  [ ] Spiderman returns is not interesting.\r\n  [ ] Cat can jump.\r\n  [#] Cat can't climb.\r\n--\r\n\r\n--regexquiz:584051c2-5cb3-444c-819c-8da6333804a0\r\nWrite a regex that matches sentences that have a year in 4 digit format.\r\n  [#] In year 2000, there was an earthquake.\r\n  [#] 1984.\r\n  [#] In 2020, I'll be 20 years old.\r\n  [ ] I am 20 years old now.\r\n  [ ] 123456789 is a really long number.\r\n--\r\n	1	2017-07-06 02:12:44.261177	2017-07-09 01:18:35.471233	[]
20	regex-matching-line-boundaries	Regex - Matching Line Boundaries	8	Just like words have boundaris that we can match with `\\b`, lines also have boundaries that we can match with `^` (start of line) and `$` (end of line).\r\n\r\nLet's say we want to match movie names that start with a year. So, we should match `2001: A Space Odyssey` but not `Dracula A.D. 1972`. We could use the pattern `^\\d{4}\\b` to do just that.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"^\\d{4}\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n<_sre.SRE_Match object; span=(0, 4), match='2009'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "44500 Max")\r\n>>> # Not a match\r\n>>>\r\n```\r\n\r\nSimilarly, we can use the pattern `\\b\\d{4}$` to match movie names that end with a year.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\b\\d{4}$"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n<_sre.SRE_Match object; span=(19, 23), match='1940'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n>>> # Not a match\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "Super 23123")\r\n>>> # Not a match\r\n>>> \r\n```\r\n\r\n--mcquiz:72adb2e8-b01c-4f29-8109-7d380d120d8c\r\nWhich of the following would match the regex `^\\d{4}$`:\r\n  [#] 1984\r\n  [#] 1971\r\n  [#] 2081\r\n  [ ] AM1200\r\n  [ ] Class of 1999\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Daleks' Invasion Earth: 2150 A.D.\r\n--\r\n\r\n--regexquiz:169bd30c-ca2c-468b-9319-5caf27f1efa7\r\nWrite a regex to match movie names that have only a single word:\r\n  [#] Superman\r\n  [#] 1984\r\n  [ ] Spiderman Returns\r\n  [ ] 2001: A Space Odyssey\r\n  [#] AM1200\r\n  [ ] I.Q.\r\n--\r\n\r\n--regexquiz:5424bec4-03d0-4ab5-a8e4-3db4fda08841\r\nWrite a regex to match movie names that do not have any whitespace character (Hint: `\\S`).\r\n  [#] Superman\r\n  [#] I.Q.\r\n  [ ] Spiderman Returns\r\n--\r\n\r\n--regexquiz:6c7ed823-0cc1-40de-a671-e988e9d44597\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] http://www.yahoo.com\r\n  [#] http://www.wattpad.com\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz:90bcd660-49e7-42fa-9f4a-64bb28720165\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://www.wattpad.com\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz:695ab476-a23b-4cf2-a876-71c2a16bbeff\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz:f2a8586f-01bb-4a33-93d4-45070c51530a\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com/tags/children\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz:e0d044cd-2577-431d-96da-ab139d9798f1\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com/tags/children\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n  [#] http://localhost:8000/test-page.html\r\n--\r\n\r\n	1	2017-07-06 02:12:44.261177	2017-07-09 01:19:07.767289	[]
23	regex-extract-content-full-match	Regex - Extract Content Full Match	2	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, but also which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\nYou should refer to the documentation of [Match Object](file:///Users/mangarg/Downloads/python-3.6.2rc1-docs-html/library/re.html#match-objects) on Python documentation.\r\n\r\n--offline-exercise:1fb6bc2e-29b5-41a9-83e4-9f39dd92aa68\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n--offline-exercise:f006ebc6-89b8-4171-9d63-bc6f8f7f5835\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that use an Adverb (words that end with ly). For example: strictly, deadly, objectively etc.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Strictly Ballroom` should give you `Strictly`.\r\n* `Tough and Deadly` should give you `Deadly`.\r\n* `Heavenly Creatures` should give you `Heavenly`.\r\n* `Superman` should not be a match.\r\n--\r\n\r\n--offline-exercise:42f6e7f4-8066-4422-81dd-7d18cb81298a\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module.\r\n* Define a regex to match sentences that have an email address (user@domain.com). For simplicity, assume that `user` and `domain` can have only the word characters and `-`.\r\n* Extract the matching email address from the Match Object returned `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `smith@yahoo.com - Steve Smith` should give you `smith@yahoo.com`.\r\n* `hi@turtleprogrammer.com - Someone Out There` should give you `hi@turtleprogrammer.com`.\r\n* `rama@gmail.com` should give you `rama@gmail.com`.\r\n* `rama @gmail.com` should not be a match.\r\n--\r\n\r\n	1	2017-07-08 14:23:19.285163	2017-07-09 01:19:33.547879	[]
22	regex-extract-content	Regex - Extract Content	13	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, but also which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\nYou should refer to the documentation of [Match Object](file:///Users/mangarg/Downloads/python-3.6.2rc1-docs-html/library/re.html#match-objects) on Python documentation.\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that use an Adverb (words that end with ly). For example: strictly, deadly, objectively etc.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Strictly Ballroom` should give you `Strictly`.\r\n* `Tough and Deadly` should give you `Deadly`.\r\n* `Heavenly Creatures` should give you `Heavenly`.\r\n* `Superman` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module.\r\n* Define a regex to match sentences that have an email address (user@domain.com). For simplicity, assume that `user` and `domain` can have only the word characters and `-`.\r\n* Extract the matching email address from the Match Object returned `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `smith@yahoo.com - Steve Smith` should give you `smith@yahoo.com`.\r\n* `hi@turtleprogrammer.com - Someone Out There` should give you `hi@turtleprogrammer.com`.\r\n* `rama@gmail.com` should give you `rama@gmail.com`.\r\n* `rama @gmail.com` should not be a match.\r\n--\r\n\r\n	1	2017-07-08 01:50:57.984556	2017-07-08 14:19:53.962153	[]
24	regex-extract-content-nested-match	Regex - Extract Content (Nested Match)	8	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r"\\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n'Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person with middle name\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person without middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and match groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and match groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `<proto>://<host>.<site>.com`. Using regex (and match groups), you need to extract the proto, host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `http`, `www` and `google`.\r\n* `https://en.wikipedia.org` should give you `https`, `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `http`, `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of ingredients and quantity for a recipe. It's in the format `<ingredient>: <quantity> <metric>`. Using regex (and match groups), you need to extract the ingredient, quantity and metric. Metric is optional.\r\n\r\nHere is how you can test it:\r\n\r\n* `Onion: 2` should give you `Onion` and `2`.\r\n* `Olive Oil: 1 tbsp` should give you `Olive Oil`, `1` and `tbsp`.\r\n* `Salt  :   1    tbsp` should give you `Salt`, `1` and `tbsp`.\r\n* `Water:`, `Pepper: tbsp` should not match.\r\n--\r\n\r\n	1	2017-07-08 14:23:19.285163	2017-07-08 18:06:13.335607	[]
26	regex-extract-content-named-groups	Regex - Extract Content (Named Groups)	8	While it's possible (and easy) to use numbered groups to extract content, it can get unwiedly in complex regex when there are too many nested groups. It's much cleaner to be able to name the groups for which we want to extract the content.\r\n\r\nLet's rework the problem of extracting first name and last name from a name. This is what we did earlier:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nWe can instead use the `(?P<group_name>...)` syntax:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(?P<first_name>\\w+) (?P<last_name>\\w+)", "Ram Kripal")\r\n>>> name_match.group('first_name')\r\n'Ram'\r\n>>> name_match.group('last_name')\r\n'Kripal'\r\n```\r\n\r\nIf you notice, we rewrote `(\\w+)` as `(?P<first_name>\\w+)` which can be broken down as:\r\n\r\n* `(` - start of the group.\r\n* `?P` - declaration that we'll give a name to the group.\r\n* `<first_name>` - name of the group.\r\n* `\\w+` - pattern. \r\n* `)` - end of the group\r\n\r\n--offline-exercise:21c05233-af76-41ea-8f32-0994dc758022\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nFrom the [previous section](/topic/regex-extract-content-nested-groups), modify the regex to extract first, middle and last names to use named groups. The group names should be first_name, middle_name and last_name.\r\n\r\nHere is how you can test it:\r\n\r\n* `George Bernard Shaw` should give you `George`, `Bernard`, `Shaw`.\r\n* `Ram Prakash Kripal` should give you `Ram`, `Prakash`, `Kripal`.\r\n* `John Smith` should give you `John`, blank middle name, `Smith`.\r\n* `Lee` and `Raja Shekhar Chandra Reddy` should not match.\r\n--\r\n\r\n--offline-exercise:ea476223-38e5-49fd-b70a-79d62746bc9a\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and named groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise:dca25a5b-8579-4aad-ba20-1b7fc072c5f2\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and named groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n\r\n	1	2017-07-08 21:02:17.717593	2017-07-09 01:20:54.058433	[]
27	regex-split-substitute-findall-content	Regex - Split/Substitute/FindAll	1	We'll run through a few more methods in the `re` module.\r\n\r\n## re.split()\r\n\r\nThe `re.split()` method splits a strings based on a regex. Example:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.split(r"\\W+", "apple banana mango pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana, mango, pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana , mango   , pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n```\r\n\r\nWhile you can use the string's `split()` method, the regex one just becomes more powerful since it can handle so many variations of the separator.\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nUse the `re.split()` mmethod to split a string that has list of ingredients and their quantity for a recipe. The format is `ingredient: quantity`.\r\n\r\nHere is what you can use for testing:\r\n\r\n* `Onion: 2` should give you `['Onion', '2']`.\r\n* `Onion  :   2` should give you `['Onion', '2']`.\r\n* `Onion:2` should give you `['Onion', '2']`.\r\n* `Onion: `, `:2` and `Onion` should not match.\r\n--\r\n\r\n\r\n\r\n\r\n	1	2017-07-08 21:51:31.167733	2017-07-08 21:51:31.167782	[]
10	regex-matching-one-of-many-characters	Regex - Matching One of Many Characters	11	An interesting problem to solve is to match movies that mention a year in their name. Sample movie names are: `2001: A Space Odyssey`, `Dream Team 1935`, `Class of 1999` etc. To keep it simple for now, a year is four digits out of which first digit could be 1 or 2 and rest of the digits could go from 0 to 9. From what we have learnt so far, we could define a pattern like this for our purpose.\r\n\r\n```Python\r\nREGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n```\r\n\r\nLet's put it to use and see it working.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nThe pattern works but it's quite cumbersome. Regex provides another expression that we can use here. `(0|1|2|3|4|5|6|7|8|9)` could be written as `[0123456789]`. When you put multiple characters in `[]`, regex would look for matching one of these.\r\n\r\nWe can now rewrite the previous expression as:\r\n\r\n```Python\r\nREGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n```\r\n\r\nLet's try out the new pattern.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nIn fact, such needs are so common that there is a further shortcut to matching digits 0-9: `[0-9]`. So, we can once again re-write the expression as `[12][0-9][0-9][0-9]`. Here is how we use it:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0-9][0-9][0-9]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nNice. Isn't it?\r\n\r\n--regexquiz:4eb7e560-d86d-4eee-9f3f-3be7a381617f\r\nTry different regex variations that we discussed just now to select movie names that have a year in their name.\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] 1984\r\n  [ ] Gone With The Wind\r\n  [ ] Star Wars: The Last Jedi\r\n--\r\n\r\n## Ranges and Alphabets\r\n\r\nRanges work not only for digits but also for alphabets. So, you could say `r"[A-Z]"` to match any upper case letter, `r"[a-z]"` to match any lower case letter, `r"[A-Za-z]"` to match all English alphabet letters, `r"[A-Za-z0-9]"` to match any alphanumeric characters. In fact, you can also say `r"[AM-PZ]"` and it would match letters A, M, N, O, P, Z.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> re.search(r"[A-Z]", "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(6, 7), match='A'>\r\n>>> \r\n>>> re.search(r"[A-Z]", "1984")\r\n>>>\r\n```\r\n\r\nHere, we are looking for a movie name with an uppercase letter. The movie `2001: A Space Odyssey` is a match, whereas, the movie `1984` is not a match.\r\n\r\n--mcquiz:3de214bf-d472-4dfd-a05e-3552496a9394\r\nHere are some movie names. Which ones would match the regex `r"[0-9][0-9][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz:50b56794-b819-4fc9-b5ab-8f7db62f3236\r\nHere are some movie names. Which ones would match the regex `r"[0-29][0-5][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz:f021d060-5ae6-4042-b6a0-87172f94be87\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [ ] `r"Super[mg][ai][nrl]"`\r\n  [#] `r"Super[mg][ai][nr]l"`\r\n  [#] `r"Super[mg][ai](n|rl)"`\r\n  [ ] `r"Super[mangirl]"`\r\n--\r\n\r\n--regexquiz:c562b1db-5dd5-49dc-b821-b25dc821dcde\r\nHere is a list of movie names. Select the ones that have at least one 4 letter word in the middle of movie name.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz:7ab96916-ae7b-43ba-a620-a07d017db875\r\nHere is a list of movie names. Select the ones that use a number within a word.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz:7f8920cf-32e5-41d4-ba2a-01766a2b8c07\r\nHere is a list of movie names. Select the ones that have a bat, cat or rat in the name. Use the shortest possible regex.\r\n  [#] Bat Whispers\r\n  [#] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n## Matching absence of characters\r\n\r\nJust like you can match for presence of certain characters, you can also match for their absence. `[^A-Z]` will match all characters except uppercase letters. `[^BCR]at` will match `Sat` but it will not match `Bat`, `Cat` and `Rat`. Simple trick here is to use `^`. `[BCR]` means match B, C or R but `[^BCR]` means match anything other than B, C or R.\r\n\r\n--mcquiz:4148011c-203d-4568-90d8-d868f0bbc517\r\nWhich of the following match regex `[0-1][0-9]:[0-6][0-9] [^P]M`:\r\n  [#] 04:00 AM\r\n  [#] 11:59 AM\r\n  [ ] 06:00 PM\r\n  [ ] 09:23 PM\r\n--\r\n\r\n--mcquiz:3233168c-7e35-471a-9f82-0bf10d884931\r\nHere are some movie names. Which ones would match the regex `[^3-9][0-5][0-9][0-9]:`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [ ] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n	1	2017-07-04 18:03:20.665	2017-08-13 21:50:14.716	{}
6	regex-matching-characters	Regex - Matching Characters	4	In this section, we'll solve problems that revolve around presence or absence of certain characters in the text. For most of the problems, we'll use Hollywood movie names as the dataset where we do our pattern matching. It looks like the following:\r\n\r\n```\r\nAbandoned\r\nAbbott and Costello Meet the Killer\r\nAbominable Dr. Phibes\r\nAbominable Snowman\r\nAbove the Street\r\nAbsent-Minded Professor\r\nAbyss\r\n...\r\nZoom \r\nZoot Suit \r\nZorba the Greek \r\nZorn's Lemma \r\nZorro \r\nZotz! \r\nZouzou \r\nZozo\r\n```\r\n\r\nHere are the kind of problems we'll solve around the movie names:\r\n\r\n* Finding movies that belong to a specific franchise (e.g. `Star Wars`).\r\n* Finding movies from multiple franchise (e.g. all movies from `Star Wars` as well as `Star Trek`).\r\n* Skipping movies from a specific franchise (e.g. all movies other than `Superman`). Or even all `Super` movies that are not `Superman`.\r\n* Finding movies that use a year in their name (e.g. `2001: A Space Odyssey`).\r\n* Finding movies with at least one five letter word (e.g. `Superman` is ok but `Cat and Dog` is not).\r\n	1	2017-07-04 13:34:51.763	2017-08-13 21:55:06.042	{}
7	regex-matching-literals	Regex - Matching Literals	32	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names.  Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n\r\nSolution: Star Wars:\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n\r\nSolution: Star Trek:\r\n--\r\n	1	2017-07-04 13:34:51.763	2017-08-17 21:38:35.464	{}
\.


--
-- Name: topics_id_seq; Type: SEQUENCE SET; Schema: public; Owner: turtleprogrammer
--

SELECT pg_catalog.setval('topics_id_seq', 28, true);


--
-- Data for Name: users; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY users (id, email, name, avatar, active, superuser, created_at, updated_at) FROM stdin;
1	manasgarg@gmail.com	Manas Garg	https://lh5.googleusercontent.com/-xWt1x_QePE8/AAAAAAAAAAI/AAAAAAAAAyc/EQvJajrcCX4/photo.jpg	t	t	2017-07-02 21:17:16.672572	2017-07-02 21:17:16.6726
\.


--
-- Name: users_id_seq; Type: SEQUENCE SET; Schema: public; Owner: turtleprogrammer
--

SELECT pg_catalog.setval('users_id_seq', 1, true);


--
-- Name: exercise_history exercise_history_pkey; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY exercise_history
    ADD CONSTRAINT exercise_history_pkey PRIMARY KEY (user_id, exercise_id);


--
-- Name: exercises exercises_pkey; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY exercises
    ADD CONSTRAINT exercises_pkey PRIMARY KEY (uuid);


--
-- Name: quizes quizes_pkey; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY quizes
    ADD CONSTRAINT quizes_pkey PRIMARY KEY (uuid);


--
-- Name: topic_drafts topic_drafts_pkey; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topic_drafts
    ADD CONSTRAINT topic_drafts_pkey PRIMARY KEY (topic_id, author_id);


--
-- Name: topic_history topic_history_pkey; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topic_history
    ADD CONSTRAINT topic_history_pkey PRIMARY KEY (user_id, topic_id);


--
-- Name: topics topics_pkey; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topics
    ADD CONSTRAINT topics_pkey PRIMARY KEY (id);


--
-- Name: topics topics_slug_key; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topics
    ADD CONSTRAINT topics_slug_key UNIQUE (slug);


--
-- Name: users users_email_key; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_email_key UNIQUE (email);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: topic_drafts topic_drafts_author_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topic_drafts
    ADD CONSTRAINT topic_drafts_author_id_fkey FOREIGN KEY (author_id) REFERENCES users(id);


--
-- Name: topic_drafts topic_drafts_topic_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topic_drafts
    ADD CONSTRAINT topic_drafts_topic_id_fkey FOREIGN KEY (topic_id) REFERENCES topics(id);


--
-- Name: topics topics_author_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topics
    ADD CONSTRAINT topics_author_id_fkey FOREIGN KEY (author_id) REFERENCES users(id);


--
-- PostgreSQL database dump complete
--

