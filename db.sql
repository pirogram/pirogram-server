--
-- PostgreSQL database dump
--

-- Dumped from database version 9.6.3
-- Dumped by pg_dump version 9.6.3

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET search_path = public, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: exercise_history; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE exercise_history (
    user_id integer NOT NULL,
    exercise_id character varying(42) NOT NULL,
    solution jsonb,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    primary key (user_id, exercise_id)
);

CREATE TABLE topic_history (
    user_id integer NOT NULL,
    topic_id integer NOT NULL,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    primary key (user_id, topic_id)
);

ALTER TABLE exercise_history OWNER TO turtleprogrammer;

CREATE TABLE topic_history (
    user_id integer NOT NULL,
    topic_id integer NOT NULL,
    created_at timestamp without time zone
);

--
-- Name: topic_drafts; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE topic_drafts (
    topic_id integer NOT NULL,
    author_id integer NOT NULL,
    title character varying(256) NOT NULL,
    markdown text NOT NULL,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


ALTER TABLE topic_drafts OWNER TO turtleprogrammer;

--
-- Name: topic_history; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE topic_edit_history (
    id integer NOT NULL,
    topic_id integer,
    author_id integer,
    slug character varying(256) NOT NULL,
    title character varying(256) NOT NULL,
    version_number integer NOT NULL,
    markdown text NOT NULL,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


ALTER TABLE topic_edit_history OWNER TO turtleprogrammer;

--
-- Name: topic_history_id_seq; Type: SEQUENCE; Schema: public; Owner: turtleprogrammer
--

CREATE SEQUENCE topic_edit_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE topic_edit_history_id_seq OWNER TO turtleprogrammer;

--
-- Name: topic_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: turtleprogrammer
--

ALTER SEQUENCE topic_edit_history_id_seq OWNED BY topic_edit_history.id;

CREATE TABLE exercises (
    uuid varchar(36) primary key,
    type varchar(64) NOT NULL,
    markdown TEXT NOT NULL,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);

--
-- Name: topics; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE topics (
    id integer NOT NULL,
    slug character varying(256),
    title character varying(256) NOT NULL,
    version_number integer NOT NULL,
    markdown text NOT NULL,
    content_list jsonb default '[]'::JSON,
    author_id integer,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);

ALTER TABLE topics OWNER TO turtleprogrammer;

--
-- Name: topics_id_seq; Type: SEQUENCE; Schema: public; Owner: turtleprogrammer
--

CREATE SEQUENCE topics_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE topics_id_seq OWNER TO turtleprogrammer;

--
-- Name: topics_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: turtleprogrammer
--

ALTER SEQUENCE topics_id_seq OWNED BY topics.id;


--
-- Name: users; Type: TABLE; Schema: public; Owner: turtleprogrammer
--

CREATE TABLE users (
    id integer NOT NULL,
    email character varying(256) NOT NULL,
    name character varying(256),
    avatar character varying(256),
    active boolean,
    superuser boolean,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


ALTER TABLE users OWNER TO turtleprogrammer;

--
-- Name: users_id_seq; Type: SEQUENCE; Schema: public; Owner: turtleprogrammer
--

CREATE SEQUENCE users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE users_id_seq OWNER TO turtleprogrammer;

--
-- Name: users_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: turtleprogrammer
--

ALTER SEQUENCE users_id_seq OWNED BY users.id;


--
-- Name: topic_history id; Type: DEFAULT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topic_history ALTER COLUMN id SET DEFAULT nextval('topic_history_id_seq'::regclass);


--
-- Name: topics id; Type: DEFAULT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topics ALTER COLUMN id SET DEFAULT nextval('topics_id_seq'::regclass);


--
-- Name: users id; Type: DEFAULT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY users ALTER COLUMN id SET DEFAULT nextval('users_id_seq'::regclass);


--
-- Data for Name: exercise_history; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY exercise_history (user_id, exercise_id, solution, created_at) FROM stdin;
1	f1de4844-1927-4b7e-a687-43ba797f1779	\N	\N
1	6c410957-58ab-4b59-9ebf-5b3c81ce178a	{"regex": "Star Wars:"}	\N
\.


--
-- Data for Name: topic_drafts; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY topic_drafts (topic_id, author_id, title, markdown, created_at, updated_at) FROM stdin;
4	1	Regex - Gibberish to Rescue	To an untrained eye, regular expressions look like gibberish and that's how we'll treat them in this section. Once you are done with the entire material, they'll not be gibberish anymore. We'll get there...\n\n#### Revisiting the Problem\n\nWe want to extract the website name (i.e. `wattpad`) from different ways in which it is given to us (i.e. `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children`).\n\n#### The Solution\n\nThe solution has two parts to it:\n\n* First, we define a pattern that would match all variations in which people mentioned the site name (i.e. `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children`)\n* Next, we'll use the pattern to extract the actual site name (i.e. `wattpad`) from its variations.\n\nHere is the gibberish (aka regular expression) that describes the pattern we are looking for. Don't even try to understand it for now. Just take it as it is.\n\n```Python\nREGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\n```\n\nHere is the code that makes use of `REGEX_GIBBERISH`, applies it to the site name as entered by the students and gives us the bare bone site name as we want to see.\n\n```Python\n# Import the regular expression module\nimport re\n\n# Define the regex pattern\nREGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\n\n# Apply the pattern to whatever site name was entered by students \n# and get the barebone site name.\nre.search(REGEX_GIBBERISH, "...site name...").group("site")\n```\n\nLet's see this code in action now.\n\n```Python\n>>> import re\n>>> REGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\n>>> \n>>> re.search(REGEX_GIBBERISH, "wattpad").group("site")\n'wattpad'\n>>> re.search(REGEX_GIBBERISH, "wattpad.com").group("site")\n'wattpad'\n>>> re.search(REGEX_GIBBERISH, "www.wattpad.com").group("site")\n'wattpad'\n>>> re.search(REGEX_GIBBERISH, "http://www.wattpad.com").group("site")\n'wattpad'\n>>> re.search(REGEX_GIBBERISH, "https://www.wattpad.com").group("site")\n'wattpad'\n>>> re.search(REGEX_GIBBERISH, "https://www.wattpad.com/tags/children").group("site")\n'wattpad'\n>>> \n```\n\nFascinating. Isn't it?	2017-07-04 00:32:00.208968	2017-07-04 01:07:16.796018
\.


--
-- Data for Name: topic_history; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY topic_history (id, topic_id, author_id, slug, title, version_number, markdown, created_at, updated_at) FROM stdin;
1	1	1	regex-introduction	Regular Expression	1	Regular expressions are a powerful way to find patterns in text. Once you find a pattern, you can also extract the matching portion of the text or you can replace it with some other text. They are implemented in the `re` module of `Python`. Here is a quick example where we check if a movie name has `War` in the name or not.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> name = "Star Wars: The Last Jedi"\r\n>>> re.search(r"War", name)\r\n<_sre.SRE_Match object; span=(5, 8), match='War'>\r\n>>> \r\n>>> name = "Star Trek: Discovery"\r\n>>> re.search(r"War", name)\r\n>>> \r\n```\r\n\r\nThe pattern we are looking for is `"War"` and it is (optionally) prefixed with `r` to indicate that it’s a regular expression. When we search for this pattern in the name `"Star Wars: The Last Jedi"`, we find a match that spans index 5 to index 8. When we search for this pattern in name `"Star Trek: Discovery"`, we don’t find a match.\r\n\r\nHere is a quick example to search for this pattern in a list of names.\r\n\r\n```Python\r\n# From the given list of names, select the ones that have War.\r\nimport re\r\nmovies = [\r\n\t\t"Star Wars: The Last Jedi",\r\n\t\t"Star Wars: The Force Awakens",\r\n\t\t"Star Trek: Discovery",\r\n\t\t"Star Trek: Voyager",\r\n\t\t"2001: A Space Odyssey",\r\n\t\t"Star Dust"\r\n]\r\nselected_movies = [movie for movie in movies if re.search(r"War", movie) != None]\r\nprint(selected_movies)\r\n```\r\n\r\nRegular expressions are described using a formal language that provides us with grammar to say things like:\r\n\r\n- which characters are allowed and which ones are not.\r\n- how do the allowed characters repeat (e.g. if you are searching for year, digits 0-9 repeat 4 times).\r\n- how does the pattern align with boundaries of line or word (e.g. match the lines that begin with word *The*).\r\n- many more things as we’ll see going forward.\r\n\r\n	2017-07-03 05:15:56.705828	2017-07-03 05:15:56.705856
2	1	1	regex-introduction	Regex Introduction	2	Regular expressions are a powerful way to find patterns in text. Once you find a pattern, you can also extract the matching portion of the text or you can replace it with some other text. They are implemented in the `re` module of `Python`. Here is a quick example where we check if a movie name has `War` in the name or not.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> name = "Star Wars: The Last Jedi"\r\n>>> re.search(r"War", name)\r\n<_sre.SRE_Match object; span=(5, 8), match='War'>\r\n>>> \r\n>>> name = "Star Trek: Discovery"\r\n>>> re.search(r"War", name)\r\n>>> \r\n```\r\n\r\nThe pattern we are looking for is `"War"` and it is (optionally) prefixed with `r` to indicate that it’s a regular expression. When we search for this pattern in the name `"Star Wars: The Last Jedi"`, we find a match that spans index 5 to index 8. When we search for this pattern in name `"Star Trek: Discovery"`, we don’t find a match.\r\n\r\nHere is a quick example to search for this pattern in a list of names.\r\n\r\n```Python\r\n# From the given list of names, select the ones that have War.\r\nimport re\r\nmovies = [\r\n\t\t"Star Wars: The Last Jedi",\r\n\t\t"Star Wars: The Force Awakens",\r\n\t\t"Star Trek: Discovery",\r\n\t\t"Star Trek: Voyager",\r\n\t\t"2001: A Space Odyssey",\r\n\t\t"Star Dust"\r\n]\r\nselected_movies = [movie for movie in movies if re.search(r"War", movie) != None]\r\nprint(selected_movies)\r\n```\r\n\r\nRegular expressions are described using a formal language that provides us with grammar to say things like:\r\n\r\n- which characters are allowed and which ones are not.\r\n- how do the allowed characters repeat (e.g. if you are searching for year, digits 0-9 repeat 4 times).\r\n- how does the pattern align with boundaries of line or word (e.g. match the lines that begin with word *The*).\r\n- many more things as we’ll see going forward.\r\n\r\n	2017-07-03 05:24:38.94264	2017-07-03 05:24:38.942671
3	1	1	regex-introduction	Regex Introduction	3	Regular expressions are a powerful way to find patterns in text. Once you find a pattern, you can also extract the matching portion of the text or you can replace it with some other text. They are implemented in the `re` module of `Python`. Here is a quick example where we check if a movie name has `War` in the name or not.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> name = "Star Wars: The Last Jedi"\r\n>>> re.search(r"War", name)\r\n<_sre.SRE_Match object; span=(5, 8), match='War'>\r\n>>> \r\n>>> name = "Star Trek: Discovery"\r\n>>> re.search(r"War", name)\r\n>>> \r\n```\r\n\r\n\r\nThe pattern we are looking for is `"War"` and it is (optionally) prefixed with `r` to indicate that it’s a regular expression. When we search for this pattern in the name `"Star Wars: The Last Jedi"`, we find a match that spans index 5 to index 8. When we search for this pattern in name `"Star Trek: Discovery"`, we don’t find a match.\r\n\r\nHere is a quick example to search for this pattern in a list of names.\r\n\r\n```Python\r\n# From the given list of names, select the ones that have War.\r\nimport re\r\nmovies = [\r\n\t\t"Star Wars: The Last Jedi",\r\n\t\t"Star Wars: The Force Awakens",\r\n\t\t"Star Trek: Discovery",\r\n\t\t"Star Trek: Voyager",\r\n\t\t"2001: A Space Odyssey",\r\n\t\t"Star Dust"\r\n]\r\nselected_movies = [movie for movie in movies if re.search(r"War", movie) != None]\r\nprint(selected_movies)\r\n```\r\n\r\nRegular expressions are described using a formal language that provides us with grammar to say things like:\r\n\r\n- which characters are allowed and which ones are not.\r\n- how do the allowed characters repeat (e.g. if you are searching for year, digits 0-9 repeat 4 times).\r\n- how does the pattern align with boundaries of line or word (e.g. match the lines that begin with word *The*).\r\n- many more things as we’ll see going forward.\r\n\r\n	2017-07-03 17:29:12.480584	2017-07-03 17:29:12.480611
4	1	1	regex-introduction	Regex Introduction	4	Regular expressions are a powerful way to find patterns in text. Once you find a pattern, you can also extract the matching portion of the text or you can replace it with some other text. They are implemented in the `re` module of `Python`. Here is a quick example where we check if a movie name has `War` in the name or not.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> name = "Star Wars: The Last Jedi"\r\n>>> re.search(r"War", name)\r\n<_sre.SRE_Match object; span=(5, 8), match='War'>\r\n>>> \r\n>>> name = "Star Trek: Discovery"\r\n>>> re.search(r"War", name)\r\n>>> \r\n```\r\n\r\n\r\nThe pattern we are looking for is `"War"` and it is (optionally) prefixed with `r` to indicate that it’s a regular expression. When we search for this pattern in the name `"Star Wars: The Last Jedi"`, we find a match that spans index 5 to index 8. When we search for this pattern in name `"Star Trek: Discovery"`, we don’t find a match.\r\n\r\nHere is a quick example to search for this pattern in a list of names.\r\n\r\n```Python\r\n# From the given list of names, select the ones that have War.\r\nimport re\r\nmovies = [\r\n\t\t"Star Wars: The Last Jedi",\r\n\t\t"Star Wars: The Force Awakens",\r\n\t\t"Star Trek: Discovery",\r\n\t\t"Star Trek: Voyager",\r\n\t\t"2001: A Space Odyssey",\r\n\t\t"Star Dust"\r\n]\r\nselected_movies = [movie for movie in movies if re.search(r"War", movie) != None]\r\nprint(selected_movies)\r\n```\r\n\r\nRegular expressions are described using a formal language that provides us with grammar to say things like:\r\n\r\n- which characters are allowed and which ones are not.\r\n- how do the allowed characters repeat (e.g. if you are searching for year, digits 0-9 repeat 4 times).\r\n- how does the pattern align with boundaries of line or word (e.g. match the lines that begin with word *The*).\r\n- many more things as we’ll see going forward.\r\n\r\n	2017-07-03 17:30:50.262711	2017-07-03 17:30:50.262744
60	10	1	regex-matching-one-of-many-characters	Regex - Matching One of Many Characters	4	An interesting problem to solve is to match movies that mention a year in their name. Sample movie names are: `2001: A Space Odyssey`, `Dream Team 1935`, `Class of 1999` etc. To keep it simple for now, a year is four digits out of which first digit could be 1 or 2 and rest of the digits could go from 0 to 9. From what we have learnt so far, we could define a pattern like this for our purpose.\r\n\r\n```Python\r\nREGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n```\r\n\r\nLet's put it to use and see it working.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nThe pattern works but it's quite cumbersome. Regex provides another expression that we can use here. `(0|1|2|3|4|5|6|7|8|9)` could be written as `[0123456789]`. When you put multiple characters in `[]`, regex would look for matching one of these.\r\n\r\nWe can now rewrite the previous expression as:\r\n\r\n```Python\r\nREGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n```\r\n\r\nLet's try out the new pattern.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nIn fact, such needs are so common that there is a further shortcut to matching digits 0-9: `[0-9]`. So, we can once again re-write the expression as `[12][0-9][0-9][0-9]`. Here is how we use it:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0-9][0-9][0-9]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nNice. Isn't it?\r\n\r\n--regexquiz\r\nTry different regex variations that we discussed just now to select movie names that have a year in their name.\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] 1984\r\n  [ ] Gone With The Wind\r\n  [ ] Star Wars: The Last Jedi\r\n--\r\n\r\n## Ranges and Alphabets\r\n\r\nRanges work not only for digits but also for alphabets. So, you could say `r"[A-Z]"` to match any upper case letter, `r"[a-z]"` to match any lower case letter, `r"[A-Za-z]"` to match all English alphabet letters, `r"[A-Za-z0-9]"` to match any alphanumeric characters. In fact, you can also say `r"[AM-PZ]"` and it would match letters A, M, N, O, P, Z.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> re.search(r"[A-Z]", "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(6, 7), match='A'>\r\n>>> \r\n>>> re.search(r"[A-Z]", "1984")\r\n>>>\r\n```\r\n\r\nHere, we are looking for a movie name with an uppercase letter. The movie `2001: A Space Odyssey` is a match, whereas, the movie `1984` is not a match.\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `r"[0-9][0-9][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `r"[0-29][0-5][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [ ] `r"Super[mg][ai][nrl]"`\r\n  [#] `r"Super[mg][ai][nr]l"`\r\n  [#] `r"Super[mg][ai](n|rl)"`\r\n  [ ] `r"Super[mangirl]"`\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that have at least one 4 letter word in the middle of movie name.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that use a number within a word.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that have a bat, cat or rat in the name. Use the shortest possible regex.\r\n  [#] Bat Whispers\r\n  [#] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n## Matching absence of characters\r\n\r\nJust like you can match for presence of certain characters, you can also match for their absence. `r"[^A-Z]"` will match all characters except uppercase letters. `r"[^BCR]at"` will match `Sat` but it will not match `Bat`, `Cat` and `Rat`. Simple trick here is to use `^`. `[BCR]` means match B, C or R but `[^BCR]` means match anything other than B, C or R.\r\n\r\n--mcquiz\r\nWhich of the following match regex `r"[0-1][0-9]:[0-6][0-9] [^P]M"`:\r\n  [#] 04:00 AM\r\n  [#] 11:59 AM\r\n  [ ] 06:00 PM\r\n  [ ] 09:23 PM\r\n--\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `r"[^3-9][0-5][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [ ] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n	2017-07-04 18:03:20.669866	2017-07-04 18:03:20.669931
61	10	1	regex-matching-one-of-many-characters	Regex - Matching One of Many Characters	5	An interesting problem to solve is to match movies that mention a year in their name. Sample movie names are: `2001: A Space Odyssey`, `Dream Team 1935`, `Class of 1999` etc. To keep it simple for now, a year is four digits out of which first digit could be 1 or 2 and rest of the digits could go from 0 to 9. From what we have learnt so far, we could define a pattern like this for our purpose.\r\n\r\n```Python\r\nREGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n```\r\n\r\nLet's put it to use and see it working.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nThe pattern works but it's quite cumbersome. Regex provides another expression that we can use here. `(0|1|2|3|4|5|6|7|8|9)` could be written as `[0123456789]`. When you put multiple characters in `[]`, regex would look for matching one of these.\r\n\r\nWe can now rewrite the previous expression as:\r\n\r\n```Python\r\nREGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n```\r\n\r\nLet's try out the new pattern.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nIn fact, such needs are so common that there is a further shortcut to matching digits 0-9: `[0-9]`. So, we can once again re-write the expression as `[12][0-9][0-9][0-9]`. Here is how we use it:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0-9][0-9][0-9]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nNice. Isn't it?\r\n\r\n--regexquiz\r\nTry different regex variations that we discussed just now to select movie names that have a year in their name.\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] 1984\r\n  [ ] Gone With The Wind\r\n  [ ] Star Wars: The Last Jedi\r\n--\r\n\r\n## Ranges and Alphabets\r\n\r\nRanges work not only for digits but also for alphabets. So, you could say `r"[A-Z]"` to match any upper case letter, `r"[a-z]"` to match any lower case letter, `r"[A-Za-z]"` to match all English alphabet letters, `r"[A-Za-z0-9]"` to match any alphanumeric characters. In fact, you can also say `r"[AM-PZ]"` and it would match letters A, M, N, O, P, Z.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> re.search(r"[A-Z]", "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(6, 7), match='A'>\r\n>>> \r\n>>> re.search(r"[A-Z]", "1984")\r\n>>>\r\n```\r\n\r\nHere, we are looking for a movie name with an uppercase letter. The movie `2001: A Space Odyssey` is a match, whereas, the movie `1984` is not a match.\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `r"[0-9][0-9][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `r"[0-29][0-5][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [ ] `r"Super[mg][ai][nrl]"`\r\n  [#] `r"Super[mg][ai][nr]l"`\r\n  [#] `r"Super[mg][ai](n|rl)"`\r\n  [ ] `r"Super[mangirl]"`\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that have at least one 4 letter word in the middle of movie name.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that use a number within a word.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that have a bat, cat or rat in the name. Use the shortest possible regex.\r\n  [#] Bat Whispers\r\n  [#] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n## Matching absence of characters\r\n\r\nJust like you can match for presence of certain characters, you can also match for their absence. `[^A-Z]` will match all characters except uppercase letters. `[^BCR]at` will match `Sat` but it will not match `Bat`, `Cat` and `Rat`. Simple trick here is to use `^`. `[BCR]` means match B, C or R but `[^BCR]` means match anything other than B, C or R.\r\n\r\n--mcquiz\r\nWhich of the following match regex `[0-1][0-9]:[0-6][0-9] [^P]M`:\r\n  [#] 04:00 AM\r\n  [#] 11:59 AM\r\n  [ ] 06:00 PM\r\n  [ ] 09:23 PM\r\n--\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `[^3-9][0-5][0-9][0-9]:`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [ ] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n	2017-07-04 18:03:20.669866	2017-07-04 18:03:20.669931
62	10	1	regex-matching-one-of-many-characters	Regex - Matching One of Many Characters	6	An interesting problem to solve is to match movies that mention a year in their name. Sample movie names are: `2001: A Space Odyssey`, `Dream Team 1935`, `Class of 1999` etc. To keep it simple for now, a year is four digits out of which first digit could be 1 or 2 and rest of the digits could go from 0 to 9. From what we have learnt so far, we could define a pattern like this for our purpose.\r\n\r\n```Python\r\nREGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n```\r\n\r\nLet's put it to use and see it working.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nThe pattern works but it's quite cumbersome. Regex provides another expression that we can use here. `(0|1|2|3|4|5|6|7|8|9)` could be written as `[0123456789]`. When you put multiple characters in `[]`, regex would look for matching one of these.\r\n\r\nWe can now rewrite the previous expression as:\r\n\r\n```Python\r\nREGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n```\r\n\r\nLet's try out the new pattern.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nIn fact, such needs are so common that there is a further shortcut to matching digits 0-9: `[0-9]`. So, we can once again re-write the expression as `[12][0-9][0-9][0-9]`. Here is how we use it:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0-9][0-9][0-9]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nNice. Isn't it?\r\n\r\n--regexquiz\r\nTry different regex variations that we discussed just now to select movie names that have a year in their name.\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] 1984\r\n  [ ] Gone With The Wind\r\n  [ ] Star Wars: The Last Jedi\r\n--\r\n\r\n## Ranges and Alphabets\r\n\r\nRanges work not only for digits but also for alphabets. So, you could say `r"[A-Z]"` to match any upper case letter, `r"[a-z]"` to match any lower case letter, `r"[A-Za-z]"` to match all English alphabet letters, `r"[A-Za-z0-9]"` to match any alphanumeric characters. In fact, you can also say `r"[AM-PZ]"` and it would match letters A, M, N, O, P, Z.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> re.search(r"[A-Z]", "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(6, 7), match='A'>\r\n>>> \r\n>>> re.search(r"[A-Z]", "1984")\r\n>>>\r\n```\r\n\r\nHere, we are looking for a movie name with an uppercase letter. The movie `2001: A Space Odyssey` is a match, whereas, the movie `1984` is not a match.\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `r"[0-9][0-9][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `r"[0-29][0-5][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [ ] `r"Super[mg][ai][nrl]"`\r\n  [#] `r"Super[mg][ai][nr]l"`\r\n  [#] `r"Super[mg][ai](n|rl)"`\r\n  [ ] `r"Super[mangirl]"`\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that have at least one 4 letter word in the middle of movie name.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that use a number within a word.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that have a bat, cat or rat in the name. Use the shortest possible regex.\r\n  [#] Bat Whispers\r\n  [#] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n## Matching absence of characters\r\n\r\nJust like you can match for presence of certain characters, you can also match for their absence. `[^A-Z]` will match all characters except uppercase letters. `[^BCR]at` will match `Sat` but it will not match `Bat`, `Cat` and `Rat`. Simple trick here is to use `^`. `[BCR]` means match B, C or R but `[^BCR]` means match anything other than B, C or R.\r\n\r\n--mcquiz\r\nWhich of the following match regex `[0-1][0-9]:[0-6][0-9] [^P]M`:\r\n  [#] 04:00 AM\r\n  [#] 11:59 AM\r\n  [ ] 06:00 PM\r\n  [ ] 09:23 PM\r\n--\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `[^3-9][0-5][0-9][0-9]:`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [ ] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n	2017-07-04 18:03:20.669866	2017-07-04 18:03:20.669931
5	1	1	regex-introduction	Regex Introduction	5	Regular expressions are a powerful way to find patterns in text. Once you find a pattern, you can also extract the matching portion of the text or you can replace it with some other text. They are implemented in the `re` module of `Python`. Here is a quick example where we check if a movie name has `War` in the name or not.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> name = "Star Wars: The Last Jedi"\r\n>>> re.search(r"War", name)\r\n<_sre.SRE_Match object; span=(5, 8), match='War'>\r\n>>> \r\n>>> name = "Star Trek: Discovery"\r\n>>> re.search(r"War", name)\r\n>>> # Nothing returned.\r\n```\r\n\r\n\r\nThe pattern we are looking for is `"War"` and it is (optionally) prefixed with `r` to indicate that it’s a regular expression. When we search for this pattern in the name `"Star Wars: The Last Jedi"`, we find a match that spans index 5 to index 8. When we search for this pattern in name `"Star Trek: Discovery"`, we don’t find a match.\r\n\r\nHere is a quick example to search for this pattern in a list of names.\r\n\r\n```Python\r\n# From the given list of names, select the ones that have War.\r\nimport re\r\nmovies = [\r\n\t\t"Star Wars: The Last Jedi",\r\n\t\t"Star Wars: The Force Awakens",\r\n\t\t"Star Trek: Discovery",\r\n\t\t"Star Trek: Voyager",\r\n\t\t"2001: A Space Odyssey",\r\n\t\t"Star Dust"\r\n]\r\nselected_movies = [movie for movie in movies if re.search(r"War", movie) != None]\r\nprint(selected_movies)\r\n```\r\n\r\nRegular expressions are described using a formal language that provides us with grammar to say things like:\r\n\r\n- which characters are allowed and which ones are not.\r\n- how do the allowed characters repeat (e.g. if you are searching for year, digits 0-9 repeat 4 times).\r\n- how does the pattern align with boundaries of line or word (e.g. match the lines that begin with word *The*).\r\n- many more things as we’ll see going forward.\r\n\r\n	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
6	1	1	regex-introduction	Regex Introduction	6	Regular expressions are a powerful way to find patterns in text. Once you find a pattern, you can also extract the matching portion of the text or you can replace it with some other text. They are implemented in the `re` module of `Python`. Here is a quick example where we check if a movie name has `War` in the name or not.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> name = "Star Wars: The Last Jedi"\r\n>>> re.search(r"War", name)\r\n<_sre.SRE_Match object; span=(5, 8), match='War'>\r\n>>> \r\n>>> name = "Star Trek: Discovery"\r\n>>> re.search(r"War", name)\r\n>>> # Nothing returned.\r\n```\r\n\r\nThe pattern we are looking for is `"War"` and it is (optionally) prefixed with `r` to indicate that it’s a regular expression. When we search for this pattern in the name `"Star Wars: The Last Jedi"`, we find a match that spans index 5 to index 8. When we search for this pattern in name `"Star Trek: Discovery"`, we don’t find a match.\r\n\r\nHere is a quick example to search for this pattern in a list of names.\r\n\r\n```Python\r\n# From the given list of names, select the ones that have War.\r\nimport re\r\nmovies = [\r\n\t\t"Star Wars: The Last Jedi",\r\n\t\t"Star Wars: The Force Awakens",\r\n\t\t"Star Trek: Discovery",\r\n\t\t"Star Trek: Voyager",\r\n\t\t"2001: A Space Odyssey",\r\n\t\t"Star Dust"\r\n]\r\nselected_movies = [movie for movie in movies if re.search(r"War", movie) != None]\r\nprint(selected_movies)\r\n```\r\n\r\nRegular expressions are described using a formal language that provides us with grammar to say things like:\r\n\r\n- which characters are allowed and which ones are not.\r\n- how do the allowed characters repeat (e.g. if you are searching for year, digits 0-9 repeat 4 times).\r\n- how does the pattern align with boundaries of line or word (e.g. match the lines that begin with word *The*).\r\n- many more things as we’ll see going forward.\r\n\r\n	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
7	1	1	regex-introduction	Regex Introduction	7	Regular Expression is a language to define patterns in textual content. Once you have defined a pattern, you can do a couple of things:\r\n\r\n* **Search:** is this pattern present in a given piece of content?\r\n* **Extract:** what part of the content matches this pattern?\r\n* **Substitute:** replace the pattern matching part with some other text.\r\n\r\n## Regex Example\r\n\r\nLet's make things concrete. You are given the following content. Do you see a pattern here?\r\n\r\n```\r\ngoogle.com, facebook.com, yahoo.com\r\n```\r\n\r\nIs there a pattern across `google.com`, `facebook.com`, `yahoo.com`? How about `www.google.com`, `www.facebook.com`, `www.yahoo.com`? What if you add `news.google.com` to the mix? Is there still a pattern here? How about `http://www.google.com`, `http://news.google.com` and `http://www.facebook.com`?\r\n\r\nWhat if you are given the problem to extract 	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
8	1	1	regex-introduction	Regex Introduction	8	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.\r\n\r\n## 	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
9	1	1	regex-introduction	Regex Introduction	9	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.\r\n\r\n## Setting the stage\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to all kids in your school. The form looks like this:\r\n\r\n![Google Spreadsheet Form to Ask Students for Favorite Website](/static/img/regex/favorite-website-form.png)\r\n\r\n\r\n\r\n\r\n	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
10	1	1	regex-introduction	Regex Introduction	10	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.\r\n\r\n## Setting the stage\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to all kids in your school. The form looks like this:\r\n\r\n<div class="ui two columns"> <img src="/static/img/regex/favorite-website-form.png" class="ui image"/> </div>\r\n\r\n![Google Spreadsheet Form to Ask Students for Favorite Website](/static/img/regex/favorite-website-form.png)\r\n\r\n\r\n\r\n\r\n	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
11	1	1	regex-introduction	Regex Introduction	11	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.\r\n\r\n## Setting the stage\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to all kids in your school. The form looks like this:\r\n\r\n<div class="ui two columns"> <img src="/static/img/regex/favorite-website-form.png" class="ui small image"/> </div>\r\n\r\n\r\n\r\n	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
12	1	1	regex-introduction	Regex Introduction	12	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.\r\n\r\n## Setting the stage\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to all kids in your school. The form looks like this:\r\n\r\n<div class="ui two columns"> <img src="/static/img/regex/favorite-website-form.png" class="ui  image"/> </div>\r\n\r\n\r\n\r\n	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
13	1	1	regex-introduction	Regex Introduction	13	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.\r\n\r\n## Setting the stage\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to all kids in your school. The form looks like this:\r\n\r\n<div><img src="/static/img/regex/favorite-website-form.png" class="ui medium image"/> </div>\r\n\r\n\r\n\r\n	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
36	4	1	regex-enters-the-gibberish	Regex - Gibberish to Rescue	2	To an untrained eye, regular expressions look like gibberish and that's how we'll treat them in this section. Once you are done with the entire material, they'll not be gibberish anymore. We'll get there...\r\n\r\n#### Revisiting the Problem\r\n\r\nWe want to extract the website name (i.e. `wattpad`) from different ways in which it is given to us (i.e. `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children`).\r\n\r\n#### The Solution\r\n\r\nThe solution has two parts to it:\r\n\r\n* First, we define a pattern that would match all variations in which people mentioned the site name (i.e. `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children`)\r\n* Next, we'll use the pattern to extract the actual site name (i.e. `wattpad`) from its variations.\r\n\r\nHere is the gibberish (aka regular expression) that describes the pattern we are looking for. Don't even try to understand it for now. Just take it as it is.\r\n\r\n```Python\r\nREGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\r\n```\r\n\r\nHere is the code that makes use of `REGEX_GIBBERISH`, applies it to the site name as entered by the students and gives us the bare bone site name as we want to see.\r\n\r\n```Python\r\n# Import the regular expression module\r\nimport re\r\n\r\n# Define the regex pattern\r\nREGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\r\n\r\n# Apply the pattern to whatever site name was entered by students \r\n# and get the barebone site name.\r\nre.search(REGEX_GIBBERISH, "...site name...").group("site")\r\n```\r\n\r\nLet's see this code in action now.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\r\n>>> \r\n>>> re.search(REGEX_GIBBERISH, "wattpad").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "www.wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "http://www.wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "https://www.wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "https://www.wattpad.com/tags/children").group("site")\r\n'wattpad'\r\n>>> \r\n```\r\n\r\nFascinating. Isn't it?	2017-07-04 00:32:00.207168	2017-07-04 00:32:00.207197
14	1	1	regex-introduction	Regex Introduction	14	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.\r\n\r\n## Setting the stage\r\n\r\n<img src="/static/img/regex/favorite-website-form.png" class="ui medium image"/>\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to all kids in your school. \r\n\r\n\r\n\r\n\r\n	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
15	1	1	regex-introduction	Regex Introduction	15	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.\r\n\r\n## Setting the stage\r\n\r\n<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to all kids in your school. \r\n\r\n\r\n\r\n\r\n	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
16	1	1	regex-introduction	Regex Introduction	16	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.\r\n\r\n## Setting the stage\r\n\r\n<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated medium image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n\r\n\r\n\r\n	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
17	1	1	regex-introduction	Regex Introduction	17	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.\r\n\r\n## Setting the stage\r\n\r\n<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n---\r\n\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated medium image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n\r\n\r\n\r\n	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
18	1	1	regex-introduction	Regex Introduction	18	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.\r\n\r\n## Setting the stage\r\n\r\n<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui divider"></div>\r\n\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated medium image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n\r\n\r\n\r\n	2017-07-03 17:52:07.597151	2017-07-03 17:52:07.597187
19	1	1	regex-introduction	Regex Introduction	19	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.	2017-07-03 23:19:12.450703	2017-07-03 23:19:12.450731
20	2	1	regex-setting-the-stage	Regex - Setting the Stage	1	<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui divider"></div>\r\n\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated medium image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n\r\n\r\n\r\n	2017-07-03 23:19:12.450703	2017-07-03 23:19:12.450731
21	2	1	regex-setting-the-stage	Regex - Setting the Stage	2	<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated medium image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n\r\n\r\n\r\n	2017-07-03 23:19:12.450703	2017-07-03 23:19:12.450731
22	2	1	regex-setting-the-stage	Regex - Setting the Stage	3	<img src="/static/img/regex/favorite-website-form.png" class="ui right floated small image"/>\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated tiny image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n\r\n\r\n\r\n	2017-07-03 23:19:12.450703	2017-07-03 23:19:12.450731
23	2	1	regex-setting-the-stage	Regex - Setting the Stage	4	<img src="/static/img/regex/favorite-website-form.png" class="ui right floated small image"/>\r\n\r\n## Stage 1\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 2\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated tiny image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n\r\n\r\n\r\n	2017-07-03 23:19:12.450703	2017-07-03 23:19:12.450731
24	2	1	regex-setting-the-stage	Regex - Setting the Stage	5	<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\n## Stage 1\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 2\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated small image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n\r\n\r\n\r\n	2017-07-03 23:19:12.450703	2017-07-03 23:19:12.450731
25	2	1	regex-setting-the-stage	Regex - Setting the Stage	6	<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\n## Stage 1\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 2\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated small image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n## Stage 3\r\n\r\n\r\n\r\n\r\n	2017-07-03 23:19:12.450703	2017-07-03 23:19:12.450731
38	6	1	regex-matching-characters	Regex - Matching Characters	1	In this section, we'll solve problems that revolve around presence or absence of certain characters in the text. For most of the problems, we'll use Hollywood movie names as the dataset where we do our pattern matching. It looks like the following:\r\n\r\n```\r\nAbandoned\r\nAbbott and Costello Meet the Killer\r\nAbominable Dr. Phibes\r\nAbominable Snowman\r\nAbove the Street\r\nAbsent-Minded Professor\r\nAbyss\r\n...\r\nZoom \r\nZoot Suit \r\nZorba the Greek \r\nZorn's Lemma \r\nZorro \r\nZotz! \r\nZouzou \r\nZozo\r\n```\r\n\r\nHere are the kind of problems we'll solve around the movie names:\r\n\r\n* Finding movies that belong to a specific franchise (e.g. `Star Wars`).\r\n* Finding movies from multiple franchise (e.g. all movies from `Star Wars` and all movies from `Star Trek`).\r\n* Skipping movies from a specific franchise (e.g. all movies other than `Superman`). Or even all `Super` movies that are not `Superman`.\r\n* Finding movies that use a year in their name (e.g. `2001: A Space Odyssey`).\r\n* Finding movies with at least one five letter word (e.g. `Superman` is ok but `Cat and Dog` is not).\r\n	2017-07-04 13:34:51.766172	2017-07-04 13:34:51.766216
26	2	1	regex-setting-the-stage	Regex - Setting the Stage	7	<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\n## Stage 1\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 2\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated small image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 3\r\n\r\n<img src="/static/img/regex/favorite-websites-2.png" class="ui left floated small image"/>\r\n\r\nWhile you were waiting for all the results to come in, you find that some people entered just the simple name (e.g. `google`), some others prefer to provide domain name (e.g. `google.com`). You were still wondering how you would handle that when (as they say) all hell broke loose.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 4, 5 so on so forth\r\n\r\n\r\n\r\n\r\n\r\n	2017-07-03 23:19:12.450703	2017-07-03 23:19:12.450731
27	2	1	regex-setting-the-stage	Regex - Setting the Stage	8	<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\n## Stage 1\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 2\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated small image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 3\r\n\r\n<img src="/static/img/regex/favorite-websites-2.png" class="ui left floated small image"/>\r\n\r\nWhile you were waiting for all the results to come in, you find that some people entered just the simple name (e.g. `google`), some others prefer to provide domain name (e.g. `google.com`). You were still wondering how you would handle that when (as they say) all hell broke loose.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 4, 5 so on so forth\r\n\r\n<img src="/static/img/regex/favorite-websites-3.png" class="ui left floated small image"/>\r\n\r\n<img src="/static/img/regex/favorite-websites-4.png" class="ui left floated small image"/>\r\n\r\nYou find that students are entering information in all sorts of format. Some are providing the domain names (`google.com`), some are providing the full url (`https://www.google.com`) and some are even providing links to specific sections of the website (`https://www.wattpad.com/tags/children`). How are you ever going to sort through all of this?\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n	2017-07-03 23:19:12.450703	2017-07-03 23:19:12.450731
28	2	1	regex-setting-the-stage	Regex - Setting the Stage	9	<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\n## Stage 1\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 2\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated small image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 3\r\n\r\n<img src="/static/img/regex/favorite-websites-2.png" class="ui left floated small image"/>\r\n\r\nWhile you were waiting for all the results to come in, you find that some people entered just the simple name (e.g. `google`), some others prefer to provide domain name (e.g. `google.com`). You were still wondering how you would handle that when (as they say) all hell broke loose.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 4, 5 so on so forth\r\n\r\n<img src="/static/img/regex/favorite-websites-3.png" class="ui left floated small image"/>\r\n\r\nYou find that students are entering information in all sorts of format. Some are providing the domain names (`google.com`), some are providing the full url (`https://www.google.com`) and some are even providing links to specific sections of the website (`https://www.wattpad.com/tags/children`). How are you ever going to sort through all of this?\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n	2017-07-03 23:19:12.450703	2017-07-03 23:19:12.450731
29	2	1	regex-setting-the-stage	Regex - Setting the Stage	10	<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\n## Stage 1\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 2\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated small image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 3\r\n\r\n<img src="/static/img/regex/favorite-websites-2.png" class="ui left floated small image"/>\r\n\r\nWhile you were waiting for all the results to come in, you find that some people entered just the simple name (e.g. `google`), some others prefer to provide domain name (e.g. `google.com`). You were still wondering how you would handle that when (as they say) all hell broke loose.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 4, 5 so on so forth\r\n\r\n<img src="/static/img/regex/favorite-websites-3.png" class="ui right floated medium image"/>\r\n\r\nYou find that students are entering information in all sorts of format. Some are providing the domain names (`google.com`), some are providing the full url (`https://www.google.com`) and some are even providing links to specific sections of the website (`https://www.wattpad.com/tags/children`). How are you ever going to sort through all of this?\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n	2017-07-03 23:19:12.450703	2017-07-03 23:19:12.450731
30	2	1	regex-setting-the-stage	Regex - Setting the Stage	11	## Stage 1\r\n\r\n<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 2\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated small image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 3\r\n\r\n<img src="/static/img/regex/favorite-websites-2.png" class="ui left floated small image"/>\r\n\r\nWhile you were waiting for all the results to come in, you find that some people entered just the simple name (e.g. `google`), some others prefer to provide domain name (e.g. `google.com`). You were still wondering how you would handle that when (as they say) all hell broke loose.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 4, 5 and so on so forth\r\n\r\n<img src="/static/img/regex/favorite-websites-3.png" class="ui right floated medium image"/>\r\n\r\nYou find that students are entering information in all sorts of format. Some are providing the domain names (`google.com`), some are providing the full url (`https://www.google.com`) and some are even providing links to specific sections of the website (`https://www.wattpad.com/tags/children`). How are you ever going to sort through all of this?\r\n\r\n\r\n\r\n\r\n\r\n	2017-07-03 23:19:12.450703	2017-07-03 23:19:12.450731
31	3	1	regex-problem-statement	Regex - Problem Statement	1	Continuing from the previous section, here is the sample information you received from the students of your school:\r\n\r\n```\r\nGoogle\r\nFacebook\r\nInstagram\r\nWattPad\r\ngoogle.com\r\nfacebook.com\r\nwattpad.com\r\nwww.google.com\r\nwww.facebook.com\r\nwww.wattpad.com\r\nhttps://www.wattpad.com/tags/children\r\nhttps://www.facebook.com/home\r\nhttps://www.instagram.com\r\n```\r\n\r\n	2017-07-03 23:57:09.423974	2017-07-03 23:57:09.424005
32	3	1	regex-problem-statement	Regex - Problem Statement	2	Continuing from the previous section, here is the sample information you received from the students of your school:\r\n\r\n```\r\nGoogle\r\nFacebook\r\nInstagram\r\nWattPad\r\ngoogle.com\r\nfacebook.com\r\nwattpad.com\r\nwww.google.com\r\nwww.facebook.com\r\nwww.wattpad.com\r\nhttps://www.wattpad.com/tags/children\r\nhttps://www.facebook.com/home\r\nhttps://www.instagram.com\r\n```\r\n\r\nEven though there is quite a variety in the way information is represented, there is a pattern here. You intuitively know that `wattpad`, `WattPad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children` mean the same thing in this context. They all mean that the student has singled out `wattpad` as the favorite site.\r\n\r\nThis is where the problem is: how do you map all these variations of `wattpad` to just what it is (i.e. `wattpad`)? To your mind, the pattern is clear and you can easily see the mapping. However, if you were to write a program for this purpose, it would be a fairly involved task.\r\n\r\nThis is where regular expresions shine.\r\n	2017-07-03 23:57:09.423974	2017-07-03 23:57:09.424005
33	3	1	regex-problem-statement	Regex - Problem Statement	3	Continuing from the previous section, here is the sample information you received from the students of your school:\r\n\r\n```\r\nGoogle\r\nFacebook\r\nInstagram\r\nWattPad\r\ngoogle.com\r\nfacebook.com\r\nwattpad.com\r\nwww.google.com\r\nwww.facebook.com\r\nwww.wattpad.com\r\nhttps://www.wattpad.com/tags/children\r\nhttps://www.facebook.com/home\r\nhttps://www.instagram.com\r\n```\r\n\r\nEven though there is quite a variety in the way information is represented, there is a pattern here. You intuitively know that `wattpad`, `WattPad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children` mean the same thing in this context. They all mean that the student has singled out `wattpad` as the favorite site.\r\n\r\nThis is where the problem is: how do you map all these variations of `wattpad` to just what it is (i.e. `wattpad`)? To your mind, the pattern is clear and you can easily see the mapping. However, if you were to write a program for this purpose, it would be a fairly involved task.\r\n\r\nThis is where regular expresions shine. They give you a powerful language to describe the pattern (or the variations thereof).\r\n\r\n\r\n	2017-07-04 00:14:57.568356	2017-07-04 00:14:57.568388
34	4	1	regex-enters-the-gibberish	Regex - Gibberish to Rescue	1	To an untrained eye, regular expressions look like gibberish and that's how we'll treat them in this section. Once you are done with the entire material, they'll not be gibberish anymore. We'll get there...\r\n\r\n#### Revisiting the Problem\r\n\r\nWe want to extract the website name (i.e. `wattpad`) from different ways in which it is given to us (i.e. `wattpad`, `WattPad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children`).\r\n\r\n#### The Solution\r\n\r\nThe solution has two parts to it:\r\n\r\n* First, we define a pattern that would match all variations in which people mentioned the site name (i.e. `wattpad`, `WattPad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children`)\r\n* Next, we'll use the pattern to extract the actual site name (i.e. `wattpad`) from its variations.\r\n\r\nHere is the gibberish (aka regular expression) that describes the pattern we are looking for. Don't even try to understand it for now. Just take it as it is.\r\n\r\n```Python\r\nREGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\r\n```\r\n\r\nHere is the code that makes use of `REGEX_GIBBERISH`, applies it to the site name as entered by the students and gives us the bare bone site name as we want to see.\r\n\r\n```Python\r\n# Import the regular expression module\r\nimport re\r\n\r\n# Define the regex pattern\r\nREGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\r\n\r\n# Apply the pattern to whatever site name was entered by students \r\n# and get the barebone site name.\r\nre.search(REGEX_GIBBERISH, "...site name...").group("site")\r\n```\r\n\r\nLet's see this code in action now.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\r\n>>> \r\n>>> re.search(REGEX_GIBBERISH, "wattpad").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "www.wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "http://www.wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "https://www.wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "https://www.wattpad.com/tags/children").group("site")\r\n'wattpad'\r\n>>> \r\n```\r\n\r\nFascinating. Isn't it?	2017-07-04 00:32:00.207168	2017-07-04 00:32:00.207197
35	1	1	regex-introduction	Regex Introduction	20	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or to understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.	2017-07-04 00:32:00.207168	2017-07-04 00:32:00.207197
37	5	1	regex-the-plan	Regex - The Plan	1	Here is what we are going to do now. We are going to learn regular expressions one bit at a time. Here is the broad outline:\r\n\r\n* How to write patterns in regular expressions and use these patterns to `match` text. This is where you learn pretty much 80% of this language.\r\n* How to extract the text that matches the pattern. This is really a small bit once you have a pattern in hand.\r\n* How to replace the matching text with some other text. This is also a small bit once the language itself has been learnt.	2017-07-04 13:34:51.766172	2017-07-04 13:34:51.766216
39	6	1	regex-matching-characters	Regex - Matching Characters	2	In this section, we'll solve problems that revolve around presence or absence of certain characters in the text. For most of the problems, we'll use Hollywood movie names as the dataset where we do our pattern matching. It looks like the following:\r\n\r\n```\r\nAbandoned\r\nAbbott and Costello Meet the Killer\r\nAbominable Dr. Phibes\r\nAbominable Snowman\r\nAbove the Street\r\nAbsent-Minded Professor\r\nAbyss\r\n...\r\nZoom \r\nZoot Suit \r\nZorba the Greek \r\nZorn's Lemma \r\nZorro \r\nZotz! \r\nZouzou \r\nZozo\r\n```\r\n\r\nHere are the kind of problems we'll solve around the movie names:\r\n\r\n* Finding movies that belong to a specific franchise (e.g. `Star Wars`).\r\n* Finding movies from multiple franchise (e.g. all movies from `Star Wars` as well as `Star Trek`).\r\n* Skipping movies from a specific franchise (e.g. all movies other than `Superman`). Or even all `Super` movies that are not `Superman`.\r\n* Finding movies that use a year in their name (e.g. `2001: A Space Odyssey`).\r\n* Finding movies with at least one five letter word (e.g. `Superman` is ok but `Cat and Dog` is not).\r\n	2017-07-04 13:34:51.766172	2017-07-04 13:34:51.766216
40	7	1	regex-matching-literals	Regex - Matching Literals	1	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nThe regex pattern optionally starts with `r`. It just marks the following string as a regular expression.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n	2017-07-04 13:34:51.766172	2017-07-04 13:34:51.766216
41	7	1	regex-matching-literals	Regex - Matching Literals	2	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nThe regex pattern optionally starts with `r`. It just marks the following string as a regular expression.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object that we'll discuss later. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `r"Window"`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-07-04 13:34:51.766172	2017-07-04 13:34:51.766216
42	7	1	regex-matching-literals	Regex - Matching Literals	3	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nThe regex pattern optionally starts with `r`. It just marks the following string as a regular expression.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object that we'll discuss later. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `r"Window"`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-07-04 17:15:32.042129	2017-07-04 17:15:32.042156
43	7	1	regex-matching-literals	Regex - Matching Literals	4	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nThe regex pattern optionally starts with `r`. It just marks the following string as a regular expression.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object that we'll discuss later. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `r"Window"`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-07-04 17:16:11.333849	2017-07-04 17:16:11.333942
56	10	1	regex-matching-one-of-many-characters	Regex - Matching One of Many Characters	1	An interesting problem to solve is to match movies that mention a year in their name. Sample movie names are: `2001: A Space Odyssey`, `Dream Team 1935`, `Class of 1999` etc. To keep it simple for now, a year is four digits out of which first digit could be 1 or 2 and rest of the digits could go from 0 to 9. From what we have learnt so far, we could define a pattern like this for our purpose.\r\n\r\n```Python\r\nREGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n```\r\n\r\nLet's put it to use and see it working.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nThe pattern works but it's quite cumbersome. Regex provides another expression that we can use here. `(0|1|2|3|4|5|6|7|8|9)` could be written as `[0123456789]`. When you put multiple characters in `[]`, regex would look for matching one of these.\r\n\r\nWe can now rewrite the previous expression as:\r\n\r\n```Python\r\nREGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n```\r\n\r\nLet's try out the new pattern.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nIn fact, such needs are so common that there is a further shortcut to matching digits 0-9: `[0-9]`. So, we can once again re-write the expression as `[12][0-9][0-9][0-9]`. Here is how we use it:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0-9][0-9][0-9]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nNice. Isn't it?\r\n\r\n\r\n\r\n\r\n\r\n\r\n	2017-07-04 18:03:20.669866	2017-07-04 18:03:20.669931
44	7	1	regex-matching-literals	Regex - Matching Literals	5	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nThe regex pattern optionally starts with `r`. It just marks the following string as a regular expression.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object that we'll discuss later. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `r"Window"`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-07-04 17:16:11.333849	2017-07-04 17:16:11.333942
45	8	1	regex-matching-this-or-that	Regex - Matching This or That	1	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we can create a regex `r"Star Wars:|Star Trek:". Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n	2017-07-04 17:16:11.333849	2017-07-04 17:16:11.333942
46	8	1	regex-matching-this-or-that	Regex - Matching This or That	2	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we could define the pattern as `r"Star Wars:|Star Trek:"`. This pattern would match either `Star Wars:` or `Star Trek:`. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\nThe regex `Star Wars:|Star Trek:` has multiple duplicate elements. We can make it more concise with `Star (Wars|Trek):`. It means look for `Star`, followed by a space followed by either `Wars` or `Trek`, followed by a `:`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star (Wars|Trek):"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `r"Force|Jedi"`:\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Discovery\r\n  [ ] Star Trek: Voyager\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars as well as Star Trek franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [#] Star Trek: Discovery\r\n  [#] Star Trek: Voyager\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n--\r\n\r\n\r\n\r\n	2017-07-04 17:16:11.333849	2017-07-04 17:16:11.333942
47	8	1	regex-matching-this-or-that	Regex - Matching This or That	3	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we could define the pattern as `Star Wars:|Star Trek:`. This pattern would match either `Star Wars:` or `Star Trek:`. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\nThe regex `Star Wars:|Star Trek:` has multiple duplicate elements. We can make it more concise with `Star (Wars|Trek):`. It means look for `Star`, followed by a space followed by either `Wars` or `Trek`, followed by a `:`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star (Wars|Trek):"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `Force|Jedi`:\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Discovery\r\n  [ ] Star Trek: Voyager\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars as well as Star Trek franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [#] Star Trek: Discovery\r\n  [#] Star Trek: Voyager\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [#] `Superman|Supergirl`\r\n  [#] `Super(man|girl)`\r\n  [ ] `Super(m|g)(a|i)(n|r)l`\r\n  [#] `Super(m|g)(a|i)(n|rl)`\r\n  [#] `Super((man|girl))`\r\n  [#] `Super((man)|girl)`\r\n--\r\n\r\n	2017-07-04 17:16:11.333849	2017-07-04 17:16:11.333942
48	8	1	regex-matching-this-or-that	Regex - Matching This or That	4	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we could define the pattern as `Star Wars:|Star Trek:`. This pattern would match either `Star Wars:` or `Star Trek:`. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\nThe regex `Star Wars:|Star Trek:` has multiple duplicate elements. We can make it more concise with `Star (Wars|Trek):`. It means look for `Star`, followed by a space followed by either `Wars` or `Trek`, followed by a `:`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star (Wars|Trek):"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `Force|Jedi`:\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Discovery\r\n  [ ] Star Trek: Voyager\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars as well as Star Trek franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [#] Star Trek: Discovery\r\n  [#] Star Trek: Voyager\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [#] `Superman|Supergirl`\r\n  [#] `Super(man|girl)`\r\n  [ ] `Super(m|g)(a|i)(n|r)l`\r\n  [#] `Super(m|g)(a|i)(n|rl)`\r\n  [#] `Super((man|girl))`\r\n  [#] `Super((man)|girl)`\r\n--\r\n\r\n	2017-07-04 17:45:40.028973	2017-07-04 17:45:40.029008
49	8	1	regex-matching-this-or-that	Regex - Matching This or That	5	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we could define the pattern as `Star Wars:|Star Trek:`. This pattern would match either `Star Wars:` or `Star Trek:`. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\nThe regex `Star Wars:|Star Trek:` has multiple duplicate elements. We can make it more concise with `Star (Wars|Trek):`. It means look for `Star`, followed by a space followed by either `Wars` or `Trek`, followed by a `:`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star (Wars|Trek):"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `Force|Jedi`:\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Discovery\r\n  [ ] Star Trek: Voyager\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars as well as Star Trek franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [#] Star Trek: Discovery\r\n  [#] Star Trek: Voyager\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [#] `Superman|Supergirl`\r\n  [#] `Super(man|girl)`\r\n  [ ] `Super(m|g)(a|i)(n|r)l`\r\n  [#] `Super(m|g)(a|i)(n|rl)`\r\n  [#] `Super((man|girl))`\r\n  [#] `Super((man)|girl)`\r\n--\r\n\r\n	2017-07-04 17:45:58.954314	2017-07-04 17:45:58.954345
57	10	1	regex-matching-one-of-many-characters	Regex - Matching One of Many Characters	2	An interesting problem to solve is to match movies that mention a year in their name. Sample movie names are: `2001: A Space Odyssey`, `Dream Team 1935`, `Class of 1999` etc. To keep it simple for now, a year is four digits out of which first digit could be 1 or 2 and rest of the digits could go from 0 to 9. From what we have learnt so far, we could define a pattern like this for our purpose.\r\n\r\n```Python\r\nREGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n```\r\n\r\nLet's put it to use and see it working.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nThe pattern works but it's quite cumbersome. Regex provides another expression that we can use here. `(0|1|2|3|4|5|6|7|8|9)` could be written as `[0123456789]`. When you put multiple characters in `[]`, regex would look for matching one of these.\r\n\r\nWe can now rewrite the previous expression as:\r\n\r\n```Python\r\nREGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n```\r\n\r\nLet's try out the new pattern.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nIn fact, such needs are so common that there is a further shortcut to matching digits 0-9: `[0-9]`. So, we can once again re-write the expression as `[12][0-9][0-9][0-9]`. Here is how we use it:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0-9][0-9][0-9]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nNice. Isn't it?\r\n\r\n--regexquiz\r\nTry different regex variations that we discussed just now to select movie names that have a year in their name.\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] 1984\r\n  [ ] Gone With The Wind\r\n  [ ] Star Wars: The Last Jedi\r\n--\r\n\r\n## Ranges and Alphabets\r\n\r\nRanges work not only for digits but also for alphabets. So, you could say `r"[A-Z]"` to match any upper case letter, `r"[a-z]"` to match any lower case letter, `r"[A-Za-z]"` to match all English alphabet letters, `r"[A-Za-z0-9]"` to match any alphanumeric characters. In fact, you can also say `r"[AM-PZ]"` and it would match letters A, M, N, O, P, Z.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> re.search(r"[A-Z]", "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(6, 7), match='A'>\r\n>>> \r\n>>> re.search(r"[A-Z]", "1984")\r\n>>>\r\n```\r\n\r\nHere, we are looking for a movie name with an uppercase letter. The movie `2001: A Space Odyssey` is a match, whereas, the movie `1984` is not a match.\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `r"[0-9][0-9][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `r"[0-29][0-5][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [ ] `r"Super[mg][ai][nrl]"`\r\n  [#] `r"Super[mg][ai][nr]l"`\r\n  [#] `r"Super[mg][ai](n|rl)"`\r\n  [ ] `r"Super[mangirl]"`\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that have at least one 4 letter word in the middle of movie name.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that use a number within a word.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that have a bat, cat or rat in the name. Use the shortest possible regex.\r\n  [#] Bat Whispers\r\n  [#] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n\r\n	2017-07-04 18:03:20.669866	2017-07-04 18:03:20.669931
58	10	1	regex-matching-one-of-many-characters	Regex - Matching One of Many Characters	3	An interesting problem to solve is to match movies that mention a year in their name. Sample movie names are: `2001: A Space Odyssey`, `Dream Team 1935`, `Class of 1999` etc. To keep it simple for now, a year is four digits out of which first digit could be 1 or 2 and rest of the digits could go from 0 to 9. From what we have learnt so far, we could define a pattern like this for our purpose.\r\n\r\n```Python\r\nREGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n```\r\n\r\nLet's put it to use and see it working.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nThe pattern works but it's quite cumbersome. Regex provides another expression that we can use here. `(0|1|2|3|4|5|6|7|8|9)` could be written as `[0123456789]`. When you put multiple characters in `[]`, regex would look for matching one of these.\r\n\r\nWe can now rewrite the previous expression as:\r\n\r\n```Python\r\nREGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n```\r\n\r\nLet's try out the new pattern.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nIn fact, such needs are so common that there is a further shortcut to matching digits 0-9: `[0-9]`. So, we can once again re-write the expression as `[12][0-9][0-9][0-9]`. Here is how we use it:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0-9][0-9][0-9]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nNice. Isn't it?\r\n\r\n--regexquiz\r\nTry different regex variations that we discussed just now to select movie names that have a year in their name.\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] 1984\r\n  [ ] Gone With The Wind\r\n  [ ] Star Wars: The Last Jedi\r\n--\r\n\r\n## Ranges and Alphabets\r\n\r\nRanges work not only for digits but also for alphabets. So, you could say `r"[A-Z]"` to match any upper case letter, `r"[a-z]"` to match any lower case letter, `r"[A-Za-z]"` to match all English alphabet letters, `r"[A-Za-z0-9]"` to match any alphanumeric characters. In fact, you can also say `r"[AM-PZ]"` and it would match letters A, M, N, O, P, Z.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> re.search(r"[A-Z]", "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(6, 7), match='A'>\r\n>>> \r\n>>> re.search(r"[A-Z]", "1984")\r\n>>>\r\n```\r\n\r\nHere, we are looking for a movie name with an uppercase letter. The movie `2001: A Space Odyssey` is a match, whereas, the movie `1984` is not a match.\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `r"[0-9][0-9][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `r"[0-29][0-5][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [ ] `r"Super[mg][ai][nrl]"`\r\n  [#] `r"Super[mg][ai][nr]l"`\r\n  [#] `r"Super[mg][ai](n|rl)"`\r\n  [ ] `r"Super[mangirl]"`\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that have at least one 4 letter word in the middle of movie name.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that use a number within a word.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nHere is a list of movie names. Select the ones that have a bat, cat or rat in the name. Use the shortest possible regex.\r\n  [#] Bat Whispers\r\n  [#] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n## Matching absence of characters\r\n\r\nJust like you can match for presence of certain characters, you can also match for their absence. `r"[^A-Z]"` will match all characters except uppercase letters. `r"[^BCR]at"` will match `Sat` but it will not match `Bat`, `Cat` and `Rat`. Simple trick here is to use `^`. `[BCR]` means match B, C or R but `[^BCR]` means match anything other than B, C or R.\r\n\r\n--mcquiz\r\nWhich of the following match regex `r"[0-1][0-9]:[0-6][0-9] [^P]M"`:\r\n  [#] 04:00 AM\r\n  [#] 11:59 AM\r\n  [ ] 06:00 PM\r\n  [ ] 09:23 PM\r\n--\r\n\r\n--mcquiz\r\nHere are some movie names. Which ones would match the regex `r"[^3-9][0-5][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [ ] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n	2017-07-04 18:03:20.669866	2017-07-04 18:03:20.669931
59	11	1	regex-matching-types-of-characters	Regex - Matching Types of Characters	1	ok	2017-07-04 18:03:20.669866	2017-07-04 18:03:20.669931
50	8	1	regex-matching-this-or-that	Regex - Matching This or That	6	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we could define the pattern as `Star Wars:|Star Trek:`. This pattern would match either `Star Wars:` or `Star Trek:`. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\nThe regex `Star Wars:|Star Trek:` has multiple duplicate elements. We can make it more concise with `Star (Wars|Trek):`. It means look for `Star`, followed by a space followed by either `Wars` or `Trek`, followed by a `:`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star (Wars|Trek):"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `Force|Jedi`:\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Discovery\r\n  [ ] Star Trek: Voyager\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars as well as Star Trek franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [#] Star Trek: Discovery\r\n  [#] Star Trek: Voyager\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [#] `Superman|Supergirl`\r\n  [#] `Super(man|girl)`\r\n  [ ] `Super(m|g)(a|i)(n|r)l`\r\n  [#] `Super(m|g)(a|i)(n|rl)`\r\n  [#] `Super((man|girl))`\r\n  [#] `Super((man)|girl)`\r\n--\r\n\r\n	2017-07-04 17:46:41.260343	2017-07-04 17:46:41.260383
51	8	1	regex-matching-this-or-that	Regex - Matching This or That	7	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we could define the pattern as `Star Wars:|Star Trek:`. This pattern would match either `Star Wars:` or `Star Trek:`. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\nThe regex `Star Wars:|Star Trek:` has multiple duplicate elements. We can make it more concise with `Star (Wars|Trek):`. It means look for `Star`, followed by a space followed by either `Wars` or `Trek`, followed by a `:`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star (Wars|Trek):"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `Force|Jedi`:\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Discovery\r\n  [ ] Star Trek: Voyager\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars as well as Star Trek franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [#] Star Trek: Discovery\r\n  [#] Star Trek: Voyager\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [#] `Superman|Supergirl`\r\n  [#] `Super(man|girl)`\r\n  [ ] `Super(m|g)(a|i)(n|r)l`\r\n  [#] `Super(m|g)(a|i)(n|rl)`\r\n  [#] `Super((man|girl))`\r\n  [#] `Super((man)|girl)`\r\n--\r\n\r\n	2017-07-04 17:47:02.196931	2017-07-04 17:47:02.196969
52	8	1	regex-matching-this-or-that	Regex - Matching This or That	8	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we could define the pattern as `Star Wars:|Star Trek:`. This pattern would match either `Star Wars:` or `Star Trek:`. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\nThe regex `Star Wars:|Star Trek:` has multiple duplicate elements. We can make it more concise with `Star (Wars|Trek):`. It means look for `Star`, followed by a space followed by either `Wars` or `Trek`, followed by a `:`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star (Wars|Trek):"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `Force|Jedi`:\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Discovery\r\n  [ ] Star Trek: Voyager\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars as well as Star Trek franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [#] Star Trek: Discovery\r\n  [#] Star Trek: Voyager\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [#] `Superman|Supergirl`\r\n  [#] `Super(man|girl)`\r\n  [ ] `Super(m|g)(a|i)(n|r)l`\r\n  [#] `Super(m|g)(a|i)(n|rl)`\r\n  [#] `Super((man|girl))`\r\n  [#] `Super((man)|girl)`\r\n--\r\n\r\n--mcquiz\r\nWhich of the following movies will be matched by regex `(Star (Wars|Trek):)|(Super(man|girl))`\r\n  [#] Star Wars: The Last Jedi\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n  [#] Star Trek: Voyager\r\n  [#] Superman Returns\r\n  [#] Supergirl\r\n--\r\n\r\n\r\n	2017-07-04 17:47:02.196931	2017-07-04 17:47:02.196969
53	8	1	regex-matching-this-or-that	Regex - Matching This or That	9	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we could define the pattern as `Star Wars:|Star Trek:`. This pattern would match either `Star Wars:` or `Star Trek:`. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\nThe regex `Star Wars:|Star Trek:` has multiple duplicate elements. We can make it more concise with `Star (Wars|Trek):`. It means look for `Star`, followed by a space followed by either `Wars` or `Trek`, followed by a `:`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star (Wars|Trek):"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `Force|Jedi`:\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Discovery\r\n  [ ] Star Trek: Voyager\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars as well as Star Trek franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [#] Star Trek: Discovery\r\n  [#] Star Trek: Voyager\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [#] `Superman|Supergirl`\r\n  [#] `Super(man|girl)`\r\n  [ ] `Super(m|g)(a|i)(n|r)l`\r\n  [#] `Super(m|g)(a|i)(n|rl)`\r\n  [#] `Super((man|girl))`\r\n  [#] `Super((man)|girl)`\r\n--\r\n\r\n--mcquiz\r\nWhich of the following movies will be matched by regex `(Star (Wars|Trek):)|(Super(man|girl))`\r\n  [#] Star Wars: The Last Jedi\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n  [#] Star Trek: Voyager\r\n  [#] Superman Returns\r\n  [#] Supergirl\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match all the Star Wars, Star Trek and Space related movies.\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n  [#] Star Trek: Voyager\r\n  [ ] Superman\r\n--\r\n\r\n	2017-07-04 17:47:02.196931	2017-07-04 17:47:02.196969
54	8	1	regex-matching-this-or-that	Regex - Matching This or That	10	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we could define the pattern as `Star Wars:|Star Trek:`. This pattern would match either `Star Wars:` or `Star Trek:`. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\nThe regex `Star Wars:|Star Trek:` has multiple duplicate elements. We can make it more concise with `Star (Wars|Trek):`. It means look for `Star`, followed by a space followed by either `Wars` or `Trek`, followed by a `:`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star (Wars|Trek):"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `Force|Jedi`:\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Discovery\r\n  [ ] Star Trek: Voyager\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars as well as Star Trek franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [#] Star Trek: Discovery\r\n  [#] Star Trek: Voyager\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n--\r\n\r\n--mcquiz\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [#] `Superman|Supergirl`\r\n  [#] `Super(man|girl)`\r\n  [ ] `Super(m|g)(a|i)(n|r)l`\r\n  [#] `Super(m|g)(a|i)(n|rl)`\r\n  [#] `Super((man|girl))`\r\n  [#] `Super((man)|girl)`\r\n--\r\n\r\n--mcquiz\r\nWhich of the following movies will be matched by regex `(Star (Wars|Trek):)|(Super(man|girl))`\r\n  [#] Star Wars: The Last Jedi\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n  [#] Star Trek: Voyager\r\n  [#] Superman Returns\r\n  [#] Supergirl\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match all the Star Wars, Star Trek and Space related movies.\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n  [#] Star Trek: Voyager\r\n  [ ] Superman\r\n  [#] Alien Space Avenger\r\n--\r\n\r\n	2017-07-04 17:47:02.196931	2017-07-04 17:47:02.196969
55	9	1	regex-matching-special-characters	Regex - Matching Special Characters	1	Some characters have special meaning in regex (e.g. `.`, `?`, `(`, `)`, `*`, `+`, `^`, `$`, `\\`, `[`, `]`) . We'll look at their use later in the game. For now, suffice it to say that if you want to match any of these, you have to precede them with `\\` to find a match. For example, if you want to match movie names that have a full stop, you have to use `\\.` as regex pattern and not `.`.\r\n\r\nLet's solve the problem of matching movie names that have a full stop. Here is the wrong pattern:\r\n\r\n```Python\r\n>>> import re\r\n>>> INCORRECT_REGEX_PATTERN = r'.'\r\n>>> \r\n>>> re.search(INCORRECT_REGEX_PATTERN, 'Mr. Average')\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(INCORRECT_REGEX_PATTERN, 'Stardust')\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> # should not have matched Stardust but it did.\r\n```\r\n\r\nHere is the same exercise with the right regex pattern:\r\n\r\n```Python\r\n>>> import re\r\n>>> CORRECT_REGEX_PATTERN = r'\\.'\r\n>>> \r\n>>> re.search(CORRECT_REGEX_PATTERN, 'Mr. Average')\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(CORRECT_REGEX_PATTERN, 'Stardust')\r\n>>> # did not match Stardust\r\n```\r\n\r\n--regexquiz\r\nWrite the regex pattern that matches movies with `.` in their name:\r\n  [#] Mr. Pip\r\n  [#] The D.I.\r\n  [ ] Stardust\r\n  [ ] Superman\r\n--\r\n\r\n\r\n\r\n	2017-07-04 18:03:20.669866	2017-07-04 18:03:20.669931
63	11	1	regex-matching-types-of-characters	Regex - Matching Types of Characters	2	Let's revisit the problem of identifying movies that have a year in their name. We looked at set of characters (i.e. `[0-9]`) as a solution. Some of these sets are so commonly used that there are special symbols for them. These symbols are:\r\n\r\n* `\\w` is equivalent to `[A-Za-z0-9_]`\r\n* `\\W` is opposite of `\\w` i.e. `[^A-Za-z0-9_]`\r\n* `\\s` is equivalent to `[ \\t\\r\\n]`\r\n* `\\S` is opposite of `\\s` i.e. `[^ \\t\\r\\n]`\r\n* `\\d` is equivalent to `[0-9]`\r\n* `\\D` is opposite of `\\d` i.e. `[^0-9]`\r\n* `.` is the most interesting shortcut and it matches all characters without exception.\r\n\r\nSo, we had earlier used regex `[12][0-9][0-9][0-9]` to find movies with a year in their name. This regex could also be written as `[12]\\d\\d\\d`. In this, `\\d` stands for a digit. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12]\\d\\d\\d"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nSimilarly, let's say if we want to find out if a movie name has at least 1 word that is five letters long (or even longer). Instead of writing `[A-Za-z][A-Za-z][A-Za-z][A-Za-z][A-Za-z]`, we could write `\\w\\w\\w\\w\\w`. The `\\w` based regex is more concise and readable. Here it is in action:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\w\\w\\w\\w\\w"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1995")\r\n<_sre.SRE_Match object; span=(0, 5), match='Dream'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 5), match='Super'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Cat And Dog")\r\n>>> \r\n```\r\n\r\n\r\nWhat if we want to find out movies whose name is at least 6 letter long? The regex `......` will do the trick for us:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"......"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 6), match='Superm'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1984")\r\n>>> \r\n```\r\n\r\nExpression `r"\\w\\w\\w\\w\\s\\w\\w\\w\\w"` would match a movie name that has at least two words and both the words have at least 4 letters.\r\n\r\n```Python\r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Gone With The Wind")\r\n<_sre.SRE_Match object; span=(0, 9), match='Gone With'>\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "The Ghosts")\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Cat And Dog")\r\n>>>\r\n```\r\n\r\n\r\n\r\n\r\n	2017-07-04 18:03:20.669866	2017-07-04 18:03:20.669931
64	11	1	regex-matching-types-of-characters	Regex - Matching Types of Characters	3	Let's revisit the problem of identifying movies that have a year in their name. We looked at set of characters (i.e. `[0-9]`) as a solution. Some of these sets are so commonly used that there are special symbols for them. These symbols are:\r\n\r\n* `\\w` is equivalent to `[A-Za-z0-9_]`\r\n* `\\W` is opposite of `\\w` i.e. `[^A-Za-z0-9_]`\r\n* `\\s` is equivalent to `[ \\t\\r\\n]`\r\n* `\\S` is opposite of `\\s` i.e. `[^ \\t\\r\\n]`\r\n* `\\d` is equivalent to `[0-9]`\r\n* `\\D` is opposite of `\\d` i.e. `[^0-9]`\r\n* `.` is the most interesting shortcut and it matches all characters without exception.\r\n\r\nSo, we had earlier used regex `[12][0-9][0-9][0-9]` to find movies with a year in their name. This regex could also be written as `[12]\\d\\d\\d`. In this, `\\d` stands for a digit. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12]\\d\\d\\d"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nSimilarly, let's say if we want to find out if a movie name has at least 1 word that is five letters long (or even longer). Instead of writing `[A-Za-z][A-Za-z][A-Za-z][A-Za-z][A-Za-z]`, we could write `\\w\\w\\w\\w\\w`. The `\\w` based regex is more concise and readable. Here it is in action:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\w\\w\\w\\w\\w"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1995")\r\n<_sre.SRE_Match object; span=(0, 5), match='Dream'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 5), match='Super'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Cat And Dog")\r\n>>> \r\n```\r\n\r\n\r\nWhat if we want to find out movies whose name is at least 6 letter long? The regex `......` will do the trick for us:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"......"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 6), match='Superm'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1984")\r\n>>> \r\n```\r\n\r\nExpression `r"\\w\\w\\w\\w\\s\\w\\w\\w\\w"` would match a movie name that has at least two words and both the words have at least 4 letters.\r\n\r\n```Python\r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Gone With The Wind")\r\n<_sre.SRE_Match object; span=(0, 9), match='Gone With'>\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "The Ghosts")\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Cat And Dog")\r\n>>>\r\n```\r\n\r\n--regexquiz\r\nWrite a regex that matches movies with at least 8 characters in their name.\r\n  [ ] Se7en\r\n  [ ] Thr3e\r\n  [ ] E=mc2\r\n  [#] 2001: A Space Odyssey\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n--regexquiz\r\nFind movies which have a number surrounded by two letters on each side.\r\n  [#] Se7en\r\n  [ ] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz\r\nFind movies which have two consecutive non-word letters. Hint: use `\\W`.\r\n  [#] Star Wars: Return of the Jedi\r\n  [#] Star Trek: Voyager\r\n  [#] Erkan & Stefan 2\r\n  [ ] Cat And Dog\r\n  [ ] Alice in Wonderland\r\n  [ ] Pirates of the Carribean\r\n--\r\n	2017-07-04 18:03:20.669866	2017-07-04 18:03:20.669931
65	11	1	regex-matching-types-of-characters	Regex - Matching Types of Characters	4	Let's revisit the problem of identifying movies that have a year in their name. We looked at set of characters (i.e. `[0-9]`) as a solution. Some of these sets are so commonly used that there are special symbols for them. These symbols are:\r\n\r\n* `\\w` is equivalent to `[A-Za-z0-9_]`\r\n* `\\W` is opposite of `\\w` i.e. `[^A-Za-z0-9_]`\r\n* `\\s` is equivalent to `[ \\t\\r\\n]`\r\n* `\\S` is opposite of `\\s` i.e. `[^ \\t\\r\\n]`\r\n* `\\d` is equivalent to `[0-9]`\r\n* `\\D` is opposite of `\\d` i.e. `[^0-9]`\r\n* `.` is the most interesting shortcut and it matches all characters without exception.\r\n\r\nSo, we had earlier used regex `[12][0-9][0-9][0-9]` to find movies with a year in their name. This regex could also be written as `[12]\\d\\d\\d`. In this, `\\d` stands for a digit. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12]\\d\\d\\d"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nSimilarly, let's say if we want to find out if a movie name has at least 1 word that is five letters long (or even longer). Instead of writing `[A-Za-z][A-Za-z][A-Za-z][A-Za-z][A-Za-z]`, we could write `\\w\\w\\w\\w\\w`. The `\\w` based regex is more concise and readable. Here it is in action:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\w\\w\\w\\w\\w"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1995")\r\n<_sre.SRE_Match object; span=(0, 5), match='Dream'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 5), match='Super'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Cat And Dog")\r\n>>> \r\n```\r\n\r\n\r\nWhat if we want to find out movies whose name is at least 6 letter long? The regex `......` will do the trick for us:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"......"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 6), match='Superm'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1984")\r\n>>> \r\n```\r\n\r\nExpression `r"\\w\\w\\w\\w\\s\\w\\w\\w\\w"` would match a movie name that has at least two words and both the words have at least 4 letters.\r\n\r\n```Python\r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Gone With The Wind")\r\n<_sre.SRE_Match object; span=(0, 9), match='Gone With'>\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "The Ghosts")\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Cat And Dog")\r\n>>>\r\n```\r\n\r\n--regexquiz\r\nWrite a regex that matches movies with at least 8 characters in their name.\r\n  [ ] Se7en\r\n  [ ] Thr3e\r\n  [ ] E=mc2\r\n  [#] 2001: A Space Odyssey\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n--regexquiz\r\nFind movies which have a number surrounded by two letters on each side.\r\n  [#] Se7en\r\n  [ ] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz\r\nFind movies which have two consecutive non-word letters. Hint: use `\\W`.\r\n  [#] Star Wars: Return of the Jedi\r\n  [#] Star Trek: Voyager\r\n  [#] Erkan & Stefan 2\r\n  [ ] Cat And Dog\r\n  [ ] Alice in Wonderland\r\n  [ ] Pirates of the Carribean\r\n--\r\n\r\n\r\n	2017-07-04 18:03:20.669866	2017-07-04 18:03:20.669931
66	11	1	regex-matching-types-of-characters	Regex - Matching Types of Characters	5	Let's revisit the problem of identifying movies that have a year in their name. We looked at set of characters (i.e. `[0-9]`) as a solution. Some of these sets are so commonly used that there are special symbols for them. These symbols are:\r\n\r\n* `\\w` is equivalent to `[A-Za-z0-9_]`\r\n* `\\W` is opposite of `\\w` i.e. `[^A-Za-z0-9_]`\r\n* `\\s` is equivalent to `[ \\t\\r\\n]`\r\n* `\\S` is opposite of `\\s` i.e. `[^ \\t\\r\\n]`\r\n* `\\d` is equivalent to `[0-9]`\r\n* `\\D` is opposite of `\\d` i.e. `[^0-9]`\r\n* `.` is the most interesting shortcut and it matches all characters without exception.\r\n\r\nSo, we had earlier used regex `[12][0-9][0-9][0-9]` to find movies with a year in their name. This regex could also be written as `[12]\\d\\d\\d`. In this, `\\d` stands for a digit. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12]\\d\\d\\d"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nSimilarly, let's say if we want to find out if a movie name has at least 1 word that is five letters long (or even longer). Instead of writing `[A-Za-z][A-Za-z][A-Za-z][A-Za-z][A-Za-z]`, we could write `\\w\\w\\w\\w\\w`. The `\\w` based regex is more concise and readable. Here it is in action:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\w\\w\\w\\w\\w"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1995")\r\n<_sre.SRE_Match object; span=(0, 5), match='Dream'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 5), match='Super'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Cat And Dog")\r\n>>> \r\n```\r\n\r\n\r\nWhat if we want to find out movies whose name is at least 6 letter long? The regex `......` will do the trick for us:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"......"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 6), match='Superm'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1984")\r\n>>> \r\n```\r\n\r\nExpression `r"\\w\\w\\w\\w\\s\\w\\w\\w\\w"` would match a movie name that has at least two words and both the words have at least 4 letters.\r\n\r\n```Python\r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Gone With The Wind")\r\n<_sre.SRE_Match object; span=(0, 9), match='Gone With'>\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "The Ghosts")\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Cat And Dog")\r\n>>>\r\n```\r\n\r\n--regexquiz\r\nWrite a regex that matches movies with at least 8 characters in their name.\r\n  [ ] Se7en\r\n  [ ] Thr3e\r\n  [ ] E=mc2\r\n  [#] 2001: A Space Odyssey\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n--regexquiz\r\nFind movies which have a number surrounded by one letters on each side.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz\r\nFind movies which have two consecutive non-word letters. Hint: use `\\W`.\r\n  [#] Star Wars: Return of the Jedi\r\n  [#] Star Trek: Voyager\r\n  [#] Erkan & Stefan 2\r\n  [ ] Cat And Dog\r\n  [ ] Alice in Wonderland\r\n  [ ] Pirates of the Carribean\r\n--\r\n\r\n\r\n	2017-07-04 23:46:27.447276	2017-07-04 23:46:27.447354
67	12	1	regex-matching-occurrences-or-repetitions	Regex - Matching Occurrences or Repetitions	1	So far, we have looked at specifying *which characters* are allowed and which ones are not allowed in the pattern. Now, we'll look at specifying *how many* are allowed.\r\n\r\nLet's revisit the problem of matching movie names with at least 6 letters. We know that `1984` is not a match and `Superman` is a match. The pattern we wrote was `......`. Basically, a `.` (which matches all characters) repeated 6 times.\r\n\r\nRegex has mechanisms to say precisely how many times a match should occur. This is what we'll study in this section.	2017-07-05 00:01:35.566568	2017-07-05 00:01:35.566595
68	13	1	regex-matching-m-to-n-occurrence	Regex - Matching m To n Occurrences	1	So far, we have encountered multiple instances where we had to specify the number of times a pattern should occur. For example, we tried to match movie names with at least 6 letters (`......`) or movie names with at least 3 letter word followed by at least 4 letter word (`\\w\\w\\w\\s\\w\\w\\w\\w`) or movie names with a year (`\\d\\d\\d\\d`).\r\n\r\nThere is an easier way to specify the number of times a pattern must occur. It's of the form `{m,n}` and it matches at least `m` occurrences and at most `n` occurrences. For example, `\\d{1,3}` would match at least 1 digits and at most 3 digits. To match a year, instead of `\\d\\d\\d\\d`, we could write `\\d{4,4}` which means at least `4` and at most `4` occurrences. In fact, we could rewrite `\\d{4,4}` as `\\d{4}` which means exactly `4` occurrences.\r\n\r\nLet's solve some problems now with `{m,n}`. First, we'll pick the problem of matching movies with a year in their name:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{4}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n<_sre.SRE_Match object; span=(11, 15), match='1992'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Gone With The Wind")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "E=mc2")\r\n>>> \r\n```\r\n\r\nNext, let's look at movie names with at least 6 characters.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r".{6}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Mr. Pip")\r\n<_sre.SRE_Match object; span=(0, 6), match='Mr. Pi'>\r\n>>> # 7 letter movie name matched.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1984")\r\n>>> # 4 letter movie name does not match.\r\n```\r\n\r\nLet's look at another problem. Let's say you want to match numbers 0 to 9. You can easily use `\\d` pattern for this. If you want to match 10 to 99, you can use `\\d\\d` or `\\d{2}` as the pattern. If you want to match 100 to 999, you can use `\\d\\d\\d` or `\\d{3}` as the pattern. What if you want to match numbers 0 to 999? You can do it with `\\d{1,3}` which reads as `\\d` occurs 1 to 3 times. Let's give it a shot:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{1,3}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "8")\r\n<_sre.SRE_Match object; span=(0, 1), match='8'>\r\n>>> # Matches 1 \\d because only 1 is available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "64")\r\n<_sre.SRE_Match object; span=(0, 2), match='64'>\r\n>>> # Matches 2 \\d because only 2 are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "256")\r\n<_sre.SRE_Match object; span=(0, 3), match='256'>\r\n>>> # Matches 3 \\d because all three are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1024")\r\n<_sre.SRE_Match object; span=(0, 3), match='102'>\r\n>>> # Matches 3 \\d and stops looking for more.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "abcdef")\r\n>>> # Not even 1 \\d found. So, not a match.\r\n```\r\n\r\nLet's re-work some of the older problems but this time, make use of `{}` operators to specify number of occurrences.\r\n\r\n--regexquiz\r\nWrite a regex that matches movies with at least 8 characters in their name.\r\n  [ ] Se7en\r\n  [ ] Thr3e\r\n  [ ] E=mc2\r\n  [#] 2001: A Space Odyssey\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n\r\n	2017-07-05 00:01:35.566568	2017-07-05 00:01:35.566595
69	13	1	regex-matching-m-to-n-occurrence	Regex - Matching m To n Occurrences	2	So far, we have encountered multiple instances where we had to specify the number of times a pattern should occur. For example, we tried to match movie names with at least 6 letters (`......`) or movie names with at least 3 letter word followed by at least 4 letter word (`\\w\\w\\w\\s\\w\\w\\w\\w`) or movie names with a year (`\\d\\d\\d\\d`).\r\n\r\nThere is an easier way to specify the number of times a pattern must occur. It's of the form `{m,n}` and it matches at least `m` occurrences and at most `n` occurrences. For example, `\\d{1,3}` would match at least 1 digits and at most 3 digits. To match a year, instead of `\\d\\d\\d\\d`, we could write `\\d{4,4}` which means at least `4` and at most `4` occurrences. In fact, we could rewrite `\\d{4,4}` as `\\d{4}` which means exactly `4` occurrences.\r\n\r\nLet's solve some problems now with `{m,n}`. First, we'll pick the problem of matching movies with a year in their name:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{4}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n<_sre.SRE_Match object; span=(11, 15), match='1992'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Gone With The Wind")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "E=mc2")\r\n>>> \r\n```\r\n\r\nNext, let's look at movie names with at least 6 characters.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r".{6}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Mr. Pip")\r\n<_sre.SRE_Match object; span=(0, 6), match='Mr. Pi'>\r\n>>> # 7 letter movie name matched.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1984")\r\n>>> # 4 letter movie name does not match.\r\n```\r\n\r\nLet's look at another problem. Let's say you want to match numbers 0 to 9. You can easily use `\\d` pattern for this. If you want to match 10 to 99, you can use `\\d\\d` or `\\d{2}` as the pattern. If you want to match 100 to 999, you can use `\\d\\d\\d` or `\\d{3}` as the pattern. What if you want to match numbers 0 to 999? You can do it with `\\d{1,3}` which reads as `\\d` occurs 1 to 3 times. Let's give it a shot:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{1,3}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "8")\r\n<_sre.SRE_Match object; span=(0, 1), match='8'>\r\n>>> # Matches 1 \\d because only 1 is available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "64")\r\n<_sre.SRE_Match object; span=(0, 2), match='64'>\r\n>>> # Matches 2 \\d because only 2 are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "256")\r\n<_sre.SRE_Match object; span=(0, 3), match='256'>\r\n>>> # Matches 3 \\d because all three are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1024")\r\n<_sre.SRE_Match object; span=(0, 3), match='102'>\r\n>>> # Matches 3 \\d and stops looking for more.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "abcdef")\r\n>>> # Not even 1 \\d found. So, not a match.\r\n```\r\n\r\nLet's re-work some of the older problems but this time, make use of `{}` operators to specify number of occurrences.\r\n\r\n--regexquiz\r\nWrite a regex that matches movies with at least 8 characters in their name.\r\n  [ ] Se7en\r\n  [ ] Thr3e\r\n  [ ] E=mc2\r\n  [#] 2001: A Space Odyssey\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n--mcquiz\r\nWhich of the following would match regex `[+-]\\d{1,2}`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. Use the `{m,n}` convention to specify occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [ ] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. The positive numbers could be prefixed with +. So, 64 could also be written as +64. Use the `{m,n}` convention to specify occurrences. Hint: in this case, `[+-]` have 0 to 1 occurrence and `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n\r\n	2017-07-05 00:01:35.566568	2017-07-05 00:01:35.566595
70	13	1	regex-matching-m-to-n-occurrence	Regex - Matching m To n Occurrences	3	So far, we have encountered multiple instances where we had to specify the number of times a pattern should occur. For example, we tried to match movie names with at least 6 letters (`......`) or movie names with at least 3 letter word followed by at least 4 letter word (`\\w\\w\\w\\s\\w\\w\\w\\w`) or movie names with a year (`\\d\\d\\d\\d`).\r\n\r\nThere is an easier way to specify the number of times a pattern must occur. It's of the form `{m,n}` and it matches at least `m` occurrences and at most `n` occurrences. For example, `\\d{1,3}` would match at least 1 digits and at most 3 digits. To match a year, instead of `\\d\\d\\d\\d`, we could write `\\d{4,4}` which means at least `4` and at most `4` occurrences. In fact, we could rewrite `\\d{4,4}` as `\\d{4}` which means exactly `4` occurrences.\r\n\r\nLet's solve some problems now with `{m,n}`. First, we'll pick the problem of matching movies with a year in their name:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{4}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n<_sre.SRE_Match object; span=(11, 15), match='1992'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Gone With The Wind")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "E=mc2")\r\n>>> \r\n```\r\n\r\nNext, let's look at movie names with at least 6 characters.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r".{6}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Mr. Pip")\r\n<_sre.SRE_Match object; span=(0, 6), match='Mr. Pi'>\r\n>>> # 7 letter movie name matched.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1984")\r\n>>> # 4 letter movie name does not match.\r\n```\r\n\r\nLet's look at another problem. Let's say you want to match numbers 0 to 9. You can easily use `\\d` pattern for this. If you want to match 10 to 99, you can use `\\d\\d` or `\\d{2}` as the pattern. If you want to match 100 to 999, you can use `\\d\\d\\d` or `\\d{3}` as the pattern. What if you want to match numbers 0 to 999? You can do it with `\\d{1,3}` which reads as `\\d` occurs 1 to 3 times. Let's give it a shot:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{1,3}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "8")\r\n<_sre.SRE_Match object; span=(0, 1), match='8'>\r\n>>> # Matches 1 \\d because only 1 is available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "64")\r\n<_sre.SRE_Match object; span=(0, 2), match='64'>\r\n>>> # Matches 2 \\d because only 2 are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "256")\r\n<_sre.SRE_Match object; span=(0, 3), match='256'>\r\n>>> # Matches 3 \\d because all three are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1024")\r\n<_sre.SRE_Match object; span=(0, 3), match='102'>\r\n>>> # Matches 3 \\d and stops looking for more.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "abcdef")\r\n>>> # Not even 1 \\d found. So, not a match.\r\n```\r\n\r\nLet's re-work some of the older problems but this time, make use of `{}` operators to specify number of occurrences.\r\n\r\n--regexquiz\r\nWrite a regex that matches movies with at least 8 characters in their name.\r\n  [ ] Se7en\r\n  [ ] Thr3e\r\n  [ ] E=mc2\r\n  [#] 2001: A Space Odyssey\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n--mcquiz\r\nWhich of the following would match regex `[+-]\\d{1,2}`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. Use the `{m,n}` convention to specify occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [ ] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. The positive numbers could be prefixed with +. So, 64 could also be written as +64. Use the `{m,n}` convention to specify occurrences. Hint: in this case, `[+-]` have 0 to 1 occurrence and `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n## m To n Roundup\r\n\r\n`{m,n}` has four variations:\r\n\r\n* `{m,n}` matches at least m and at most n occurrences.\r\n* `{m}` matches exactly m occurrences.\r\n* `{m,}` matches at least m occurrneces (no upper bound).\r\n* `{,n}` matches at least 0 and at most n occurrences.\r\n\r\n\r\n\r\n\r\n\r\n	2017-07-05 00:01:35.566568	2017-07-05 00:01:35.566595
71	13	1	regex-matching-m-to-n-occurrence	Regex - Matching m To n Occurrences	4	So far, we have encountered multiple instances where we had to specify the number of times a pattern should occur. For example, we tried to match movie names with at least 6 letters (`......`) or movie names with at least 3 letter word followed by at least 4 letter word (`\\w\\w\\w\\s\\w\\w\\w\\w`) or movie names with a year (`\\d\\d\\d\\d`).\r\n\r\nThere is an easier way to specify the number of times a pattern must occur. It's of the form `{m,n}` and it matches at least `m` occurrences and at most `n` occurrences. For example, `\\d{1,3}` would match at least 1 digits and at most 3 digits. To match a year, instead of `\\d\\d\\d\\d`, we could write `\\d{4,4}` which means at least `4` and at most `4` occurrences. In fact, we could rewrite `\\d{4,4}` as `\\d{4}` which means exactly `4` occurrences.\r\n\r\nLet's solve some problems now with `{m,n}`. First, we'll pick the problem of matching movies with a year in their name:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{4}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n<_sre.SRE_Match object; span=(11, 15), match='1992'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Gone With The Wind")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "E=mc2")\r\n>>> \r\n```\r\n\r\nNext, let's look at movie names with at least 6 characters.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r".{6}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Mr. Pip")\r\n<_sre.SRE_Match object; span=(0, 6), match='Mr. Pi'>\r\n>>> # 7 letter movie name matched.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1984")\r\n>>> # 4 letter movie name does not match.\r\n```\r\n\r\nLet's look at another problem. Let's say you want to match numbers 0 to 9. You can easily use `\\d` pattern for this. If you want to match 10 to 99, you can use `\\d\\d` or `\\d{2}` as the pattern. If you want to match 100 to 999, you can use `\\d\\d\\d` or `\\d{3}` as the pattern. What if you want to match numbers 0 to 999? You can do it with `\\d{1,3}` which reads as `\\d` occurs 1 to 3 times. Let's give it a shot:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{1,3}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "8")\r\n<_sre.SRE_Match object; span=(0, 1), match='8'>\r\n>>> # Matches 1 \\d because only 1 is available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "64")\r\n<_sre.SRE_Match object; span=(0, 2), match='64'>\r\n>>> # Matches 2 \\d because only 2 are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "256")\r\n<_sre.SRE_Match object; span=(0, 3), match='256'>\r\n>>> # Matches 3 \\d because all three are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1024")\r\n<_sre.SRE_Match object; span=(0, 3), match='102'>\r\n>>> # Matches 3 \\d and stops looking for more.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "abcdef")\r\n>>> # Not even 1 \\d found. So, not a match.\r\n```\r\n\r\nLet's re-work some of the older problems but this time, make use of `{}` operators to specify number of occurrences.\r\n\r\n--regexquiz\r\nWrite a regex that matches movies with at least 8 characters in their name.\r\n  [ ] Se7en\r\n  [ ] Thr3e\r\n  [ ] E=mc2\r\n  [#] 2001: A Space Odyssey\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n--mcquiz\r\nWhich of the following would match regex `[+-]\\d{1,2}`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. Use the `{m,n}` convention to specify occurrences. Hint: `-` has 0 to 1 occurrence while `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [ ] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. The positive numbers could be prefixed with +. So, 64 could also be written as +64. Use the `{m,n}` convention to specify occurrences. Hint: in this case, `[+-]` have 0 to 1 occurrence and `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n## m To n Roundup\r\n\r\n`{m,n}` has four variations:\r\n\r\n* `{m,n}` matches at least m and at most n occurrences.\r\n* `{m}` matches exactly m occurrences.\r\n* `{m,}` matches at least m occurrneces (no upper bound).\r\n* `{,n}` matches at least 0 and at most n occurrences.\r\n\r\n\r\n\r\n\r\n\r\n	2017-07-05 00:01:35.566568	2017-07-05 00:01:35.566595
72	14	1	regex-repetition-count-symbols	Regex - ?, * and +	1	Some of the `{m,n}` are so commonly used that there are special symbols for them. Here is the list:\r\n\r\n* `?` is same as `{0,1}`. `\\d?` means a digit may or may not be there.\r\n* `*` is same as `{0,}`. `\\d*` means a digit may not be there or there may be infinite occurrences of the same.\r\n* `+` is same as `{1,}`. `\\d+` means that at least one digit is present and it may repeat infinitely.\r\n\r\nLet's put them to some use.\r\n\r\n## ? ({0,1})\r\n\r\nIf you want to match numbers 0 to 99, you can do it with `\\d{1,2}` or `\\d?\\d`. Let's try:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search("\\d?\\d", "43")\r\n<_sre.SRE_Match object; span=(0, 2), match='43'>\r\n>>>\r\n>>> re.search("\\d?\\d", "4")\r\n<_sre.SRE_Match object; span=(0, 1), match='4'>\r\n```\r\n\r\nNote: the pattern `r"\\d?\\d"` would always try to look for two digits as a first thing. However, if it doesn’t find two, it would settle for one. That’s different from `r"\\d"` which would always try to match one digit.\r\n\r\n--mcquiz\r\nWhich of the following would match regex `[+-]\\d?\\d`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -99 to 99. So, it should match -99, -98, …, 98, 99.\r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [ ] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -99 to 99. The +ve numbers may be written with or without a `+` prefix. For example, 98 could be written as 98 or +98. \r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n## * or {0,}\r\n\r\nJust like `?` matches something that’s optional, `*` matches something that’s optional and yet it can have more than 1 occurrences. So, `r"BA*T"` will match `"BT"`, `"BAT"` as well as `"BAAAAAAAAT"`.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "BA*T", "BT")\r\n<_sre.SRE_Match object; span=(0, 2), match='BT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAT")\r\n<_sre.SRE_Match object; span=(0, 3), match='BAT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAAAAAT")\r\n<_sre.SRE_Match object; span=(0, 7), match='BAAAAAT'>\r\n```\r\n\r\n--mcquiz\r\nWhich of the following would match regex `\\w\\s*:\\s*\\w`:\r\n  [#] Potatoes: 4\r\n  [#] Potatoes:4\r\n  [#] Potatoes    :     4\r\n  [#] 4: Potatoes\r\n  [ ] Potatoes ~::~ 4\r\n  [ ] :Potatoes:\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match the sentences that mention cat followed by dog. Hint: use repetition of `.` to match word & space characters.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [ ] The dog looked at the cat with confusion.\r\n  [ ] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match sentences that mention cat and dog in any order (i.e. word cat could come before or after the word dog). Hint: Use the `|` operator.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [#] The dog looked at the cat with confusion.\r\n  [#] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n  [ ] The dog went wild.\r\n--\r\n\r\n## + or {1,}\r\n\r\nJust like `*` matches 0 or more occurrences, `+` matches 1 or more occurrences. That means the preceding pattern is not optional. There has to be at least one instance but it can repeat any number of times. Where is it useful? Let’s say we want to match `Yikes` as well as `Yiiiiiiiikkkkkes` in our text. They eventually mean the same thing with different intensity. We could do something like this:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "Yi+k+es", "Yikes" )\r\n<_sre.SRE_Match object; span=(0, 5), match='Yikes'>\r\n>>>\r\n>>> re.search( "Yi+k+es", "Yiiiiiiiiikkkkkes" )\r\n<_sre.SRE_Match object; span=(0, 17), match='Yiiiiiiiiikkkkkes'>\r\n>>>\r\n```\r\n\r\nHow do you find out the names of movies that have at least 2 words? Something along the lines of `\\w+\\s+\\w+` would do the trick.\r\n\r\n--regexquiz\r\nWrite a regex to match movies with at least three words in their name.\r\n  [#] Gone With The Wind\r\n  [ ] Superman\r\n  [#] La La Land\r\n  [#] The Sixth Sense\r\n  [ ] Braveheart\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match movies with at least four words in their name. Note: you have to match `:` as part of characters between words. Hint: you can use `[]` or `|` for matching characters between words.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n  [ ] Shawshank Redemption\r\n  [#] 2001: A Space Odyssey\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match the sentences that mention two years.\r\n  [#] 1984 comes before 1999.\r\n  [#] 2004 comes after 2001.\r\n  [ ] In 2015, I bought 2 cars.\r\n  [ ] There was a flood in 1999.\r\n--\r\n\r\n\r\n\r\n	2017-07-05 00:01:35.566568	2017-07-05 00:01:35.566595
73	14	1	regex-repetition-count-symbols	Regex - ?, * and +	2	Some of the `{m,n}` are so commonly used that there are special symbols for them. Here is the list:\r\n\r\n* `?` is same as `{0,1}`. `\\d?` means a digit may or may not be there.\r\n* `*` is same as `{0,}`. `\\d*` means a digit may not be there or there may be infinite occurrences of the same.\r\n* `+` is same as `{1,}`. `\\d+` means that at least one digit is present and it may repeat infinitely.\r\n\r\nLet's put them to some use.\r\n\r\n## ? or {0,1}\r\n\r\nIf you want to match numbers 0 to 99, you can do it with `\\d{1,2}` or `\\d?\\d`. Let's try:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search("\\d?\\d", "43")\r\n<_sre.SRE_Match object; span=(0, 2), match='43'>\r\n>>>\r\n>>> re.search("\\d?\\d", "4")\r\n<_sre.SRE_Match object; span=(0, 1), match='4'>\r\n```\r\n\r\nNote: the pattern `r"\\d?\\d"` would always try to look for two digits as a first thing. However, if it doesn’t find two, it would settle for one. That’s different from `r"\\d"` which would always try to match one digit.\r\n\r\n--mcquiz\r\nWhich of the following would match regex `[+-]\\d?\\d`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -99 to 99. So, it should match -99, -98, …, 98, 99.\r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [ ] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -99 to 99. The +ve numbers may be written with or without a `+` prefix. For example, 98 could be written as 98 or +98. \r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n## * or {0,}\r\n\r\nJust like `?` matches something that’s optional, `*` matches something that’s optional and yet it can have more than 1 occurrences. So, `r"BA*T"` will match `"BT"`, `"BAT"` as well as `"BAAAAAAAAT"`.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "BA*T", "BT")\r\n<_sre.SRE_Match object; span=(0, 2), match='BT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAT")\r\n<_sre.SRE_Match object; span=(0, 3), match='BAT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAAAAAT")\r\n<_sre.SRE_Match object; span=(0, 7), match='BAAAAAT'>\r\n```\r\n\r\n--mcquiz\r\nWhich of the following would match regex `\\w\\s*:\\s*\\w`:\r\n  [#] Potatoes: 4\r\n  [#] Potatoes:4\r\n  [#] Potatoes    :     4\r\n  [#] 4: Potatoes\r\n  [ ] Potatoes ~::~ 4\r\n  [ ] :Potatoes:\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match the sentences that mention cat followed by dog. Hint: use repetition of `.` to match word & space characters.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [ ] The dog looked at the cat with confusion.\r\n  [ ] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match sentences that mention cat and dog in any order (i.e. word cat could come before or after the word dog). Hint: Use the `|` operator.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [#] The dog looked at the cat with confusion.\r\n  [#] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n  [ ] The dog went wild.\r\n--\r\n\r\n## + or {1,}\r\n\r\nJust like `*` matches 0 or more occurrences, `+` matches 1 or more occurrences. That means the preceding pattern is not optional. There has to be at least one instance but it can repeat any number of times. Where is it useful? Let’s say we want to match `Yikes` as well as `Yiiiiiiiikkkkkes` in our text. They eventually mean the same thing with different intensity. We could do something like this:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "Yi+k+es", "Yikes" )\r\n<_sre.SRE_Match object; span=(0, 5), match='Yikes'>\r\n>>>\r\n>>> re.search( "Yi+k+es", "Yiiiiiiiiikkkkkes" )\r\n<_sre.SRE_Match object; span=(0, 17), match='Yiiiiiiiiikkkkkes'>\r\n>>>\r\n```\r\n\r\nHow do you find out the names of movies that have at least 2 words? Something along the lines of `\\w+\\s+\\w+` would do the trick.\r\n\r\n--regexquiz\r\nWrite a regex to match movies with at least three words in their name.\r\n  [#] Gone With The Wind\r\n  [ ] Superman\r\n  [#] La La Land\r\n  [#] The Sixth Sense\r\n  [ ] Braveheart\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match movies with at least four words in their name. Note: you have to match `:` as part of characters between words. Hint: you can use `[]` or `|` for matching characters between words.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n  [ ] Shawshank Redemption\r\n  [#] 2001: A Space Odyssey\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match the sentences that mention two years.\r\n  [#] 1984 comes before 1999.\r\n  [#] 2004 comes after 2001.\r\n  [ ] In 2015, I bought 2 cars.\r\n  [ ] There was a flood in 1999.\r\n--\r\n\r\n\r\n\r\n	2017-07-05 00:01:35.566568	2017-07-05 00:01:35.566595
74	7	1	regex-matching-literals	Regex - Matching Literals	6	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nThe regex pattern optionally starts with `r`. It just marks the following string as a regular expression.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `r"Window"`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-07-05 00:01:35.566568	2017-07-05 00:01:35.566595
75	7	1	regex-matching-literals	Regex - Matching Literals	7	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nThe regex pattern optionally starts with `r`. It just marks the following string as a regular expression.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-07-05 00:01:35.566568	2017-07-05 00:01:35.566595
76	13	1	regex-matching-m-to-n-occurrence	Regex - Matching m To n Occurrences	5	In regex, the general purpose method of matching certain number of occurrences is to use `{m,n}`. `\\d{2,4}` would match at least 2 and at most 4 occurrences of `\\d`.\r\n\r\nEarlier, we wrote the regex `\\d\\d\\d\\d` for matching a year in movie name. The same could be re-written as `\\d{4,4}` which matches at least 4 and at most 4 occurrences of `\\d`. It could be further shortened to `\\d{4}`.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{4}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n<_sre.SRE_Match object; span=(11, 15), match='1992'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Gone With The Wind")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "E=mc2")\r\n>>> \r\n```\r\n\r\n--mcquiz\r\nWrite a regex that matches movie names that have at least 12 letters. Use the `{}` syntax.\r\n  [ ] 1984\r\n  [ ] Superman\r\n  [#] Spiderman Returns\r\n  [#] Star Wars: Return of the Jedi\r\n--\r\n\r\nLet's look at a different problem this time. You want to match numbers 0 to 999. How would you do that? `\\d{1,3}` would do the trick.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{1,3}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "8")\r\n<_sre.SRE_Match object; span=(0, 1), match='8'>\r\n>>> # Matches 1 \\d because only 1 is available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "64")\r\n<_sre.SRE_Match object; span=(0, 2), match='64'>\r\n>>> # Matches 2 \\d because only 2 are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "256")\r\n<_sre.SRE_Match object; span=(0, 3), match='256'>\r\n>>> # Matches 3 \\d because all three are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1024")\r\n<_sre.SRE_Match object; span=(0, 3), match='102'>\r\n>>> # Matches 3 \\d and stops looking for more.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "abcdef")\r\n>>> # Not even 1 \\d found. So, not a match.\r\n```\r\n\r\nLet's re-work some of the older problems but this time, make use of `{}` operators to specify number of occurrences.\r\n\r\n\r\n--mcquiz\r\nWhich of the following would match regex `[+-]\\d{1,2}`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. Use the `{m,n}` convention to specify occurrences. Hint: `-` has 0 to 1 occurrence while `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [ ] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. The positive numbers could be prefixed with +. So, 64 could also be written as +64. Use the `{m,n}` convention to specify occurrences. Hint: in this case, `[+-]` have 0 to 1 occurrence and `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] Spinderman Returns\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n## m To n Roundup\r\n\r\n`{m,n}` has four variations:\r\n\r\n* `{m,n}` matches at least m and at most n occurrences.\r\n* `{m}` matches exactly m occurrences.\r\n* `{m,}` matches at least m occurrneces (no upper bound).\r\n* `{,n}` matches at least 0 and at most n occurrences.\r\n\r\n	2017-07-05 05:27:39.160467	2017-07-05 05:27:39.160499
77	3	1	regex-problem-statement	Regex - Problem Statement	4	Continuing from the previous section, here is the sample information you received from the students of your school:\r\n\r\n```\r\nGoogle\r\nFacebook\r\nInstagram\r\nWattPad\r\ngoogle.com\r\nfacebook.com\r\nwattpad.com\r\nwww.google.com\r\nwww.facebook.com\r\nwww.wattpad.com\r\nhttps://www.wattpad.com/tags/children\r\nhttps://www.facebook.com/home\r\nhttps://www.instagram.com\r\n```\r\n\r\nEven though there is quite a variety in the way information is represented, there is a pattern here. You intuitively know that `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children` mean the same thing in this context. They all mean that the student has singled out `wattpad` as the favorite site.\r\n\r\nThis is where the problem is: how do you map all these variations of `wattpad` to just what it is (i.e. `wattpad`)? To your mind, the pattern is clear and you can easily see the mapping. However, if you were to write a program for this purpose, it would be a fairly involved task.\r\n\r\nThis is where regular expresions shine. They give you a powerful language to describe the pattern (or the variations thereof).\r\n\r\n\r\n	2017-07-06 00:43:32.70291	2017-07-06 00:43:32.702955
78	3	1	regex-problem-statement	Regex - Problem Statement	5	Continuing from the previous section, here is the sample information you received from the students of your school:\r\n\r\n```\r\nGoogle\r\nFacebook\r\nInstagram\r\nWattPad\r\ngoogle.com\r\nfacebook.com\r\nwattpad.com\r\nwww.google.com\r\nwww.facebook.com\r\nwww.wattpad.com\r\nhttps://www.wattpad.com/tags/children\r\nhttps://www.facebook.com/home\r\nhttps://www.instagram.com\r\n```\r\n\r\nEven though there is quite a variety in the way information is represented, there is a pattern here. You intuitively know that `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children` mean the same thing in this context. They all mean that the student has singled out `wattpad` as the favorite site.\r\n\r\nThis is where the problem is: how do you map all these variations of `wattpad` to just what it is (i.e. `wattpad`)? To your mind, the pattern is clear and you can easily see the mapping. However, if you were to write a program for this purpose, it would be a fairly involved task.\r\n\r\nThis is where regular expresions shine. They give you a powerful language to describe the pattern (or the variations thereof).\r\n\r\n\r\n	2017-07-06 00:43:32.70291	2017-07-06 00:43:32.702955
79	15	1	regex-matching-0-or-1-occurrences	Regex - ? (Matching 0 or 1 Occurrence)	1	`?` is a shortform of `{0,1}`. A pattern should match at least 0 and at most 1 time. Effectively, it's another way of saying that the pattern may or may not be there. It's used very frequently.\r\n\r\nLet's revisit the problem of matching numbers from -9 to 9. Also, 7 could be written as 7 as well as +7. We could re-write the previous regex (`[+-]{0,1}\\d`) as `[+-]?\\d`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[+-]?\\d"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "-7")\r\n<_sre.SRE_Match object; span=(0, 2), match='-7'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "7")\r\n<_sre.SRE_Match object; span=(0, 1), match='7'>\r\n>>> re.search(REGEX_PATTERN, "+7")\r\n>>> \r\n<_sre.SRE_Match object; span=(0, 2), match='+7'>\r\n>>> \r\n```\r\n\r\n--mcquiz\r\nWhich of the following would match regex `[+-]\\d?\\d`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -99 to 99. The +ve numbers may be written with or without a `+` prefix. For example, 98 could be written as 98 or +98. \r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match `http://` as well as `https://` urls.\r\n  [#] https://www.google.com\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] http://www.yahoo.com\r\n  [ ] ftp://www.google.com\r\n  [ ] scp://www.yahoo.com\r\n  [ ] http-proto\r\n  [ ] https is a protocol\r\n--\r\n  \r\n  \r\n  \r\n  \r\n  \r\n\r\n	2017-07-06 00:43:32.70291	2017-07-06 00:43:32.702955
80	16	1	regex-matching-0-or-more-occurrences	Regex - * (Matching 0 or More Occurrences)	1	`*` is a shorthand symbol for `{0,}` which means at least 0 and at most infinite matches. `BA*T` would match `BT`, `BAT`, `BAAAAAAAAAAAAAAAAAAAAAT` etc.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "BA*T", "BT")\r\n<_sre.SRE_Match object; span=(0, 2), match='BT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAT")\r\n<_sre.SRE_Match object; span=(0, 3), match='BAT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAAAAAT")\r\n<_sre.SRE_Match object; span=(0, 7), match='BAAAAAT'>\r\n```\r\n\r\n--mcquiz\r\nWhich of the following would match regex `\\w\\s*:\\s*\\w`:\r\n  [#] Potatoes: 4\r\n  [#] Potatoes:4\r\n  [#] Potatoes    :     4\r\n  [#] 4: Potatoes\r\n  [ ] Potatoes ~::~ 4\r\n  [ ] :Potatoes:\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that matches `http` and `https` urls that end with `.com` or `.org` domains. Hint: you'll need `.*`.\r\n  [#] http://www.google.com\r\n  [#] http://yahoo.org\r\n  [#] http://www.facebook.com/profile\r\n  [#] http://www.wattpad.com/tags/fiction\r\n  [ ] ftp://www.google.com\r\n  [ ] http://www.yahoo.net\r\n  [#] https://www.facebook.com\r\n  [ ] https://www.photo.net\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match the sentences that mention cat followed by dog. Hint: use repetition of `.` to match word & space characters.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [ ] The dog looked at the cat with confusion.\r\n  [ ] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match sentences that mention cat and dog in any order (i.e. word cat could come before or after the word dog). Hint: Use the `|` operator.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [#] The dog looked at the cat with confusion.\r\n  [#] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n  [ ] The dog went wild.\r\n--\r\n	2017-07-06 00:43:32.70291	2017-07-06 00:43:32.702955
81	17	1	regex-matching-1-or-more-occurrences	Regex - + (Match 1 or More Occurrences)	1	`+` stands for `{1,}` which matches at least 1 and at most infinite times.\r\n\r\nHow do you match the movies with at least 2 words in their name? `\\w+\\s+\\w+` would do the trick. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\w+\\s+\\w+"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Spiderman Returns")\r\n<_sre.SRE_Match object; span=(0, 17), match='Spiderman Returns'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Spiderman")\r\n>>> \r\n```\r\n\r\n--regexquiz\r\nWrite a regex to match movies with at least three words in their name.\r\n  [#] Gone With The Wind\r\n  [ ] Superman\r\n  [#] La La Land\r\n  [#] The Sixth Sense\r\n  [ ] Braveheart\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match movies with at least four words in their name. Note: you have to match `:` as part of characters between words. Hint: you can use `[]` or `|` for matching characters between words.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n  [ ] Shawshank Redemption\r\n  [#] 2001: A Space Odyssey\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match the sentences that mention two years.\r\n  [#] 1984 comes before 1999.\r\n  [#] 2004 comes after 2001.\r\n  [ ] In 2015, I bought 2 cars.\r\n  [ ] There was a flood in 1999.\r\n--\r\n	2017-07-06 00:43:32.70291	2017-07-06 00:43:32.702955
82	13	1	regex-matching-m-to-n-occurrence	Regex - Matching m To n Occurrences	6	In regex, the general purpose method of matching certain number of occurrences is to use `{m,n}`. `\\d{2,4}` would match at least 2 and at most 4 occurrences of `\\d`.\r\n\r\nEarlier, we wrote the regex `\\d\\d\\d\\d` for matching a year in movie name. The same could be re-written as `\\d{4,4}` which matches at least 4 and at most 4 occurrences of `\\d`. It could be further shortened to `\\d{4}`.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{4}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n<_sre.SRE_Match object; span=(11, 15), match='1992'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Gone With The Wind")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "E=mc2")\r\n>>> \r\n```\r\n\r\n--regexquiz\r\nWrite a regex that matches movie names that have at least 12 letters. Use the `{}` syntax.\r\n  [ ] 1984\r\n  [ ] Superman\r\n  [#] Spiderman Returns\r\n  [#] Star Wars: Return of the Jedi\r\n--\r\n\r\nLet's look at a different problem this time. You want to match numbers 0 to 999. How would you do that? `\\d{1,3}` would do the trick.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{1,3}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "8")\r\n<_sre.SRE_Match object; span=(0, 1), match='8'>\r\n>>> # Matches 1 \\d because only 1 is available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "64")\r\n<_sre.SRE_Match object; span=(0, 2), match='64'>\r\n>>> # Matches 2 \\d because only 2 are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "256")\r\n<_sre.SRE_Match object; span=(0, 3), match='256'>\r\n>>> # Matches 3 \\d because all three are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1024")\r\n<_sre.SRE_Match object; span=(0, 3), match='102'>\r\n>>> # Matches 3 \\d and stops looking for more.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "abcdef")\r\n>>> # Not even 1 \\d found. So, not a match.\r\n```\r\n\r\nLet's re-work some of the older problems but this time, make use of `{}` operators to specify number of occurrences.\r\n\r\n\r\n--mcquiz\r\nWhich of the following would match regex `[+-]\\d{1,2}`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. Use the `{m,n}` convention to specify occurrences. Hint: `-` has 0 to 1 occurrence while `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [ ] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. The positive numbers could be prefixed with +. So, 64 could also be written as +64. Use the `{m,n}` convention to specify occurrences. Hint: in this case, `[+-]` have 0 to 1 occurrence and `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] Spinderman Returns\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n## m To n Roundup\r\n\r\n`{m,n}` has four variations:\r\n\r\n* `{m,n}` matches at least m and at most n occurrences.\r\n* `{m}` matches exactly m occurrences.\r\n* `{m,}` matches at least m occurrneces (no upper bound).\r\n* `{,n}` matches at least 0 and at most n occurrences.\r\n\r\n	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
83	16	1	regex-matching-0-or-more-occurrences	Regex - * (Matching 0 or More Occurrences)	2	`*` stands for `{0,}` which means at least 0 and at most infinite matches. `BA*T` would match `BT`, `BAT`, `BAAAAAAAAAAAAAAAAAAAAAT` etc.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "BA*T", "BT")\r\n<_sre.SRE_Match object; span=(0, 2), match='BT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAT")\r\n<_sre.SRE_Match object; span=(0, 3), match='BAT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAAAAAT")\r\n<_sre.SRE_Match object; span=(0, 7), match='BAAAAAT'>\r\n```\r\n\r\n--mcquiz\r\nWhich of the following would match regex `\\w\\s*:\\s*\\w`:\r\n  [#] Potatoes: 4\r\n  [#] Potatoes:4\r\n  [#] Potatoes    :     4\r\n  [#] 4: Potatoes\r\n  [ ] Potatoes ~::~ 4\r\n  [ ] :Potatoes:\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that matches `http` and `https` urls that end with `.com` or `.org` domains. Hint: you'll need `.*`.\r\n  [#] http://www.google.com\r\n  [#] http://yahoo.org\r\n  [#] http://www.facebook.com/profile\r\n  [#] http://www.wattpad.com/tags/fiction\r\n  [ ] ftp://www.google.com\r\n  [ ] http://www.yahoo.net\r\n  [#] https://www.facebook.com\r\n  [ ] https://www.photo.net\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match the sentences that mention cat followed by dog. Hint: use repetition of `.` to match word & space characters.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [ ] The dog looked at the cat with confusion.\r\n  [ ] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match sentences that mention cat and dog in any order (i.e. word cat could come before or after the word dog). Hint: Use the `|` operator.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [#] The dog looked at the cat with confusion.\r\n  [#] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n  [ ] The dog went wild.\r\n--\r\n	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
84	15	1	regex-matching-0-or-1-occurrences	Regex - ? (Matching 0 or 1 Occurrence)	2	`?` stands for `{0,1}`. A pattern should match at least 0 and at most 1 time. Effectively, it's another way of saying that the pattern may or may not be there. It's used very frequently.\r\n\r\nLet's revisit the problem of matching numbers from -9 to 9. Also, 7 could be written as 7 as well as +7. We could re-write the previous regex (`[+-]{0,1}\\d`) as `[+-]?\\d`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[+-]?\\d"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "-7")\r\n<_sre.SRE_Match object; span=(0, 2), match='-7'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "7")\r\n<_sre.SRE_Match object; span=(0, 1), match='7'>\r\n>>> re.search(REGEX_PATTERN, "+7")\r\n>>> \r\n<_sre.SRE_Match object; span=(0, 2), match='+7'>\r\n>>> \r\n```\r\n\r\n--mcquiz\r\nWhich of the following would match regex `[+-]\\d?\\d`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -99 to 99. The +ve numbers may be written with or without a `+` prefix. For example, 98 could be written as 98 or +98. \r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match `http://` as well as `https://` urls.\r\n  [#] https://www.google.com\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] http://www.yahoo.com\r\n  [ ] ftp://www.google.com\r\n  [ ] scp://www.yahoo.com\r\n  [ ] http-proto\r\n  [ ] https is a protocol\r\n--\r\n  \r\n  \r\n  \r\n  \r\n  \r\n\r\n	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
85	18	1	regex-matching-boundaries	Regex - Matching Boundaries	1	Let's say, we want to match the text which has the word `cat` in it. We could use the regex `cat`. This regex would match `cat is fat`, `the cat jumped over the wall` etc. But it would also match `he was herding the cattle` :(\r\n\r\nIf we modify the regex to `cat\\s`, we can avoid matching `he was herding the cattle`. But it would still match `this muscat is funny`.\r\n\r\nHow about `\\scat\\s` as the regex? The problem is that it would not match `cat jumped` or `this is my cat.`.\r\n\r\nRegex has the ability to match boundaries of words & lines that would help us in this scenario. Let's see how...	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
86	19	1	regex-matching-word-boundaries	Regex - Matching Word Boundaries	1	In regex, `\\b` matches word boundary. What does it mean? Let's first define what a word is.\r\n\r\nIn regex, a word is an unbroken sequence of `[A-Za-z0-9_]` or `\\w`. The sentence `cat jumped` has two words: `cat` and `jumped`. OTOH, `key:value` has two words: `key` and `value`.\r\n\r\nSymbol `\\b` matches at the start and end of word boundary. The regex `\\bcat\\b` would match sentences that have word `cat`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\bcat\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "cat is fat")\r\n<_sre.SRE_Match object; span=(0, 3), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "the cat jumped over the wall.")\r\n<_sre.SRE_Match object; span=(4, 7), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this is my cat.")\r\n<_sre.SRE_Match object; span=(11, 14), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "he was herding the cattle.")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this muscat is funny.")\r\n>>> \r\n```\r\n\r\n	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
87	19	1	regex-matching-word-boundaries	Regex - Matching Word Boundaries	2	In regex, `\\b` matches word boundary. What does it mean? Let's first define what a word is.\r\n\r\nIn regex, a word is an unbroken sequence of `[A-Za-z0-9_]` or `\\w`. The sentence `cat jumped` has two words: `cat` and `jumped`. OTOH, `key:value` has two words: `key` and `value`. Even `http-proto` has two words: `http` and `proto`.\r\n\r\nSymbol `\\b` matches at the start and end of word boundary. The regex `\\bcat\\b` would match sentences that have word `cat`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\bcat\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "cat is fat")\r\n<_sre.SRE_Match object; span=(0, 3), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "the cat jumped over the wall.")\r\n<_sre.SRE_Match object; span=(4, 7), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this is my cat.")\r\n<_sre.SRE_Match object; span=(11, 14), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "he was herding the cattle.")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this muscat is funny.")\r\n>>> \r\n```\r\n\r\n--mcquiz\r\nHow many words (as per regex definition) are there in `http://www.google.com/search`?\r\n  [ ] 3\r\n  [ ] 4\r\n  [#] 5\r\n  [ ] 6\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match sentences that mention animal dog.\r\n  [#] a dog was barking.\r\n  [#] dog is a loyal animal.\r\n  [#] this is my dog.\r\n  [ ] is it a dogfish?\r\n  [ ] dogfood is about using your own software.\r\n--\r\n\r\n\r\n\r\n	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
88	19	1	regex-matching-word-boundaries	Regex - Matching Word Boundaries	3	In regex, `\\b` matches word boundary. What does it mean? Let's first define what a word is.\r\n\r\nIn regex, a word is an unbroken sequence of `[A-Za-z0-9_]` or `\\w`. The sentence `cat jumped` has two words: `cat` and `jumped`. OTOH, `key:value` has two words: `key` and `value`. Even `http-proto` has two words: `http` and `proto`.\r\n\r\nSymbol `\\b` matches at the start and end of word boundary. The regex `\\bcat\\b` would match sentences that have word `cat`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\bcat\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "cat is fat")\r\n<_sre.SRE_Match object; span=(0, 3), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "the cat jumped over the wall.")\r\n<_sre.SRE_Match object; span=(4, 7), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this is my cat.")\r\n<_sre.SRE_Match object; span=(11, 14), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "he was herding the cattle.")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this muscat is funny.")\r\n>>> \r\n```\r\n\r\n--mcquiz\r\nHow many words (as per regex definition) are there in `http://www.google.com/search`?\r\n  [ ] 3\r\n  [ ] 4\r\n  [#] 5\r\n  [ ] 6\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match sentences that mention animal dog.\r\n  [#] a dog was barking.\r\n  [#] dog is a loyal animal.\r\n  [#] this is my dog.\r\n  [ ] is it a dogfish?\r\n  [ ] dogfood is about using your own software.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that matches sentences with at least one word that has exactly 5 letters.\r\n  [#] I am a super human.\r\n  [#] Spice route is not spicy.\r\n  [ ] Spiderman returns is not interesting.\r\n  [ ] Cat can jump.\r\n  [#] Cat can't climb.\r\n--\r\n\r\n\r\n	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
89	20	1	regex-matching-line-boundaries	Regex - Matching Line Boundaries	1	Just like words have boundaris that we can match with `\\b`, lines also have boundaries that we can match with `^` (start of line) and `$` (end of line).	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
90	19	1	regex-matching-word-boundaries	Regex - Matching Word Boundaries	4	In regex, `\\b` matches word boundary. What does it mean? Let's first define what a word is.\r\n\r\nIn regex, a word is an unbroken sequence of `[A-Za-z0-9_]` or `\\w`. The sentence `cat jumped` has two words: `cat` and `jumped`. OTOH, `key:value` has two words: `key` and `value`. Even `http-proto` has two words: `http` and `proto`.\r\n\r\nSymbol `\\b` matches at the start and end of word boundary. The regex `\\bcat\\b` would match sentences that have word `cat`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\bcat\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "cat is fat")\r\n<_sre.SRE_Match object; span=(0, 3), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "the cat jumped over the wall.")\r\n<_sre.SRE_Match object; span=(4, 7), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this is my cat.")\r\n<_sre.SRE_Match object; span=(11, 14), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "he was herding the cattle.")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this muscat is funny.")\r\n>>> \r\n```\r\n\r\n--mcquiz\r\nHow many words (as per regex definition) are there in `http://www.google.com/search`?\r\n  [ ] 3\r\n  [ ] 4\r\n  [#] 5\r\n  [ ] 6\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match sentences that mention animal dog.\r\n  [#] a dog was barking.\r\n  [#] dog is a loyal animal.\r\n  [#] this is my dog.\r\n  [ ] is it a dogfish?\r\n  [ ] dogfood is about using your own software.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that matches sentences with at least one word that has exactly 5 letters.\r\n  [#] I am a super human.\r\n  [#] Spice route is not spicy.\r\n  [ ] Spiderman returns is not interesting.\r\n  [ ] Cat can jump.\r\n  [#] Cat can't climb.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that matches sentences that have a year in 4 digit format.\r\n  [#] In year 2000, there was an earthquake.\r\n  [#] 1984.\r\n  [#] In 2020, I'll be 20 years old.\r\n  [ ] I am 20 years old now.\r\n  [ ] 123456789 is a really long number.\r\n--\r\n	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
91	20	1	regex-matching-line-boundaries	Regex - Matching Line Boundaries	2	Just like words have boundaris that we can match with `\\b`, lines also have boundaries that we can match with `^` (start of line) and `$` (end of line).\r\n\r\nLet's say we want to match movie names that start with a year. So, we should match `2001: A Space Odyssey` but not `Dracula A.D. 1972`. We could use the pattern `^\\d{4}\\b` to do just that.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"^\\d{4}\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n<_sre.SRE_Match object; span=(0, 4), match='2009'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "44500 Max")\r\n>>> # Not a match\r\n>>>\r\n```	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
92	20	1	regex-matching-line-boundaries	Regex - Matching Line Boundaries	3	Just like words have boundaris that we can match with `\\b`, lines also have boundaries that we can match with `^` (start of line) and `$` (end of line).\r\n\r\nLet's say we want to match movie names that start with a year. So, we should match `2001: A Space Odyssey` but not `Dracula A.D. 1972`. We could use the pattern `^\\d{4}\\b` to do just that.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"^\\d{4}\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n<_sre.SRE_Match object; span=(0, 4), match='2009'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "44500 Max")\r\n>>> # Not a match\r\n>>>\r\n```\r\n\r\nSimilarly, we can use the pattern `\\b\\d{4}$` to match movie names that end with a year.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\b\\d{4}$"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n<_sre.SRE_Match object; span=(19, 23), match='1940'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n>>> # Not a match\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "Super 23123")\r\n>>> # Not a match\r\n>>> \r\n```	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
93	20	1	regex-matching-line-boundaries	Regex - Matching Line Boundaries	4	Just like words have boundaris that we can match with `\\b`, lines also have boundaries that we can match with `^` (start of line) and `$` (end of line).\r\n\r\nLet's say we want to match movie names that start with a year. So, we should match `2001: A Space Odyssey` but not `Dracula A.D. 1972`. We could use the pattern `^\\d{4}\\b` to do just that.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"^\\d{4}\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n<_sre.SRE_Match object; span=(0, 4), match='2009'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "44500 Max")\r\n>>> # Not a match\r\n>>>\r\n```\r\n\r\nSimilarly, we can use the pattern `\\b\\d{4}$` to match movie names that end with a year.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\b\\d{4}$"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n<_sre.SRE_Match object; span=(19, 23), match='1940'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n>>> # Not a match\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "Super 23123")\r\n>>> # Not a match\r\n>>> \r\n```\r\n\r\n--regexquiz\r\nWrite a regex that matches movie names that have nothing but a year.\r\n  [#] 1984\r\n  [#] 1971\r\n  [#] 2081\r\n  [ ] AM1200\r\n  [ ] Class of 1999\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Daleks' Invasion Earth: 2150 A.D.\r\n--\r\n\r\n\r\n	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
94	20	1	regex-matching-line-boundaries	Regex - Matching Line Boundaries	5	Just like words have boundaris that we can match with `\\b`, lines also have boundaries that we can match with `^` (start of line) and `$` (end of line).\r\n\r\nLet's say we want to match movie names that start with a year. So, we should match `2001: A Space Odyssey` but not `Dracula A.D. 1972`. We could use the pattern `^\\d{4}\\b` to do just that.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"^\\d{4}\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n<_sre.SRE_Match object; span=(0, 4), match='2009'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "44500 Max")\r\n>>> # Not a match\r\n>>>\r\n```\r\n\r\nSimilarly, we can use the pattern `\\b\\d{4}$` to match movie names that end with a year.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\b\\d{4}$"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n<_sre.SRE_Match object; span=(19, 23), match='1940'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n>>> # Not a match\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "Super 23123")\r\n>>> # Not a match\r\n>>> \r\n```\r\n\r\n--mcquiz\r\nWhich of the following would match the regex `^\\d{4}$`:\r\n  [#] 1984\r\n  [#] 1971\r\n  [#] 2081\r\n  [ ] AM1200\r\n  [ ] Class of 1999\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Daleks' Invasion Earth: 2150 A.D.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match movie names that have only a single word:\r\n  [#] Superman\r\n  [#] 1984\r\n  [ ] Spiderman Returns\r\n  [ ] 2001: A Space Odyssey\r\n  [#] AM1200\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match movie names that do not have any whitespace character (Hint: `\\S`).\r\n  [#] Superman\r\n  [#] I.Q.\r\n  [ ] Spiderman Returns\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com/tags/children\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n  [#] http://localhost:8000/test-page.html\r\n--\r\n\r\n	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
95	20	1	regex-matching-line-boundaries	Regex - Matching Line Boundaries	6	Just like words have boundaris that we can match with `\\b`, lines also have boundaries that we can match with `^` (start of line) and `$` (end of line).\r\n\r\nLet's say we want to match movie names that start with a year. So, we should match `2001: A Space Odyssey` but not `Dracula A.D. 1972`. We could use the pattern `^\\d{4}\\b` to do just that.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"^\\d{4}\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n<_sre.SRE_Match object; span=(0, 4), match='2009'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "44500 Max")\r\n>>> # Not a match\r\n>>>\r\n```\r\n\r\nSimilarly, we can use the pattern `\\b\\d{4}$` to match movie names that end with a year.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\b\\d{4}$"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n<_sre.SRE_Match object; span=(19, 23), match='1940'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n>>> # Not a match\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "Super 23123")\r\n>>> # Not a match\r\n>>> \r\n```\r\n\r\n--mcquiz\r\nWhich of the following would match the regex `^\\d{4}$`:\r\n  [#] 1984\r\n  [#] 1971\r\n  [#] 2081\r\n  [ ] AM1200\r\n  [ ] Class of 1999\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Daleks' Invasion Earth: 2150 A.D.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match movie names that have only a single word:\r\n  [#] Superman\r\n  [#] 1984\r\n  [ ] Spiderman Returns\r\n  [ ] 2001: A Space Odyssey\r\n  [#] AM1200\r\n  [ ] I.Q.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match movie names that do not have any whitespace character (Hint: `\\S`).\r\n  [#] Superman\r\n  [#] I.Q.\r\n  [ ] Spiderman Returns\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com/tags/children\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n  [#] http://localhost:8000/test-page.html\r\n--\r\n\r\n	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
96	20	1	regex-matching-line-boundaries	Regex - Matching Line Boundaries	7	Just like words have boundaris that we can match with `\\b`, lines also have boundaries that we can match with `^` (start of line) and `$` (end of line).\r\n\r\nLet's say we want to match movie names that start with a year. So, we should match `2001: A Space Odyssey` but not `Dracula A.D. 1972`. We could use the pattern `^\\d{4}\\b` to do just that.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"^\\d{4}\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n<_sre.SRE_Match object; span=(0, 4), match='2009'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "44500 Max")\r\n>>> # Not a match\r\n>>>\r\n```\r\n\r\nSimilarly, we can use the pattern `\\b\\d{4}$` to match movie names that end with a year.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\b\\d{4}$"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n<_sre.SRE_Match object; span=(19, 23), match='1940'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n>>> # Not a match\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "Super 23123")\r\n>>> # Not a match\r\n>>> \r\n```\r\n\r\n--mcquiz\r\nWhich of the following would match the regex `^\\d{4}$`:\r\n  [#] 1984\r\n  [#] 1971\r\n  [#] 2081\r\n  [ ] AM1200\r\n  [ ] Class of 1999\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Daleks' Invasion Earth: 2150 A.D.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match movie names that have only a single word:\r\n  [#] Superman\r\n  [#] 1984\r\n  [ ] Spiderman Returns\r\n  [ ] 2001: A Space Odyssey\r\n  [#] AM1200\r\n  [ ] I.Q.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match movie names that do not have any whitespace character (Hint: `\\S`).\r\n  [#] Superman\r\n  [#] I.Q.\r\n  [ ] Spiderman Returns\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] http://www.yahoo.com\r\n  [#] http://www.wattpad.com\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://www.wattpad.com\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com/tags/children\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com/tags/children\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n  [#] http://localhost:8000/test-page.html\r\n--\r\n\r\n	2017-07-06 02:12:44.264452	2017-07-06 02:12:44.264498
97	21	1	regex-beyond-match	Regex - Beyond Match	1	So far, our focus was to become proficient at writing regex patterns. We'll learn a few more things about writing patterns but before that, let's take a break and focus on what you can do *after* you have found a match.	2017-07-08 01:50:57.987049	2017-07-08 01:50:57.987084
108	22	1	regex-extract-content	Regex - Extract Content	11	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, but also which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\nYou should refer to the documentation of [Match Object](file:///Users/mangarg/Downloads/python-3.6.2rc1-docs-html/library/re.html#match-objects) on Python documentation.\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that use an Adverb (words that end with ly). For example: strictly, deadly, objectively etc.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Strictly Ballroom` should give you `Strictly`.\r\n* `Tough and Deadly` should give you `Deadly`.\r\n* `Heavenly Creatures` should give you `Heavenly`.\r\n* `Superman` should not be a match.\r\n--\r\n\r\n\r\n	2017-07-08 13:27:04.045468	2017-07-08 13:27:04.045547
98	22	1	regex-extract-content	Regex - Extract Content	1	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, you also want to find out which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to matches movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n\r\n\r\n	2017-07-08 01:50:57.987049	2017-07-08 01:50:57.987084
99	22	1	regex-extract-content	Regex - Extract Content	2	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, you also want to find out which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to matches movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n\r\n\r\n	2017-07-08 01:50:57.987049	2017-07-08 01:50:57.987084
100	22	1	regex-extract-content	Regex - Extract Content	3	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, you also want to find out which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to matches movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n\r\n\r\n	2017-07-08 13:17:12.492035	2017-07-08 13:17:12.492064
101	22	1	regex-extract-content	Regex - Extract Content	4	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, you also want to find out which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to matches movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n\r\n\r\n	2017-07-08 13:17:12.492035	2017-07-08 13:17:12.492064
102	22	1	regex-extract-content	Regex - Extract Content	5	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, you also want to find out which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to matches movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n\r\n\r\n	2017-07-08 13:21:33.655978	2017-07-08 13:21:33.656017
103	22	1	regex-extract-content	Regex - Extract Content	6	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, you also want to find out which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to matches movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n\r\n\r\n	2017-07-08 13:22:29.821739	2017-07-08 13:22:29.821773
104	22	1	regex-extract-content	Regex - Extract Content	7	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, you also want to find out which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to matches movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n\r\n\r\n	2017-07-08 13:24:10.506321	2017-07-08 13:24:10.506349
105	22	1	regex-extract-content	Regex - Extract Content	8	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, you also want to find out which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to matches movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n\r\n\r\n	2017-07-08 13:24:58.836075	2017-07-08 13:24:58.836108
106	22	1	regex-extract-content	Regex - Extract Content	9	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, you also want to find out which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\nYou should refer to the documentation of [Match Object](file:///Users/mangarg/Downloads/python-3.6.2rc1-docs-html/library/re.html#match-objects) on Python documentation.\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n\r\n\r\n	2017-07-08 13:24:58.836075	2017-07-08 13:24:58.836108
107	22	1	regex-extract-content	Regex - Extract Content	10	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, you also want to find out which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\nYou should refer to the documentation of [Match Object](file:///Users/mangarg/Downloads/python-3.6.2rc1-docs-html/library/re.html#match-objects) on Python documentation.\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that use an Adverb (words that end with ly). For example: strictly, deadly, objectively etc.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Strictly Ballroom` should give you `Strictly`.\r\n* `Tough and Deadly` should give you `Deadly`.\r\n* `Heavenly Creatures` should give you `Heavenly`.\r\n* `Superman` should not be a match.\r\n--\r\n\r\n\r\n	2017-07-08 13:27:04.045468	2017-07-08 13:27:04.045547
109	22	1	regex-extract-content	Regex - Extract Content	12	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, but also which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\nYou should refer to the documentation of [Match Object](file:///Users/mangarg/Downloads/python-3.6.2rc1-docs-html/library/re.html#match-objects) on Python documentation.\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that use an Adverb (words that end with ly). For example: strictly, deadly, objectively etc.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Strictly Ballroom` should give you `Strictly`.\r\n* `Tough and Deadly` should give you `Deadly`.\r\n* `Heavenly Creatures` should give you `Heavenly`.\r\n* `Superman` should not be a match.\r\n--\r\n\r\n\r\n	2017-07-08 13:38:19.618926	2017-07-08 13:38:19.619008
110	22	1	regex-extract-content	Regex - Extract Content	13	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, but also which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\nYou should refer to the documentation of [Match Object](file:///Users/mangarg/Downloads/python-3.6.2rc1-docs-html/library/re.html#match-objects) on Python documentation.\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that use an Adverb (words that end with ly). For example: strictly, deadly, objectively etc.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Strictly Ballroom` should give you `Strictly`.\r\n* `Tough and Deadly` should give you `Deadly`.\r\n* `Heavenly Creatures` should give you `Heavenly`.\r\n* `Superman` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module.\r\n* Define a regex to match sentences that have an email address (user@domain.com). For simplicity, assume that `user` and `domain` can have only the word characters and `-`.\r\n* Extract the matching email address from the Match Object returned `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `smith@yahoo.com - Steve Smith` should give you `smith@yahoo.com`.\r\n* `hi@turtleprogrammer.com - Someone Out There` should give you `hi@turtleprogrammer.com`.\r\n* `rama@gmail.com` should give you `rama@gmail.com`.\r\n* `rama @gmail.com` should not be a match.\r\n--\r\n\r\n	2017-07-08 13:38:19.618926	2017-07-08 13:38:19.619008
111	23	1	regex-extract-content-full-match	Regex - Extract Content Full Match	1	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, but also which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\nYou should refer to the documentation of [Match Object](file:///Users/mangarg/Downloads/python-3.6.2rc1-docs-html/library/re.html#match-objects) on Python documentation.\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that use an Adverb (words that end with ly). For example: strictly, deadly, objectively etc.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Strictly Ballroom` should give you `Strictly`.\r\n* `Tough and Deadly` should give you `Deadly`.\r\n* `Heavenly Creatures` should give you `Heavenly`.\r\n* `Superman` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module.\r\n* Define a regex to match sentences that have an email address (user@domain.com). For simplicity, assume that `user` and `domain` can have only the word characters and `-`.\r\n* Extract the matching email address from the Match Object returned `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `smith@yahoo.com - Steve Smith` should give you `smith@yahoo.com`.\r\n* `hi@turtleprogrammer.com - Someone Out There` should give you `hi@turtleprogrammer.com`.\r\n* `rama@gmail.com` should give you `rama@gmail.com`.\r\n* `rama @gmail.com` should not be a match.\r\n--\r\n\r\n	2017-07-08 14:23:19.28714	2017-07-08 14:23:19.287167
112	24	1	regex-extract-content-nested-match	Regex - Extract Content Nested Match	1	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r" \\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n' Kripal'\r\n```\r\n\r\nThis is not very efficient as we have to create two separate regex. We can 	2017-07-08 14:23:19.28714	2017-07-08 14:23:19.287167
113	24	1	regex-extract-content-nested-match	Regex - Extract Content Nested Match	2	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r" \\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n' Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group()\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n	2017-07-08 14:23:19.28714	2017-07-08 14:23:19.287167
118	24	1	regex-extract-content-nested-match	Regex - Extract Content (Nested Match)	7	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r"\\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n'Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person without middle name\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person with middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and match groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and match groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `<proto>://<host>.<site>.com`. Using regex (and match groups), you need to extract the proto, host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `http`, `www` and `google`.\r\n* `https://en.wikipedia.org` should give you `https`, `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `http`, `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of ingredients and quantity for a recipe. It's in the format `<ingredient>: <quantity> <metric>`. Using regex (and match groups), you need to extract the ingredient, quantity and metric. Metric is optional.\r\n\r\nHere is how you can test it:\r\n\r\n* `Onion: 2` should give you `Onion` and `2`.\r\n* `Olive Oil: 1 tbsp` should give you `Olive Oil`, `1` and `tbsp`.\r\n* `Salt  :   1    tbsp` should give you `Salt`, `1` and `tbsp`.\r\n* `Water:`, `Pepper: tbsp` should not match.\r\n--\r\n\r\n	2017-07-08 14:23:19.28714	2017-07-08 14:23:19.287167
114	24	1	regex-extract-content-nested-match	Regex - Extract Content Nested Match	3	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r" \\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n' Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person without middle name\r\n>>> name_match = re.search(r"(\\w+) \\b(\\w*)\\b\\s*(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person with middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) \\b(\\w*)\\b\\s*(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n	2017-07-08 14:23:19.28714	2017-07-08 14:23:19.287167
115	24	1	regex-extract-content-nested-match	Regex - Extract Content Nested Match	4	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r" \\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n' Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person without middle name\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s*(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person with middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s*(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n	2017-07-08 14:23:19.28714	2017-07-08 14:23:19.287167
116	24	1	regex-extract-content-nested-match	Regex - Extract Content Nested Match	5	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r" \\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n' Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person without middle name\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person with middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and match groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and match groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `<proto>://<host>.<site>.com`. Using regex (and match groups), you need to extract the proto, host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `http`, `www` and `google`.\r\n* `https://en.wikipedia.org` should give you `https`, `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `http`, `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of ingredients and quantity for a recipe. It's in the format `<ingredient>: <quantity> <metric>`. Using regex (and match groups), you need to extract the ingredient, quantity and metric. Metric is optional.\r\n\r\nHere is how you can test it:\r\n\r\n* `Onion: 2` should give you `Onion` and `2`.\r\n* `Olive Oil: 1 tbsp` should give you `Olive Oil`, `1` and `tbsp`.\r\n* `Salt  :   1    tbsp` should give you `Salt`, `1` and `tbsp`.\r\n* `Water:`, `Pepper: tbsp` should not match.\r\n--\r\n\r\n	2017-07-08 14:23:19.28714	2017-07-08 14:23:19.287167
117	24	1	regex-extract-content-nested-match	Regex - Extract Content (Nested Match)	6	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r" \\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n' Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person without middle name\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person with middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and match groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and match groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `<proto>://<host>.<site>.com`. Using regex (and match groups), you need to extract the proto, host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `http`, `www` and `google`.\r\n* `https://en.wikipedia.org` should give you `https`, `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `http`, `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of ingredients and quantity for a recipe. It's in the format `<ingredient>: <quantity> <metric>`. Using regex (and match groups), you need to extract the ingredient, quantity and metric. Metric is optional.\r\n\r\nHere is how you can test it:\r\n\r\n* `Onion: 2` should give you `Onion` and `2`.\r\n* `Olive Oil: 1 tbsp` should give you `Olive Oil`, `1` and `tbsp`.\r\n* `Salt  :   1    tbsp` should give you `Salt`, `1` and `tbsp`.\r\n* `Water:`, `Pepper: tbsp` should not match.\r\n--\r\n\r\n	2017-07-08 14:23:19.28714	2017-07-08 14:23:19.287167
119	24	1	regex-extract-content-nested-match	Regex - Extract Content (Nested Match)	8	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r"\\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n'Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person with middle name\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person without middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and match groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and match groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `<proto>://<host>.<site>.com`. Using regex (and match groups), you need to extract the proto, host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `http`, `www` and `google`.\r\n* `https://en.wikipedia.org` should give you `https`, `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `http`, `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of ingredients and quantity for a recipe. It's in the format `<ingredient>: <quantity> <metric>`. Using regex (and match groups), you need to extract the ingredient, quantity and metric. Metric is optional.\r\n\r\nHere is how you can test it:\r\n\r\n* `Onion: 2` should give you `Onion` and `2`.\r\n* `Olive Oil: 1 tbsp` should give you `Olive Oil`, `1` and `tbsp`.\r\n* `Salt  :   1    tbsp` should give you `Salt`, `1` and `tbsp`.\r\n* `Water:`, `Pepper: tbsp` should not match.\r\n--\r\n\r\n	2017-07-08 14:23:19.28714	2017-07-08 14:23:19.287167
120	25	1	regex-extract-content-nested-groups	regex-extract-content-nested-groups	1	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r"\\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n'Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person with middle name\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person without middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and match groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and match groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `<proto>://<host>.<site>.com`. Using regex (and match groups), you need to extract the proto, host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `http`, `www` and `google`.\r\n* `https://en.wikipedia.org` should give you `https`, `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `http`, `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of ingredients and quantity for a recipe. It's in the format `<ingredient>: <quantity> <metric>`. Using regex (and match groups), you need to extract the ingredient, quantity and metric. Metric is optional.\r\n\r\nHere is how you can test it:\r\n\r\n* `Onion: 2` should give you `Onion` and `2`.\r\n* `Olive Oil: 1 tbsp` should give you `Olive Oil`, `1` and `tbsp`.\r\n* `Salt  :   1    tbsp` should give you `Salt`, `1` and `tbsp`.\r\n* `Water:`, `Pepper: tbsp` should not match.\r\n--\r\n\r\n	2017-07-08 21:01:24.414139	2017-07-08 21:01:24.41417
121	25	1	regex-extract-content-nested-groups	Regex - Extract Content (Nested Groups)	2	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r"\\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n'Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person with middle name\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person without middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and match groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and match groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `<proto>://<host>.<site>.com`. Using regex (and match groups), you need to extract the proto, host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `http`, `www` and `google`.\r\n* `https://en.wikipedia.org` should give you `https`, `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `http`, `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of ingredients and quantity for a recipe. It's in the format `<ingredient>: <quantity> <metric>`. Using regex (and match groups), you need to extract the ingredient, quantity and metric. Metric is optional.\r\n\r\nHere is how you can test it:\r\n\r\n* `Onion: 2` should give you `Onion` and `2`.\r\n* `Olive Oil: 1 tbsp` should give you `Olive Oil`, `1` and `tbsp`.\r\n* `Salt  :   1    tbsp` should give you `Salt`, `1` and `tbsp`.\r\n* `Water:`, `Pepper: tbsp` should not match.\r\n--\r\n\r\n	2017-07-08 21:01:24.414139	2017-07-08 21:01:24.41417
122	26	1	regex-extract-content-named-groups	Regex - Extract Content (Named Groups)	1	While it's possible (and easy) to use numbered groups to extract content, it can get unwiedly in complex regex when there are too many nested groups. It's much cleaner to be able to name the groups for which we want to extract the content.\r\n\r\nLet's rework the problem of extracting first name and last name from a name. This is what we did earlier:\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nWe can instead use the expression `(?P<group_name>...)` syntax:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(?P<first_name>\\w+) (?P<last_name>\\w+)", "Ram Kripal")\r\n>>> name_match.group('first_name')\r\n'Ram'\r\n>>> name_match.group('last_name')\r\n'Kripal'\r\n```\r\n\r\nIf you notice, we rewrote `(\\w+)` as `(?P<first_name>\\w+)` which can be broken down as `(` (start of the group), `?P<first_name>` (name of the group), `\\w+` (pattern), `)` (end of the group).\r\n\r\n\r\n\r\n\r\n	2017-07-08 21:02:17.71986	2017-07-08 21:02:17.719891
123	26	1	regex-extract-content-named-groups	Regex - Extract Content (Named Groups)	2	While it's possible (and easy) to use numbered groups to extract content, it can get unwiedly in complex regex when there are too many nested groups. It's much cleaner to be able to name the groups for which we want to extract the content.\r\n\r\nLet's rework the problem of extracting first name and last name from a name. This is what we did earlier:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nWe can instead use the expression `(?P<group_name>...)` syntax:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(?P<first_name>\\w+) (?P<last_name>\\w+)", "Ram Kripal")\r\n>>> name_match.group('first_name')\r\n'Ram'\r\n>>> name_match.group('last_name')\r\n'Kripal'\r\n```\r\n\r\nIf you notice, we rewrote `(\\w+)` as `(?P<first_name>\\w+)` which can be broken down as `(` (start of the group), `?P<first_name>` (name of the group), `\\w+` (pattern), `)` (end of the group).\r\n\r\n\r\n\r\n\r\n	2017-07-08 21:02:17.71986	2017-07-08 21:02:17.719891
124	26	1	regex-extract-content-named-groups	Regex - Extract Content (Named Groups)	3	While it's possible (and easy) to use numbered groups to extract content, it can get unwiedly in complex regex when there are too many nested groups. It's much cleaner to be able to name the groups for which we want to extract the content.\r\n\r\nLet's rework the problem of extracting first name and last name from a name. This is what we did earlier:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nWe can instead use the expression `(?P<group_name>...)` syntax:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(?P<first_name>\\w+) (?P<last_name>\\w+)", "Ram Kripal")\r\n>>> name_match.group('first_name')\r\n'Ram'\r\n>>> name_match.group('last_name')\r\n'Kripal'\r\n```\r\n\r\nIf you notice, we rewrote `(\\w+)` as `(?P<first_name>\\w+)` which can be broken down as `(` (start of the group), `?P<first_name>` (name of the group), `\\w+` (pattern), `)` (end of the group).\r\n\r\n\r\n\r\n\r\n	2017-07-08 21:02:17.71986	2017-07-08 21:02:17.719891
125	26	1	regex-extract-content-named-groups	Regex - Extract Content (Named Groups)	4	While it's possible (and easy) to use numbered groups to extract content, it can get unwiedly in complex regex when there are too many nested groups. It's much cleaner to be able to name the groups for which we want to extract the content.\r\n\r\nLet's rework the problem of extracting first name and last name from a name. This is what we did earlier:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nWe can instead use the `(?P<group_name>...)` syntax:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(?P<first_name>\\w+) (?P<last_name>\\w+)", "Ram Kripal")\r\n>>> name_match.group('first_name')\r\n'Ram'\r\n>>> name_match.group('last_name')\r\n'Kripal'\r\n```\r\n\r\nIf you notice, we rewrote `(\\w+)` as `(?P<first_name>\\w+)` which can be broken down as `(` (start of the group), `?P<first_name>` (name of the group), `\\w+` (pattern), `)` (end of the group).\r\n\r\n\r\n\r\n\r\n	2017-07-08 21:02:17.71986	2017-07-08 21:02:17.719891
126	26	1	regex-extract-content-named-groups	Regex - Extract Content (Named Groups)	5	While it's possible (and easy) to use numbered groups to extract content, it can get unwiedly in complex regex when there are too many nested groups. It's much cleaner to be able to name the groups for which we want to extract the content.\r\n\r\nLet's rework the problem of extracting first name and last name from a name. This is what we did earlier:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nWe can instead use the `(?P<group_name>...)` syntax:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(?P<first_name>\\w+) (?P<last_name>\\w+)", "Ram Kripal")\r\n>>> name_match.group('first_name')\r\n'Ram'\r\n>>> name_match.group('last_name')\r\n'Kripal'\r\n```\r\n\r\nIf you notice, we rewrote `(\\w+)` as `(?P<first_name>\\w+)` which can be broken down as:\r\n\r\n* `(` - start of the group.\r\n* `?P` - declaration that we'll give a name to the group.\r\n* `<first_name>` - name of the group.\r\n* `\\w+` - pattern. \r\n* `)` - end of the group\r\n\r\n\r\n\r\n\r\n	2017-07-08 21:02:17.71986	2017-07-08 21:02:17.719891
127	26	1	regex-extract-content-named-groups	Regex - Extract Content (Named Groups)	6	While it's possible (and easy) to use numbered groups to extract content, it can get unwiedly in complex regex when there are too many nested groups. It's much cleaner to be able to name the groups for which we want to extract the content.\r\n\r\nLet's rework the problem of extracting first name and last name from a name. This is what we did earlier:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nWe can instead use the `(?P<group_name>...)` syntax:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(?P<first_name>\\w+) (?P<last_name>\\w+)", "Ram Kripal")\r\n>>> name_match.group('first_name')\r\n'Ram'\r\n>>> name_match.group('last_name')\r\n'Kripal'\r\n```\r\n\r\nIf you notice, we rewrote `(\\w+)` as `(?P<first_name>\\w+)` which can be broken down as:\r\n\r\n* `(` - start of the group.\r\n* `?P` - declaration that we'll give a name to the group.\r\n* `<first_name>` - name of the group.\r\n* `\\w+` - pattern. \r\n* `)` - end of the group\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nFrom the [previous section](/topic/regex-extract-content-nested-groups), modify the regex to extract first, middle and last names to use named groups. The group names should be first_name, middle_name, last_name.\r\n\r\n\r\n--\r\n\r\n\r\n	2017-07-08 21:02:17.71986	2017-07-08 21:02:17.719891
128	26	1	regex-extract-content-named-groups	Regex - Extract Content (Named Groups)	7	While it's possible (and easy) to use numbered groups to extract content, it can get unwiedly in complex regex when there are too many nested groups. It's much cleaner to be able to name the groups for which we want to extract the content.\r\n\r\nLet's rework the problem of extracting first name and last name from a name. This is what we did earlier:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nWe can instead use the `(?P<group_name>...)` syntax:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(?P<first_name>\\w+) (?P<last_name>\\w+)", "Ram Kripal")\r\n>>> name_match.group('first_name')\r\n'Ram'\r\n>>> name_match.group('last_name')\r\n'Kripal'\r\n```\r\n\r\nIf you notice, we rewrote `(\\w+)` as `(?P<first_name>\\w+)` which can be broken down as:\r\n\r\n* `(` - start of the group.\r\n* `?P` - declaration that we'll give a name to the group.\r\n* `<first_name>` - name of the group.\r\n* `\\w+` - pattern. \r\n* `)` - end of the group\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nFrom the [previous section](/topic/regex-extract-content-nested-groups), modify the regex to extract first, middle and last names to use named groups. The group names should be first_name, middle_name and last_name.\r\n\r\nHere is how you can test it:\r\n\r\n* `George Bernard Shaw` should give you `George`, `Bernard`, `Shaw`.\r\n* `Ram Prakash Kripal` should give you `Ram`, `Prakash`, `Kripal`.\r\n* `John Smith` should give you `John`, blank middle name, `Smith`.\r\n* `Lee` and `Raja Shekhar Chandra Reddy` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and named groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and named groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n\r\n	2017-07-08 21:02:17.71986	2017-07-08 21:02:17.719891
129	27	1	regex-split-substitute-findall-content	Regex - Split/Substitute/FindAll	1	We'll run through a few more methods in the `re` module.\r\n\r\n## re.split()\r\n\r\nThe `re.split()` method splits a strings based on a regex. Example:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.split(r"\\W+", "apple banana mango pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana, mango, pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana , mango   , pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n```\r\n\r\nWhile you can use the string's `split()` method, the regex one just becomes more powerful since it can handle so many variations of the separator.\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nUse the `re.split()` mmethod to split a string that has list of ingredients and their quantity for a recipe. The format is `ingredient: quantity`.\r\n\r\nHere is what you can use for testing:\r\n\r\n* `Onion: 2` should give you `['Onion', '2']`.\r\n* `Onion  :   2` should give you `['Onion', '2']`.\r\n* `Onion:2` should give you `['Onion', '2']`.\r\n* `Onion: `, `:2` and `Onion` should not match.\r\n--\r\n\r\n\r\n\r\n\r\n	2017-07-08 21:51:31.170858	2017-07-08 21:51:31.170908
130	28	1	regex-split-findall-content	Regex - Split/FindAll	1	We'll run through a few more methods in the `re` module.\r\n\r\n## re.split()\r\n\r\nThe `re.split()` method splits a strings based on a regex. Example:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.split(r"\\W+", "apple banana mango pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana, mango, pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana , mango   , pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n```\r\n\r\nWhile you can use the string's `split()` method, the regex one just becomes more powerful since it can handle so many variations of the separator.\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nUse the `re.split()` mmethod to split a string that has list of ingredients and their quantity for a recipe. The format is `ingredient: quantity`.\r\n\r\nHere is what you can use for testing:\r\n\r\n* `Onion: 2` should give you `['Onion', '2']`.\r\n* `Onion  :   2` should give you `['Onion', '2']`.\r\n* `Onion:2` should give you `['Onion', '2']`.\r\n* `Onion: `, `:2` and `Onion` should not match.\r\n--\r\n\r\n## re.findall()\r\n\r\nThe method `re.findall()` is useful when you are trying to find multiple occurrences of a pattern within text. For example, if we want to find all years mentioned in a given text, `findall()` would be pretty helpful. Example:\r\n\r\n```Python\r\n>>> text = "The growth was more in 2001 compred to 2002."\r\n>>> re.findall(r"\\d+", text)\r\n['2001', '2002']\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nUse the `re.findall()` method to find all five letter words in given text. Here is how you can test your code:\r\n\r\n* `There was less death in 2004.` should give you `['There', 'death']`.\r\n* `This is superb.` should give you nothing.\r\n--\r\n\r\n	2017-07-08 22:04:22.348762	2017-07-08 22:04:22.348796
131	7	1	regex-matching-literals	Regex - Matching Literals	8	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-07-08 22:04:22.348762	2017-07-08 22:04:22.348796
132	7	1	regex-matching-literals	Regex - Matching Literals	9	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
133	9	1	regex-matching-special-characters	Regex - Matching Special Characters	2	Some characters have special meaning in regex (e.g. `.`, `?`, `(`, `)`, `*`, `+`, `^`, `$`, `\\`, `[`, `]`) . We'll look at their use later in the game. For now, suffice it to say that if you want to match any of these, you have to precede them with `\\` to find a match. For example, if you want to match movie names that have a full stop, you have to use `\\.` as regex pattern and not `.`.\r\n\r\nLet's solve the problem of matching movie names that have a full stop. Here is the wrong pattern:\r\n\r\n```Python\r\n>>> import re\r\n>>> INCORRECT_REGEX_PATTERN = r'.'\r\n>>> \r\n>>> re.search(INCORRECT_REGEX_PATTERN, 'Mr. Average')\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(INCORRECT_REGEX_PATTERN, 'Stardust')\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> # should not have matched Stardust but it did.\r\n```\r\n\r\nHere is the same exercise with the right regex pattern:\r\n\r\n```Python\r\n>>> import re\r\n>>> CORRECT_REGEX_PATTERN = r'\\.'\r\n>>> \r\n>>> re.search(CORRECT_REGEX_PATTERN, 'Mr. Average')\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(CORRECT_REGEX_PATTERN, 'Stardust')\r\n>>> # did not match Stardust\r\n```\r\n\r\n--regexquiz:ffb4f681-4808-439c-bb43-23727c19e013\r\nWrite the regex pattern that matches movies with `.` in their name:\r\n  [#] Mr. Pip\r\n  [#] The D.I.\r\n  [ ] Stardust\r\n  [ ] Superman\r\n--\r\n\r\n\r\n\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
134	8	1	regex-matching-this-or-that	Regex - Matching This or That	11	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we could define the pattern as `Star Wars:|Star Trek:`. This pattern would match either `Star Wars:` or `Star Trek:`. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\nThe regex `Star Wars:|Star Trek:` has multiple duplicate elements. We can make it more concise with `Star (Wars|Trek):`. It means look for `Star`, followed by a space followed by either `Wars` or `Trek`, followed by a `:`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star (Wars|Trek):"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n--mcquiz:2b151f26-94fd-4932-bab8-349427ce848d\r\nHere are some movie names. Which of these would match the regex `Force|Jedi`:\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Discovery\r\n  [ ] Star Trek: Voyager\r\n--\r\n\r\n--regexquiz:4007c758-69cf-46a6-928e-4b7cd55bf4fd\r\nWhat's the regex to select movies from Star Wars as well as Star Trek franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [#] Star Trek: Discovery\r\n  [#] Star Trek: Voyager\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n--\r\n\r\n--mcquiz:fa5b08c2-b54d-4547-9a6d-eb4ff46f2b4c\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [#] `Superman|Supergirl`\r\n  [#] `Super(man|girl)`\r\n  [ ] `Super(m|g)(a|i)(n|r)l`\r\n  [#] `Super(m|g)(a|i)(n|rl)`\r\n  [#] `Super((man|girl))`\r\n  [#] `Super((man)|girl)`\r\n--\r\n\r\n--mcquiz:a16209cb-a012-4ce5-8f0a-d30ffbaa3a5c\r\nWhich of the following movies will be matched by regex `(Star (Wars|Trek):)|(Super(man|girl))`\r\n  [#] Star Wars: The Last Jedi\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n  [#] Star Trek: Voyager\r\n  [#] Superman Returns\r\n  [#] Supergirl\r\n--\r\n\r\n--regexquiz:9cb8a852-cfbd-491b-af75-47edc4c229a9\r\nWrite a regex that would match all the Star Wars, Star Trek and Space related movies.\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n  [#] Star Trek: Voyager\r\n  [ ] Superman\r\n  [#] Alien Space Avenger\r\n--\r\n\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
135	10	1	regex-matching-one-of-many-characters	Regex - Matching One of Many Characters	7	An interesting problem to solve is to match movies that mention a year in their name. Sample movie names are: `2001: A Space Odyssey`, `Dream Team 1935`, `Class of 1999` etc. To keep it simple for now, a year is four digits out of which first digit could be 1 or 2 and rest of the digits could go from 0 to 9. From what we have learnt so far, we could define a pattern like this for our purpose.\r\n\r\n```Python\r\nREGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n```\r\n\r\nLet's put it to use and see it working.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nThe pattern works but it's quite cumbersome. Regex provides another expression that we can use here. `(0|1|2|3|4|5|6|7|8|9)` could be written as `[0123456789]`. When you put multiple characters in `[]`, regex would look for matching one of these.\r\n\r\nWe can now rewrite the previous expression as:\r\n\r\n```Python\r\nREGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n```\r\n\r\nLet's try out the new pattern.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nIn fact, such needs are so common that there is a further shortcut to matching digits 0-9: `[0-9]`. So, we can once again re-write the expression as `[12][0-9][0-9][0-9]`. Here is how we use it:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0-9][0-9][0-9]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nNice. Isn't it?\r\n\r\n--regexquiz:4eb7e560-d86d-4eee-9f3f-3be7a381617f\r\nTry different regex variations that we discussed just now to select movie names that have a year in their name.\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] 1984\r\n  [ ] Gone With The Wind\r\n  [ ] Star Wars: The Last Jedi\r\n--\r\n\r\n## Ranges and Alphabets\r\n\r\nRanges work not only for digits but also for alphabets. So, you could say `r"[A-Z]"` to match any upper case letter, `r"[a-z]"` to match any lower case letter, `r"[A-Za-z]"` to match all English alphabet letters, `r"[A-Za-z0-9]"` to match any alphanumeric characters. In fact, you can also say `r"[AM-PZ]"` and it would match letters A, M, N, O, P, Z.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> re.search(r"[A-Z]", "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(6, 7), match='A'>\r\n>>> \r\n>>> re.search(r"[A-Z]", "1984")\r\n>>>\r\n```\r\n\r\nHere, we are looking for a movie name with an uppercase letter. The movie `2001: A Space Odyssey` is a match, whereas, the movie `1984` is not a match.\r\n\r\n--mcquiz:3de214bf-d472-4dfd-a05e-3552496a9394\r\nHere are some movie names. Which ones would match the regex `r"[0-9][0-9][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz:50b56794-b819-4fc9-b5ab-8f7db62f3236\r\nHere are some movie names. Which ones would match the regex `r"[0-29][0-5][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz:f021d060-5ae6-4042-b6a0-87172f94be87\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [ ] `r"Super[mg][ai][nrl]"`\r\n  [#] `r"Super[mg][ai][nr]l"`\r\n  [#] `r"Super[mg][ai](n|rl)"`\r\n  [ ] `r"Super[mangirl]"`\r\n--\r\n\r\n--regexquiz:c562b1db-5dd5-49dc-b821-b25dc821dcde\r\nHere is a list of movie names. Select the ones that have at least one 4 letter word in the middle of movie name.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz:7ab96916-ae7b-43ba-a620-a07d017db875\r\nHere is a list of movie names. Select the ones that use a number within a word.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz:7f8920cf-32e5-41d4-ba2a-01766a2b8c07\r\nHere is a list of movie names. Select the ones that have a bat, cat or rat in the name. Use the shortest possible regex.\r\n  [#] Bat Whispers\r\n  [#] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n## Matching absence of characters\r\n\r\nJust like you can match for presence of certain characters, you can also match for their absence. `[^A-Z]` will match all characters except uppercase letters. `[^BCR]at` will match `Sat` but it will not match `Bat`, `Cat` and `Rat`. Simple trick here is to use `^`. `[BCR]` means match B, C or R but `[^BCR]` means match anything other than B, C or R.\r\n\r\n--mcquiz:4148011c-203d-4568-90d8-d868f0bbc517\r\nWhich of the following match regex `[0-1][0-9]:[0-6][0-9] [^P]M`:\r\n  [#] 04:00 AM\r\n  [#] 11:59 AM\r\n  [ ] 06:00 PM\r\n  [ ] 09:23 PM\r\n--\r\n\r\n--mcquiz:3233168c-7e35-471a-9f82-0bf10d884931\r\nHere are some movie names. Which ones would match the regex `[^3-9][0-5][0-9][0-9]:`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [ ] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
136	11	1	regex-matching-types-of-characters	Regex - Matching Types of Characters	6	Let's revisit the problem of identifying movies that have a year in their name. We looked at set of characters (i.e. `[0-9]`) as a solution. Some of these sets are so commonly used that there are special symbols for them. These symbols are:\r\n\r\n* `\\w` is equivalent to `[A-Za-z0-9_]`\r\n* `\\W` is opposite of `\\w` i.e. `[^A-Za-z0-9_]`\r\n* `\\s` is equivalent to `[ \\t\\r\\n]`\r\n* `\\S` is opposite of `\\s` i.e. `[^ \\t\\r\\n]`\r\n* `\\d` is equivalent to `[0-9]`\r\n* `\\D` is opposite of `\\d` i.e. `[^0-9]`\r\n* `.` is the most interesting shortcut and it matches all characters without exception.\r\n\r\nSo, we had earlier used regex `[12][0-9][0-9][0-9]` to find movies with a year in their name. This regex could also be written as `[12]\\d\\d\\d`. In this, `\\d` stands for a digit. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12]\\d\\d\\d"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nSimilarly, let's say if we want to find out if a movie name has at least 1 word that is five letters long (or even longer). Instead of writing `[A-Za-z][A-Za-z][A-Za-z][A-Za-z][A-Za-z]`, we could write `\\w\\w\\w\\w\\w`. The `\\w` based regex is more concise and readable. Here it is in action:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\w\\w\\w\\w\\w"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1995")\r\n<_sre.SRE_Match object; span=(0, 5), match='Dream'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 5), match='Super'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Cat And Dog")\r\n>>> \r\n```\r\n\r\n\r\nWhat if we want to find out movies whose name is at least 6 letter long? The regex `......` will do the trick for us:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"......"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 6), match='Superm'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1984")\r\n>>> \r\n```\r\n\r\nExpression `r"\\w\\w\\w\\w\\s\\w\\w\\w\\w"` would match a movie name that has at least two words and both the words have at least 4 letters.\r\n\r\n```Python\r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Gone With The Wind")\r\n<_sre.SRE_Match object; span=(0, 9), match='Gone With'>\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "The Ghosts")\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Cat And Dog")\r\n>>>\r\n```\r\n\r\n--regexquiz:2b4d6694-3281-4d0a-b663-a9f089f7a081\r\nWrite a regex that matches movies with at least 8 characters in their name.\r\n  [ ] Se7en\r\n  [ ] Thr3e\r\n  [ ] E=mc2\r\n  [#] 2001: A Space Odyssey\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz:a1c91f6f-0aa9-48b2-9f36-fb20beba582b\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz:cd83f62d-4944-4a63-af26-98da4fbd50b9\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n--regexquiz:bccd002e-ecfa-4006-bf3f-3d404c607381\r\nFind movies which have a number surrounded by one letters on each side.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz:08dbdec3-eb4a-492f-9548-ff7e5c1e7b5b\r\nFind movies which have two consecutive non-word letters. Hint: use `\\W`.\r\n  [#] Star Wars: Return of the Jedi\r\n  [#] Star Trek: Voyager\r\n  [#] Erkan & Stefan 2\r\n  [ ] Cat And Dog\r\n  [ ] Alice in Wonderland\r\n  [ ] Pirates of the Carribean\r\n--\r\n\r\n\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
137	13	1	regex-matching-m-to-n-occurrence	Regex - Matching m To n Occurrences	7	In regex, the general purpose method of matching certain number of occurrences is to use `{m,n}`. `\\d{2,4}` would match at least 2 and at most 4 occurrences of `\\d`.\r\n\r\nEarlier, we wrote the regex `\\d\\d\\d\\d` for matching a year in movie name. The same could be re-written as `\\d{4,4}` which matches at least 4 and at most 4 occurrences of `\\d`. It could be further shortened to `\\d{4}`.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{4}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n<_sre.SRE_Match object; span=(11, 15), match='1992'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Gone With The Wind")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "E=mc2")\r\n>>> \r\n```\r\n\r\n--regexquiz:2e62b6a3-6843-446e-b199-b2cff2277ead\r\nWrite a regex that matches movie names that have at least 12 letters. Use the `{}` syntax.\r\n  [ ] 1984\r\n  [ ] Superman\r\n  [#] Spiderman Returns\r\n  [#] Star Wars: Return of the Jedi\r\n--\r\n\r\nLet's look at a different problem this time. You want to match numbers 0 to 999. How would you do that? `\\d{1,3}` would do the trick.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{1,3}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "8")\r\n<_sre.SRE_Match object; span=(0, 1), match='8'>\r\n>>> # Matches 1 \\d because only 1 is available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "64")\r\n<_sre.SRE_Match object; span=(0, 2), match='64'>\r\n>>> # Matches 2 \\d because only 2 are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "256")\r\n<_sre.SRE_Match object; span=(0, 3), match='256'>\r\n>>> # Matches 3 \\d because all three are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1024")\r\n<_sre.SRE_Match object; span=(0, 3), match='102'>\r\n>>> # Matches 3 \\d and stops looking for more.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "abcdef")\r\n>>> # Not even 1 \\d found. So, not a match.\r\n```\r\n\r\nLet's re-work some of the older problems but this time, make use of `{}` operators to specify number of occurrences.\r\n\r\n--mcquiz:4b2aa2ca-eca9-4721-9a87-fa67219966ad\r\nWhich of the following would match regex `[+-]\\d{1,2}`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz:f8f71c16-f771-4ed5-afeb-43858df03a07\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. Use the `{m,n}` convention to specify occurrences. Hint: `-` has 0 to 1 occurrence while `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [ ] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz:123cc9d9-c4a1-43c4-9394-225b1ab1d76f\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. The positive numbers could be prefixed with +. So, 64 could also be written as +64. Use the `{m,n}` convention to specify occurrences. Hint: in this case, `[+-]` have 0 to 1 occurrence and `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz:cf65ce5a-a047-400f-a31a-a33629f832ab\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] Spinderman Returns\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz:10edf34a-f317-42ca-98a0-cb1d6995c7c8\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n## m To n Roundup\r\n\r\n`{m,n}` has four variations:\r\n\r\n* `{m,n}` matches at least m and at most n occurrences.\r\n* `{m}` matches exactly m occurrences.\r\n* `{m,}` matches at least m occurrneces (no upper bound).\r\n* `{,n}` matches at least 0 and at most n occurrences.\r\n\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
138	15	1	regex-matching-0-or-1-occurrences	Regex - ? (Matching 0 or 1 Occurrence)	3	`?` stands for `{0,1}`. A pattern should match at least 0 and at most 1 time. Effectively, it's another way of saying that the pattern may or may not be there. It's used very frequently.\r\n\r\nLet's revisit the problem of matching numbers from -9 to 9. Also, 7 could be written as 7 as well as +7. We could re-write the previous regex (`[+-]{0,1}\\d`) as `[+-]?\\d`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[+-]?\\d"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "-7")\r\n<_sre.SRE_Match object; span=(0, 2), match='-7'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "7")\r\n<_sre.SRE_Match object; span=(0, 1), match='7'>\r\n>>> re.search(REGEX_PATTERN, "+7")\r\n>>> \r\n<_sre.SRE_Match object; span=(0, 2), match='+7'>\r\n>>> \r\n```\r\n\r\n--mcquiz:c1e4f09c-8569-4d35-aac9-018ff5b6cfaa\r\nWhich of the following would match regex `[+-]\\d?\\d`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz:62aeb766-20d9-4021-a140-618342d4ff16\r\nWrite a regex that would match numbers -99 to 99. The +ve numbers may be written with or without a `+` prefix. For example, 98 could be written as 98 or +98. \r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz:ae9c9584-2889-44ff-95f3-f9fa831a0e31\r\nWrite a regex that would match `http://` as well as `https://` urls.\r\n  [#] https://www.google.com\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] http://www.yahoo.com\r\n  [ ] ftp://www.google.com\r\n  [ ] scp://www.yahoo.com\r\n  [ ] http-proto\r\n  [ ] https is a protocol\r\n--\r\n  \r\n  \r\n  \r\n  \r\n  \r\n\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
139	16	1	regex-matching-0-or-more-occurrences	Regex - * (Matching 0 or More Occurrences)	3	`*` stands for `{0,}` which means at least 0 and at most infinite matches. `BA*T` would match `BT`, `BAT`, `BAAAAAAAAAAAAAAAAAAAAAT` etc.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "BA*T", "BT")\r\n<_sre.SRE_Match object; span=(0, 2), match='BT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAT")\r\n<_sre.SRE_Match object; span=(0, 3), match='BAT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAAAAAT")\r\n<_sre.SRE_Match object; span=(0, 7), match='BAAAAAT'>\r\n```\r\n\r\n--mcquiz:14376373-e7c1-494e-a8f2-531f565e2bf7\r\nWhich of the following would match regex `\\w\\s*:\\s*\\w`:\r\n  [#] Potatoes: 4\r\n  [#] Potatoes:4\r\n  [#] Potatoes    :     4\r\n  [#] 4: Potatoes\r\n  [ ] Potatoes ~::~ 4\r\n  [ ] :Potatoes:\r\n--\r\n\r\n--regexquiz:dc76c54b-5968-4a3b-a02f-260a10651451\r\nWrite a regex that matches `http` and `https` urls that end with `.com` or `.org` domains. Hint: you'll need `.*`.\r\n  [#] http://www.google.com\r\n  [#] http://yahoo.org\r\n  [#] http://www.facebook.com/profile\r\n  [#] http://www.wattpad.com/tags/fiction\r\n  [ ] ftp://www.google.com\r\n  [ ] http://www.yahoo.net\r\n  [#] https://www.facebook.com\r\n  [ ] https://www.photo.net\r\n--\r\n\r\n--regexquiz:dba74cbc-9b45-4215-8603-2f519c3d0bae\r\nWrite a regex that would match the sentences that mention cat followed by dog. Hint: use repetition of `.` to match word & space characters.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [ ] The dog looked at the cat with confusion.\r\n  [ ] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n--\r\n\r\n--regexquiz:5ee02aed-22c0-48de-a012-f393b69c9bee\r\nWrite a regex that would match sentences that mention cat and dog in any order (i.e. word cat could come before or after the word dog). Hint: Use the `|` operator.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [#] The dog looked at the cat with confusion.\r\n  [#] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n  [ ] The dog went wild.\r\n--\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
140	17	1	regex-matching-1-or-more-occurrences	Regex - + (Match 1 or More Occurrences)	2	`+` stands for `{1,}` which matches at least 1 and at most infinite times.\r\n\r\nHow do you match the movies with at least 2 words in their name? `\\w+\\s+\\w+` would do the trick. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\w+\\s+\\w+"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Spiderman Returns")\r\n<_sre.SRE_Match object; span=(0, 17), match='Spiderman Returns'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Spiderman")\r\n>>> \r\n```\r\n\r\n--regexquiz:3cacba35-8a65-4acb-b1fc-1cf375c8b55c\r\nWrite a regex to match movies with at least three words in their name.\r\n  [#] Gone With The Wind\r\n  [ ] Superman\r\n  [#] La La Land\r\n  [#] The Sixth Sense\r\n  [ ] Braveheart\r\n--\r\n\r\n--regexquiz:d5ee27df-3581-4b7e-aa2d-354be285db74\r\nWrite a regex to match movies with at least four words in their name. Note: you have to match `:` as part of characters between words. Hint: you can use `[]` or `|` for matching characters between words.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n  [ ] Shawshank Redemption\r\n  [#] 2001: A Space Odyssey\r\n--\r\n\r\n--regexquiz:20698e4a-4f06-4eec-adc7-8c69cac3808b\r\nWrite a regex to match the sentences that mention two years.\r\n  [#] 1984 comes before 1999.\r\n  [#] 2004 comes after 2001.\r\n  [ ] In 2015, I bought 2 cars.\r\n  [ ] There was a flood in 1999.\r\n--\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
141	19	1	regex-matching-word-boundaries	Regex - Matching Word Boundaries	5	In regex, `\\b` matches word boundary. What does it mean? Let's first define what a word is.\r\n\r\nIn regex, a word is an unbroken sequence of `[A-Za-z0-9_]` or `\\w`. The sentence `cat jumped` has two words: `cat` and `jumped`. OTOH, `key:value` has two words: `key` and `value`. Even `http-proto` has two words: `http` and `proto`.\r\n\r\nSymbol `\\b` matches at the start and end of word boundary. The regex `\\bcat\\b` would match sentences that have word `cat`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\bcat\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "cat is fat")\r\n<_sre.SRE_Match object; span=(0, 3), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "the cat jumped over the wall.")\r\n<_sre.SRE_Match object; span=(4, 7), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this is my cat.")\r\n<_sre.SRE_Match object; span=(11, 14), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "he was herding the cattle.")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this muscat is funny.")\r\n>>> \r\n```\r\n\r\n--mcquiz:66532415-dbad-42db-8664-17bb962fd21c\r\nHow many words (as per regex definition) are there in `http://www.google.com/search`?\r\n  [ ] 3\r\n  [ ] 4\r\n  [#] 5\r\n  [ ] 6\r\n--\r\n\r\n--regexquiz:67d4ece9-9a4b-4f0e-b733-5ced60ce9bb8\r\nWrite a regex to match sentences that mention animal dog.\r\n  [#] a dog was barking.\r\n  [#] dog is a loyal animal.\r\n  [#] this is my dog.\r\n  [ ] is it a dogfish?\r\n  [ ] dogfood is about using your own software.\r\n--\r\n\r\n--regexquiz:de6b8d33-1db6-4bd4-92dc-51856f2eb37b\r\nWrite a regex that matches sentences with at least one word that has exactly 5 letters.\r\n  [#] I am a super human.\r\n  [#] Spice route is not spicy.\r\n  [ ] Spiderman returns is not interesting.\r\n  [ ] Cat can jump.\r\n  [#] Cat can't climb.\r\n--\r\n\r\n--regexquiz:584051c2-5cb3-444c-819c-8da6333804a0\r\nWrite a regex that matches sentences that have a year in 4 digit format.\r\n  [#] In year 2000, there was an earthquake.\r\n  [#] 1984.\r\n  [#] In 2020, I'll be 20 years old.\r\n  [ ] I am 20 years old now.\r\n  [ ] 123456789 is a really long number.\r\n--\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
142	20	1	regex-matching-line-boundaries	Regex - Matching Line Boundaries	8	Just like words have boundaris that we can match with `\\b`, lines also have boundaries that we can match with `^` (start of line) and `$` (end of line).\r\n\r\nLet's say we want to match movie names that start with a year. So, we should match `2001: A Space Odyssey` but not `Dracula A.D. 1972`. We could use the pattern `^\\d{4}\\b` to do just that.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"^\\d{4}\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n<_sre.SRE_Match object; span=(0, 4), match='2009'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "44500 Max")\r\n>>> # Not a match\r\n>>>\r\n```\r\n\r\nSimilarly, we can use the pattern `\\b\\d{4}$` to match movie names that end with a year.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\b\\d{4}$"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n<_sre.SRE_Match object; span=(19, 23), match='1940'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n>>> # Not a match\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "Super 23123")\r\n>>> # Not a match\r\n>>> \r\n```\r\n\r\n--mcquiz:72adb2e8-b01c-4f29-8109-7d380d120d8c\r\nWhich of the following would match the regex `^\\d{4}$`:\r\n  [#] 1984\r\n  [#] 1971\r\n  [#] 2081\r\n  [ ] AM1200\r\n  [ ] Class of 1999\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Daleks' Invasion Earth: 2150 A.D.\r\n--\r\n\r\n--regexquiz:169bd30c-ca2c-468b-9319-5caf27f1efa7\r\nWrite a regex to match movie names that have only a single word:\r\n  [#] Superman\r\n  [#] 1984\r\n  [ ] Spiderman Returns\r\n  [ ] 2001: A Space Odyssey\r\n  [#] AM1200\r\n  [ ] I.Q.\r\n--\r\n\r\n--regexquiz:5424bec4-03d0-4ab5-a8e4-3db4fda08841\r\nWrite a regex to match movie names that do not have any whitespace character (Hint: `\\S`).\r\n  [#] Superman\r\n  [#] I.Q.\r\n  [ ] Spiderman Returns\r\n--\r\n\r\n--regexquiz:6c7ed823-0cc1-40de-a671-e988e9d44597\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] http://www.yahoo.com\r\n  [#] http://www.wattpad.com\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz:90bcd660-49e7-42fa-9f4a-64bb28720165\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://www.wattpad.com\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz:695ab476-a23b-4cf2-a876-71c2a16bbeff\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz:f2a8586f-01bb-4a33-93d4-45070c51530a\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com/tags/children\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz:e0d044cd-2577-431d-96da-ab139d9798f1\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com/tags/children\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n  [#] http://localhost:8000/test-page.html\r\n--\r\n\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
143	23	1	regex-extract-content-full-match	Regex - Extract Content Full Match	2	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, but also which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\nYou should refer to the documentation of [Match Object](file:///Users/mangarg/Downloads/python-3.6.2rc1-docs-html/library/re.html#match-objects) on Python documentation.\r\n\r\n--offline-exercise:1fb6bc2e-29b5-41a9-83e4-9f39dd92aa68\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n--offline-exercise:f006ebc6-89b8-4171-9d63-bc6f8f7f5835\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that use an Adverb (words that end with ly). For example: strictly, deadly, objectively etc.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Strictly Ballroom` should give you `Strictly`.\r\n* `Tough and Deadly` should give you `Deadly`.\r\n* `Heavenly Creatures` should give you `Heavenly`.\r\n* `Superman` should not be a match.\r\n--\r\n\r\n--offline-exercise:42f6e7f4-8066-4422-81dd-7d18cb81298a\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module.\r\n* Define a regex to match sentences that have an email address (user@domain.com). For simplicity, assume that `user` and `domain` can have only the word characters and `-`.\r\n* Extract the matching email address from the Match Object returned `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `smith@yahoo.com - Steve Smith` should give you `smith@yahoo.com`.\r\n* `hi@turtleprogrammer.com - Someone Out There` should give you `hi@turtleprogrammer.com`.\r\n* `rama@gmail.com` should give you `rama@gmail.com`.\r\n* `rama @gmail.com` should not be a match.\r\n--\r\n\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
144	25	1	regex-extract-content-nested-groups	Regex - Extract Content (Nested Groups)	3	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r"\\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n'Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person with middle name\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person without middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n--offline-exercise:8a9f5ede-33d8-4d92-a0b1-94dc9c8170af\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and match groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise:f2017509-009a-42a7-b33b-3c68b915d971\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and match groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise:78b449f4-fc02-457b-ab44-d499418324c0\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `<proto>://<host>.<site>.com`. Using regex (and match groups), you need to extract the proto, host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `http`, `www` and `google`.\r\n* `https://en.wikipedia.org` should give you `https`, `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `http`, `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise:31c2764d-e0bb-4a22-8da7-21654f58abcf\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of ingredients and quantity for a recipe. It's in the format `<ingredient>: <quantity> <metric>`. Using regex (and match groups), you need to extract the ingredient, quantity and metric. Metric is optional.\r\n\r\nHere is how you can test it:\r\n\r\n* `Onion: 2` should give you `Onion` and `2`.\r\n* `Olive Oil: 1 tbsp` should give you `Olive Oil`, `1` and `tbsp`.\r\n* `Salt  :   1    tbsp` should give you `Salt`, `1` and `tbsp`.\r\n* `Water:`, `Pepper: tbsp` should not match.\r\n--\r\n\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
145	26	1	regex-extract-content-named-groups	Regex - Extract Content (Named Groups)	8	While it's possible (and easy) to use numbered groups to extract content, it can get unwiedly in complex regex when there are too many nested groups. It's much cleaner to be able to name the groups for which we want to extract the content.\r\n\r\nLet's rework the problem of extracting first name and last name from a name. This is what we did earlier:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nWe can instead use the `(?P<group_name>...)` syntax:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(?P<first_name>\\w+) (?P<last_name>\\w+)", "Ram Kripal")\r\n>>> name_match.group('first_name')\r\n'Ram'\r\n>>> name_match.group('last_name')\r\n'Kripal'\r\n```\r\n\r\nIf you notice, we rewrote `(\\w+)` as `(?P<first_name>\\w+)` which can be broken down as:\r\n\r\n* `(` - start of the group.\r\n* `?P` - declaration that we'll give a name to the group.\r\n* `<first_name>` - name of the group.\r\n* `\\w+` - pattern. \r\n* `)` - end of the group\r\n\r\n--offline-exercise:21c05233-af76-41ea-8f32-0994dc758022\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nFrom the [previous section](/topic/regex-extract-content-nested-groups), modify the regex to extract first, middle and last names to use named groups. The group names should be first_name, middle_name and last_name.\r\n\r\nHere is how you can test it:\r\n\r\n* `George Bernard Shaw` should give you `George`, `Bernard`, `Shaw`.\r\n* `Ram Prakash Kripal` should give you `Ram`, `Prakash`, `Kripal`.\r\n* `John Smith` should give you `John`, blank middle name, `Smith`.\r\n* `Lee` and `Raja Shekhar Chandra Reddy` should not match.\r\n--\r\n\r\n--offline-exercise:ea476223-38e5-49fd-b70a-79d62746bc9a\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and named groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise:dca25a5b-8579-4aad-ba20-1b7fc072c5f2\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and named groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
146	28	1	regex-split-findall-content	Regex - Split/FindAll	2	We'll run through a few more methods in the `re` module.\r\n\r\n## re.split()\r\n\r\nThe `re.split()` method splits a strings based on a regex. Example:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.split(r"\\W+", "apple banana mango pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana, mango, pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana , mango   , pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n```\r\n\r\nWhile you can use the string's `split()` method, the regex one just becomes more powerful since it can handle so many variations of the separator.\r\n\r\n--offline-exercise:f9965145-d7b0-46a5-a506-47afb703ffb0\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nUse the `re.split()` mmethod to split a string that has list of ingredients and their quantity for a recipe. The format is `ingredient: quantity`.\r\n\r\nHere is what you can use for testing:\r\n\r\n* `Onion: 2` should give you `['Onion', '2']`.\r\n* `Onion  :   2` should give you `['Onion', '2']`.\r\n* `Onion:2` should give you `['Onion', '2']`.\r\n* `Onion: `, `:2` and `Onion` should not match.\r\n--\r\n\r\n## re.findall()\r\n\r\nThe method `re.findall()` is useful when you are trying to find multiple occurrences of a pattern within text. For example, if we want to find all years mentioned in a given text, `findall()` would be pretty helpful. Example:\r\n\r\n```Python\r\n>>> text = "The growth was more in 2001 compred to 2002."\r\n>>> re.findall(r"\\d+", text)\r\n['2001', '2002']\r\n```\r\n\r\n--offline-exercise:f84447b8-31cf-489c-8e6f-017263fa859e\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nUse the `re.findall()` method to find all five letter words in given text. Here is how you can test your code:\r\n\r\n* `There was less death in 2004.` should give you `['There', 'death']`.\r\n* `This is superb.` should give you nothing.\r\n--\r\n\r\n	2017-07-09 00:57:01.181266	2017-07-09 00:57:01.181295
\.


--
-- Name: topic_history_id_seq; Type: SEQUENCE SET; Schema: public; Owner: turtleprogrammer
--

SELECT pg_catalog.setval('topic_history_id_seq', 146, true);


--
-- Data for Name: topics; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY topics (id, slug, title, version_number, markdown, author_id, created_at, updated_at) FROM stdin;
6	regex-matching-characters	Regex - Matching Characters	2	In this section, we'll solve problems that revolve around presence or absence of certain characters in the text. For most of the problems, we'll use Hollywood movie names as the dataset where we do our pattern matching. It looks like the following:\r\n\r\n```\r\nAbandoned\r\nAbbott and Costello Meet the Killer\r\nAbominable Dr. Phibes\r\nAbominable Snowman\r\nAbove the Street\r\nAbsent-Minded Professor\r\nAbyss\r\n...\r\nZoom \r\nZoot Suit \r\nZorba the Greek \r\nZorn's Lemma \r\nZorro \r\nZotz! \r\nZouzou \r\nZozo\r\n```\r\n\r\nHere are the kind of problems we'll solve around the movie names:\r\n\r\n* Finding movies that belong to a specific franchise (e.g. `Star Wars`).\r\n* Finding movies from multiple franchise (e.g. all movies from `Star Wars` as well as `Star Trek`).\r\n* Skipping movies from a specific franchise (e.g. all movies other than `Superman`). Or even all `Super` movies that are not `Superman`.\r\n* Finding movies that use a year in their name (e.g. `2001: A Space Odyssey`).\r\n* Finding movies with at least one five letter word (e.g. `Superman` is ok but `Cat and Dog` is not).\r\n	1	2017-07-04 13:34:51.763413	2017-07-04 14:23:52.24723
1	regex-introduction	Regex Introduction	20	There is an inherent difficulty in explaining what regular expressions are. As is the case with many other subjects in software engineering, regular expressions are part of a different paradigm than what we are familiar with. That makes it hard to explain it in theory or to understand it in terms of pure concept. However, as soon as you see it, you not only understand it but also appreciate the ingenuinity in its design and wide applicability it has in solving several classes of problems.\r\n\r\nSo, rather than starting from the explanation of what regular expressions are or what they are good for, let's start from a problem that we want to solve and then arrive at the conclusion that we need regular expressions like tool to solve that problem.\r\n\r\nBased on this approach, here is the outline of our regex learning plan:\r\n\r\n* A short and sweet introduction to problem of defining patterns, searching for them in plain text, extracting the matching portions of the text etc.\r\n* A multi-topic study of regular expressions. Learning the language and mastering it with various practice problems.\r\n* Solving a couple of problems where our full knowledge of regex can be applied.	1	2017-07-03 05:15:56.703792	2017-07-04 01:05:22.929537
2	regex-setting-the-stage	Regex - Setting the Stage	11	## Stage 1\r\n\r\n<img src="/static/img/regex/favorite-website-form.png" class="ui right floated medium image"/>\r\n\r\nLet's talk about a problem that someone can actually run into. Let's say, you were intereted in finding out the most popular websites that kids in your school go to. You create a Google Spreadsheet based Form and send a link to everyone in your school. There is only one simple question: `What's your favorite website?`.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 2\r\n<img src="/static/img/regex/favorite-websites.png" class="ui left floated small image"/>\r\n\r\nAnswers start pouring in and your Google spreadsheet starts filling in with the name of the websites. You are hoping that you can easily count the distinct names and that would tell you how popular different websites are.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 3\r\n\r\n<img src="/static/img/regex/favorite-websites-2.png" class="ui left floated small image"/>\r\n\r\nWhile you were waiting for all the results to come in, you find that some people entered just the simple name (e.g. `google`), some others prefer to provide domain name (e.g. `google.com`). You were still wondering how you would handle that when (as they say) all hell broke loose.\r\n\r\n<div class="ui clearing divider"></div>\r\n\r\n## Stage 4, 5 and so on so forth\r\n\r\n<img src="/static/img/regex/favorite-websites-3.png" class="ui right floated medium image"/>\r\n\r\nYou find that students are entering information in all sorts of format. Some are providing the domain names (`google.com`), some are providing the full url (`https://www.google.com`) and some are even providing links to specific sections of the website (`https://www.wattpad.com/tags/children`). How are you ever going to sort through all of this?\r\n\r\n\r\n\r\n\r\n\r\n	1	2017-07-03 23:19:12.44864	2017-07-03 23:55:56.184578
4	regex-enters-the-gibberish	Regex - Gibberish to Rescue	2	To an untrained eye, regular expressions look like gibberish and that's how we'll treat them in this section. Once you are done with the entire material, they'll not be gibberish anymore. We'll get there...\r\n\r\n#### Revisiting the Problem\r\n\r\nWe want to extract the website name (i.e. `wattpad`) from different ways in which it is given to us (i.e. `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children`).\r\n\r\n#### The Solution\r\n\r\nThe solution has two parts to it:\r\n\r\n* First, we define a pattern that would match all variations in which people mentioned the site name (i.e. `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children`)\r\n* Next, we'll use the pattern to extract the actual site name (i.e. `wattpad`) from its variations.\r\n\r\nHere is the gibberish (aka regular expression) that describes the pattern we are looking for. Don't even try to understand it for now. Just take it as it is.\r\n\r\n```Python\r\nREGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\r\n```\r\n\r\nHere is the code that makes use of `REGEX_GIBBERISH`, applies it to the site name as entered by the students and gives us the bare bone site name as we want to see.\r\n\r\n```Python\r\n# Import the regular expression module\r\nimport re\r\n\r\n# Define the regex pattern\r\nREGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\r\n\r\n# Apply the pattern to whatever site name was entered by students \r\n# and get the barebone site name.\r\nre.search(REGEX_GIBBERISH, "...site name...").group("site")\r\n```\r\n\r\nLet's see this code in action now.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_GIBBERISH = r"(https?://)?(www\\.)?(?P<site>\\w+)(\\.com)?"\r\n>>> \r\n>>> re.search(REGEX_GIBBERISH, "wattpad").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "www.wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "http://www.wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "https://www.wattpad.com").group("site")\r\n'wattpad'\r\n>>> re.search(REGEX_GIBBERISH, "https://www.wattpad.com/tags/children").group("site")\r\n'wattpad'\r\n>>> \r\n```\r\n\r\nFascinating. Isn't it?	1	2017-07-04 00:32:00.205196	2017-07-04 01:07:13.272998
3	regex-problem-statement	Regex - Problem Statement	5	Continuing from the previous section, here is the sample information you received from the students of your school:\r\n\r\n```\r\nGoogle\r\nFacebook\r\nInstagram\r\nWattPad\r\ngoogle.com\r\nfacebook.com\r\nwattpad.com\r\nwww.google.com\r\nwww.facebook.com\r\nwww.wattpad.com\r\nhttps://www.wattpad.com/tags/children\r\nhttps://www.facebook.com/home\r\nhttps://www.instagram.com\r\n```\r\n\r\nEven though there is quite a variety in the way information is represented, there is a pattern here. You intuitively know that `wattpad`, `www.wattpad.com`, `https://www.wattpad.com/` and `https://www.wattpad.com/tags/children` mean the same thing in this context. They all mean that the student has singled out `wattpad` as the favorite site.\r\n\r\nThis is where the problem is: how do you map all these variations of `wattpad` to just what it is (i.e. `wattpad`)? To your mind, the pattern is clear and you can easily see the mapping. However, if you were to write a program for this purpose, it would be a fairly involved task.\r\n\r\nThis is where regular expresions shine. They give you a powerful language to describe the pattern (or the variations thereof).\r\n\r\n\r\n	1	2017-07-03 23:57:09.421612	2017-07-06 00:47:48.233946
5	regex-the-plan	Regex - The Plan	1	Here is what we are going to do now. We are going to learn regular expressions one bit at a time. Here is the broad outline:\r\n\r\n* How to write patterns in regular expressions and use these patterns to `match` text. This is where you learn pretty much 80% of this language.\r\n* How to extract the text that matches the pattern. This is really a small bit once you have a pattern in hand.\r\n* How to replace the matching text with some other text. This is also a small bit once the language itself has been learnt.	1	2017-07-04 13:34:51.763413	2017-07-04 13:34:51.763455
25	regex-extract-content-nested-groups	Regex - Extract Content (Nested Groups)	3	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r"\\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n'Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person with middle name\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person without middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n--offline-exercise:8a9f5ede-33d8-4d92-a0b1-94dc9c8170af\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and match groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise:f2017509-009a-42a7-b33b-3c68b915d971\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and match groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise:78b449f4-fc02-457b-ab44-d499418324c0\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `<proto>://<host>.<site>.com`. Using regex (and match groups), you need to extract the proto, host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `http`, `www` and `google`.\r\n* `https://en.wikipedia.org` should give you `https`, `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `http`, `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise:31c2764d-e0bb-4a22-8da7-21654f58abcf\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of ingredients and quantity for a recipe. It's in the format `<ingredient>: <quantity> <metric>`. Using regex (and match groups), you need to extract the ingredient, quantity and metric. Metric is optional.\r\n\r\nHere is how you can test it:\r\n\r\n* `Onion: 2` should give you `Onion` and `2`.\r\n* `Olive Oil: 1 tbsp` should give you `Olive Oil`, `1` and `tbsp`.\r\n* `Salt  :   1    tbsp` should give you `Salt`, `1` and `tbsp`.\r\n* `Water:`, `Pepper: tbsp` should not match.\r\n--\r\n\r\n	1	2017-07-08 21:01:24.41188	2017-07-09 01:20:32.66126
7	regex-matching-literals	Regex - Matching Literals	9	Let's start with defining a pattern that matches `Star Wars` franchise movies. The movie names look like the following:\r\n\r\n```\r\nStar Wars: Episode IV - A New Hope \r\nStar Wars: Episode V - The Empire Strikes Back \r\nStar Wars: Episode VI - Return of the Jedi\r\n```\r\n\r\nHere, the pattern we are potentially looking for is `Star Wars`. It distinguishes this franchise from other movies like: `Cinderella III: A Twist in Time`, `2001: A Space Odyssey` etc. Let's test out our pattern now.\r\n\r\n## Anatomy of a Regex Match\r\n\r\nFirst thing we do is import the `re` module that provides all the regex functionality in Python.\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, we define our pattern.\r\n\r\n```Python\r\n>>> REGEX_PATTERN = r"Star Wars"\r\n```\r\n\r\nIf you start the string with `r`, it marks as `Raw String Mode`. In this mode, `\\` is a not a special character and need not be escaped.\r\n\r\nFinally, we perform the match. We use the `search(pattern, string)` function for that. As you can guess, `pattern` is the regex pattern we are searching for and `string` is the piece of text where we are searching for that pattern.\r\n\r\n```Python\r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> # match object was returned\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n>>> # nothing returned\r\n```\r\n\r\nWhen we search for our pattern in `Star Wars: Episode I - The Phantom Menace`, a match is found the `search()` function returns a match object that we'll discuss later. However, when we search in `2001: A Space Odyssey`, the pattern is not found and `search()` function returns `None`.\r\n\r\nIt's an important distinction. When the pattern is found, `search()` returns a match object. But when pattern is not found, `search()` returns `None`.\r\n\r\n--mcquiz:f1de4844-1927-4b7e-a687-43ba797f1779\r\nHere are some movie names. Which of these would match the regex `Window`:\r\n  [#] Rear Window\r\n  [#] Secret Window\r\n  [#] Open Windows\r\n  [ ] Win it All\r\n  [ ] Gone With The Wind\r\n--\r\n\r\n--regexquiz:6c410957-58ab-4b59-9ebf-5b3c81ce178a\r\nWhat's the regex to select movies from Star Wars franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Generations \r\n  [ ] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n\r\n--regexquiz:e1043574-1cbd-46b0-8183-815ebe1daad2\r\nWhat's the regex to select movies from Star Trek franchise?\r\n  [ ] Star Wars: The Last Jedi\r\n  [ ] Star Wars: The Force Awakens\r\n  [#] Star Trek: Generations \r\n  [#] Star Trek: First Contact\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Empire of Dreams: The Story of the 'Star Wars' Trilogy\r\n--\r\n	1	2017-07-04 13:34:51.763413	2017-07-09 01:12:49.214302
9	regex-matching-special-characters	Regex - Matching Special Characters	2	Some characters have special meaning in regex (e.g. `.`, `?`, `(`, `)`, `*`, `+`, `^`, `$`, `\\`, `[`, `]`) . We'll look at their use later in the game. For now, suffice it to say that if you want to match any of these, you have to precede them with `\\` to find a match. For example, if you want to match movie names that have a full stop, you have to use `\\.` as regex pattern and not `.`.\r\n\r\nLet's solve the problem of matching movie names that have a full stop. Here is the wrong pattern:\r\n\r\n```Python\r\n>>> import re\r\n>>> INCORRECT_REGEX_PATTERN = r'.'\r\n>>> \r\n>>> re.search(INCORRECT_REGEX_PATTERN, 'Mr. Average')\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(INCORRECT_REGEX_PATTERN, 'Stardust')\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> # should not have matched Stardust but it did.\r\n```\r\n\r\nHere is the same exercise with the right regex pattern:\r\n\r\n```Python\r\n>>> import re\r\n>>> CORRECT_REGEX_PATTERN = r'\\.'\r\n>>> \r\n>>> re.search(CORRECT_REGEX_PATTERN, 'Mr. Average')\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(CORRECT_REGEX_PATTERN, 'Stardust')\r\n>>> # did not match Stardust\r\n```\r\n\r\n--regexquiz:ffb4f681-4808-439c-bb43-23727c19e013\r\nWrite the regex pattern that matches movies with `.` in their name:\r\n  [#] Mr. Pip\r\n  [#] The D.I.\r\n  [ ] Stardust\r\n  [ ] Superman\r\n--\r\n\r\n\r\n\r\n	1	2017-07-04 18:03:20.665585	2017-07-09 01:13:03.252865
8	regex-matching-this-or-that	Regex - Matching This or That	11	We'll now solve the problem of matching movie names that could be from `Star Wars` or `Star Trek` franchise. So, the regex pattern should match the following:\r\n\r\n```\r\nStar Wars: Episode I - The Phantom Menace \r\nStar Wars: Episode II - Attack of the Clones\r\nStar Trek: Generations \r\nStar Trek: First Contact \r\n```\r\n\r\nBut it should not match the following:\r\n\r\n```\r\nStardust\r\nStar 80\r\nStar of Midnight\r\n```\r\n\r\nIn regex, multiple patterns can be combined with `|` which means `OR` condition. For example, to solve our current problem, we could define the pattern as `Star Wars:|Star Trek:`. This pattern would match either `Star Wars:` or `Star Trek:`. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star Wars:|Star Trek:"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\nThe regex `Star Wars:|Star Trek:` has multiple duplicate elements. We can make it more concise with `Star (Wars|Trek):`. It means look for `Star`, followed by a space followed by either `Wars` or `Trek`, followed by a `:`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"Star (Wars|Trek):"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Wars: Episode I - The Phantom Menace")\r\n<_sre.SRE_Match object at 0x109b19c60>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Star Trek: Generations")\r\n<_sre.SRE_Match object at 0x109b19bf8>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Stardust")\r\n>>> re.search(REGEX_PATTERN, "Star 80")\r\n>>> # Stardust and Star 80 don't match the pattern.\r\n```\r\n\r\n--mcquiz:2b151f26-94fd-4932-bab8-349427ce848d\r\nHere are some movie names. Which of these would match the regex `Force|Jedi`:\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [ ] Star Trek: Discovery\r\n  [ ] Star Trek: Voyager\r\n--\r\n\r\n--regexquiz:4007c758-69cf-46a6-928e-4b7cd55bf4fd\r\nWhat's the regex to select movies from Star Wars as well as Star Trek franchise?\r\n  [#] Star Wars: The Last Jedi\r\n  [#] Star Wars: The Force Awakens\r\n  [#] Star Trek: Discovery\r\n  [#] Star Trek: Voyager\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n--\r\n\r\n--mcquiz:fa5b08c2-b54d-4547-9a6d-eb4ff46f2b4c\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [#] `Superman|Supergirl`\r\n  [#] `Super(man|girl)`\r\n  [ ] `Super(m|g)(a|i)(n|r)l`\r\n  [#] `Super(m|g)(a|i)(n|rl)`\r\n  [#] `Super((man|girl))`\r\n  [#] `Super((man)|girl)`\r\n--\r\n\r\n--mcquiz:a16209cb-a012-4ce5-8f0a-d30ffbaa3a5c\r\nWhich of the following movies will be matched by regex `(Star (Wars|Trek):)|(Super(man|girl))`\r\n  [#] Star Wars: The Last Jedi\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n  [#] Star Trek: Voyager\r\n  [#] Superman Returns\r\n  [#] Supergirl\r\n--\r\n\r\n--regexquiz:9cb8a852-cfbd-491b-af75-47edc4c229a9\r\nWrite a regex that would match all the Star Wars, Star Trek and Space related movies.\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Star Dust\r\n  [#] Star Trek: Voyager\r\n  [ ] Superman\r\n  [#] Alien Space Avenger\r\n--\r\n\r\n	1	2017-07-04 17:16:11.331039	2017-07-09 01:13:44.718424
10	regex-matching-one-of-many-characters	Regex - Matching One of Many Characters	7	An interesting problem to solve is to match movies that mention a year in their name. Sample movie names are: `2001: A Space Odyssey`, `Dream Team 1935`, `Class of 1999` etc. To keep it simple for now, a year is four digits out of which first digit could be 1 or 2 and rest of the digits could go from 0 to 9. From what we have learnt so far, we could define a pattern like this for our purpose.\r\n\r\n```Python\r\nREGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n```\r\n\r\nLet's put it to use and see it working.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"(1|2)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nThe pattern works but it's quite cumbersome. Regex provides another expression that we can use here. `(0|1|2|3|4|5|6|7|8|9)` could be written as `[0123456789]`. When you put multiple characters in `[]`, regex would look for matching one of these.\r\n\r\nWe can now rewrite the previous expression as:\r\n\r\n```Python\r\nREGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n```\r\n\r\nLet's try out the new pattern.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0123456789][0123456789][0123456789]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nIn fact, such needs are so common that there is a further shortcut to matching digits 0-9: `[0-9]`. So, we can once again re-write the expression as `[12][0-9][0-9][0-9]`. Here is how we use it:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12][0-9][0-9][0-9]"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nNice. Isn't it?\r\n\r\n--regexquiz:4eb7e560-d86d-4eee-9f3f-3be7a381617f\r\nTry different regex variations that we discussed just now to select movie names that have a year in their name.\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] 1984\r\n  [ ] Gone With The Wind\r\n  [ ] Star Wars: The Last Jedi\r\n--\r\n\r\n## Ranges and Alphabets\r\n\r\nRanges work not only for digits but also for alphabets. So, you could say `r"[A-Z]"` to match any upper case letter, `r"[a-z]"` to match any lower case letter, `r"[A-Za-z]"` to match all English alphabet letters, `r"[A-Za-z0-9]"` to match any alphanumeric characters. In fact, you can also say `r"[AM-PZ]"` and it would match letters A, M, N, O, P, Z.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> re.search(r"[A-Z]", "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(6, 7), match='A'>\r\n>>> \r\n>>> re.search(r"[A-Z]", "1984")\r\n>>>\r\n```\r\n\r\nHere, we are looking for a movie name with an uppercase letter. The movie `2001: A Space Odyssey` is a match, whereas, the movie `1984` is not a match.\r\n\r\n--mcquiz:3de214bf-d472-4dfd-a05e-3552496a9394\r\nHere are some movie names. Which ones would match the regex `r"[0-9][0-9][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [#] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz:50b56794-b819-4fc9-b5ab-8f7db62f3236\r\nHere are some movie names. Which ones would match the regex `r"[0-29][0-5][0-9][0-9]:"`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [#] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n--mcquiz:f021d060-5ae6-4042-b6a0-87172f94be87\r\nFrom a list of movies, if we want to match the ones that are part of `Superman` or `Supergirl` franchise, which of the following regex would do the work:\r\n  [ ] `r"Super[mg][ai][nrl]"`\r\n  [#] `r"Super[mg][ai][nr]l"`\r\n  [#] `r"Super[mg][ai](n|rl)"`\r\n  [ ] `r"Super[mangirl]"`\r\n--\r\n\r\n--regexquiz:c562b1db-5dd5-49dc-b821-b25dc821dcde\r\nHere is a list of movie names. Select the ones that have at least one 4 letter word in the middle of movie name.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz:7ab96916-ae7b-43ba-a620-a07d017db875\r\nHere is a list of movie names. Select the ones that use a number within a word.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz:7f8920cf-32e5-41d4-ba2a-01766a2b8c07\r\nHere is a list of movie names. Select the ones that have a bat, cat or rat in the name. Use the shortest possible regex.\r\n  [#] Bat Whispers\r\n  [#] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n## Matching absence of characters\r\n\r\nJust like you can match for presence of certain characters, you can also match for their absence. `[^A-Z]` will match all characters except uppercase letters. `[^BCR]at` will match `Sat` but it will not match `Bat`, `Cat` and `Rat`. Simple trick here is to use `^`. `[BCR]` means match B, C or R but `[^BCR]` means match anything other than B, C or R.\r\n\r\n--mcquiz:4148011c-203d-4568-90d8-d868f0bbc517\r\nWhich of the following match regex `[0-1][0-9]:[0-6][0-9] [^P]M`:\r\n  [#] 04:00 AM\r\n  [#] 11:59 AM\r\n  [ ] 06:00 PM\r\n  [ ] 09:23 PM\r\n--\r\n\r\n--mcquiz:3233168c-7e35-471a-9f82-0bf10d884931\r\nHere are some movie names. Which ones would match the regex `[^3-9][0-5][0-9][0-9]:`\r\n  [#] 2001: A Space Odyssey\r\n  [ ] Amityville 1992: It's About Time\r\n  [ ] Detroit 9000\r\n  [#] 2010: The Year We Make Contact\r\n  [#] Godzilla 2000\r\n--\r\n\r\n	1	2017-07-04 18:03:20.665585	2017-07-09 01:15:03.588027
17	regex-matching-1-or-more-occurrences	Regex - + (Match 1 or More Occurrences)	2	`+` stands for `{1,}` which matches at least 1 and at most infinite times.\r\n\r\nHow do you match the movies with at least 2 words in their name? `\\w+\\s+\\w+` would do the trick. Let's give it a try.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\w+\\s+\\w+"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Spiderman Returns")\r\n<_sre.SRE_Match object; span=(0, 17), match='Spiderman Returns'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Spiderman")\r\n>>> \r\n```\r\n\r\n--regexquiz:3cacba35-8a65-4acb-b1fc-1cf375c8b55c\r\nWrite a regex to match movies with at least three words in their name.\r\n  [#] Gone With The Wind\r\n  [ ] Superman\r\n  [#] La La Land\r\n  [#] The Sixth Sense\r\n  [ ] Braveheart\r\n--\r\n\r\n--regexquiz:d5ee27df-3581-4b7e-aa2d-354be285db74\r\nWrite a regex to match movies with at least four words in their name. Note: you have to match `:` as part of characters between words. Hint: you can use `[]` or `|` for matching characters between words.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n  [ ] Shawshank Redemption\r\n  [#] 2001: A Space Odyssey\r\n--\r\n\r\n--regexquiz:20698e4a-4f06-4eec-adc7-8c69cac3808b\r\nWrite a regex to match the sentences that mention two years.\r\n  [#] 1984 comes before 1999.\r\n  [#] 2004 comes after 2001.\r\n  [ ] In 2015, I bought 2 cars.\r\n  [ ] There was a flood in 1999.\r\n--\r\n	1	2017-07-06 00:43:32.697962	2017-07-09 01:18:11.332015
12	regex-matching-occurrences-or-repetitions	Regex - Matching Occurrences or Repetitions	1	So far, we have looked at specifying *which characters* are allowed and which ones are not allowed in the pattern. Now, we'll look at specifying *how many* are allowed.\r\n\r\nLet's revisit the problem of matching movie names with at least 6 letters. We know that `1984` is not a match and `Superman` is a match. The pattern we wrote was `......`. Basically, a `.` (which matches all characters) repeated 6 times.\r\n\r\nRegex has mechanisms to say precisely how many times a match should occur. This is what we'll study in this section.	1	2017-07-05 00:01:35.564596	2017-07-05 00:01:35.564626
11	regex-matching-types-of-characters	Regex - Matching Types of Characters	6	Let's revisit the problem of identifying movies that have a year in their name. We looked at set of characters (i.e. `[0-9]`) as a solution. Some of these sets are so commonly used that there are special symbols for them. These symbols are:\r\n\r\n* `\\w` is equivalent to `[A-Za-z0-9_]`\r\n* `\\W` is opposite of `\\w` i.e. `[^A-Za-z0-9_]`\r\n* `\\s` is equivalent to `[ \\t\\r\\n]`\r\n* `\\S` is opposite of `\\s` i.e. `[^ \\t\\r\\n]`\r\n* `\\d` is equivalent to `[0-9]`\r\n* `\\D` is opposite of `\\d` i.e. `[^0-9]`\r\n* `.` is the most interesting shortcut and it matches all characters without exception.\r\n\r\nSo, we had earlier used regex `[12][0-9][0-9][0-9]` to find movies with a year in their name. This regex could also be written as `[12]\\d\\d\\d`. In this, `\\d` stands for a digit. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[12]\\d\\d\\d"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1935")\r\n<_sre.SRE_Match object; span=(11, 15), match='1935'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n>>> \r\n```\r\n\r\nSimilarly, let's say if we want to find out if a movie name has at least 1 word that is five letters long (or even longer). Instead of writing `[A-Za-z][A-Za-z][A-Za-z][A-Za-z][A-Za-z]`, we could write `\\w\\w\\w\\w\\w`. The `\\w` based regex is more concise and readable. Here it is in action:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\w\\w\\w\\w\\w"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Dream Team 1995")\r\n<_sre.SRE_Match object; span=(0, 5), match='Dream'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 5), match='Super'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Cat And Dog")\r\n>>> \r\n```\r\n\r\n\r\nWhat if we want to find out movies whose name is at least 6 letter long? The regex `......` will do the trick for us:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"......"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Superman")\r\n<_sre.SRE_Match object; span=(0, 6), match='Superm'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1984")\r\n>>> \r\n```\r\n\r\nExpression `r"\\w\\w\\w\\w\\s\\w\\w\\w\\w"` would match a movie name that has at least two words and both the words have at least 4 letters.\r\n\r\n```Python\r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Gone With The Wind")\r\n<_sre.SRE_Match object; span=(0, 9), match='Gone With'>\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "The Ghosts")\r\n>>> \r\n>>> re.search(r"\\w\\w\\w\\w\\s\\w\\w\\w\\w", "Cat And Dog")\r\n>>>\r\n```\r\n\r\n--regexquiz:2b4d6694-3281-4d0a-b663-a9f089f7a081\r\nWrite a regex that matches movies with at least 8 characters in their name.\r\n  [ ] Se7en\r\n  [ ] Thr3e\r\n  [ ] E=mc2\r\n  [#] 2001: A Space Odyssey\r\n  [#] Superman\r\n--\r\n\r\n--regexquiz:a1c91f6f-0aa9-48b2-9f36-fb20beba582b\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz:cd83f62d-4944-4a63-af26-98da4fbd50b9\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n--regexquiz:bccd002e-ecfa-4006-bf3f-3d404c607381\r\nFind movies which have a number surrounded by one letters on each side.\r\n  [#] Se7en\r\n  [#] Thr3e\r\n  [ ] E=mc2\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Superman\r\n--\r\n\r\n--regexquiz:08dbdec3-eb4a-492f-9548-ff7e5c1e7b5b\r\nFind movies which have two consecutive non-word letters. Hint: use `\\W`.\r\n  [#] Star Wars: Return of the Jedi\r\n  [#] Star Trek: Voyager\r\n  [#] Erkan & Stefan 2\r\n  [ ] Cat And Dog\r\n  [ ] Alice in Wonderland\r\n  [ ] Pirates of the Carribean\r\n--\r\n\r\n\r\n	1	2017-07-04 18:03:20.665585	2017-07-09 01:15:49.2823
15	regex-matching-0-or-1-occurrences	Regex - ? (Matching 0 or 1 Occurrence)	3	`?` stands for `{0,1}`. A pattern should match at least 0 and at most 1 time. Effectively, it's another way of saying that the pattern may or may not be there. It's used very frequently.\r\n\r\nLet's revisit the problem of matching numbers from -9 to 9. Also, 7 could be written as 7 as well as +7. We could re-write the previous regex (`[+-]{0,1}\\d`) as `[+-]?\\d`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"[+-]?\\d"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "-7")\r\n<_sre.SRE_Match object; span=(0, 2), match='-7'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "7")\r\n<_sre.SRE_Match object; span=(0, 1), match='7'>\r\n>>> re.search(REGEX_PATTERN, "+7")\r\n>>> \r\n<_sre.SRE_Match object; span=(0, 2), match='+7'>\r\n>>> \r\n```\r\n\r\n--mcquiz:c1e4f09c-8569-4d35-aac9-018ff5b6cfaa\r\nWhich of the following would match regex `[+-]\\d?\\d`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz:62aeb766-20d9-4021-a140-618342d4ff16\r\nWrite a regex that would match numbers -99 to 99. The +ve numbers may be written with or without a `+` prefix. For example, 98 could be written as 98 or +98. \r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz:ae9c9584-2889-44ff-95f3-f9fa831a0e31\r\nWrite a regex that would match `http://` as well as `https://` urls.\r\n  [#] https://www.google.com\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] http://www.yahoo.com\r\n  [ ] ftp://www.google.com\r\n  [ ] scp://www.yahoo.com\r\n  [ ] http-proto\r\n  [ ] https is a protocol\r\n--\r\n  \r\n  \r\n  \r\n  \r\n  \r\n\r\n	1	2017-07-06 00:43:32.697962	2017-07-09 01:16:57.550549
14	regex-repetition-count-symbols	Regex - ?, * and +	2	Some of the `{m,n}` are so commonly used that there are special symbols for them. Here is the list:\r\n\r\n* `?` is same as `{0,1}`. `\\d?` means a digit may or may not be there.\r\n* `*` is same as `{0,}`. `\\d*` means a digit may not be there or there may be infinite occurrences of the same.\r\n* `+` is same as `{1,}`. `\\d+` means that at least one digit is present and it may repeat infinitely.\r\n\r\nLet's put them to some use.\r\n\r\n## ? or {0,1}\r\n\r\nIf you want to match numbers 0 to 99, you can do it with `\\d{1,2}` or `\\d?\\d`. Let's try:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search("\\d?\\d", "43")\r\n<_sre.SRE_Match object; span=(0, 2), match='43'>\r\n>>>\r\n>>> re.search("\\d?\\d", "4")\r\n<_sre.SRE_Match object; span=(0, 1), match='4'>\r\n```\r\n\r\nNote: the pattern `r"\\d?\\d"` would always try to look for two digits as a first thing. However, if it doesn’t find two, it would settle for one. That’s different from `r"\\d"` which would always try to match one digit.\r\n\r\n--mcquiz\r\nWhich of the following would match regex `[+-]\\d?\\d`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -99 to 99. So, it should match -99, -98, …, 98, 99.\r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [ ] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match numbers -99 to 99. The +ve numbers may be written with or without a `+` prefix. For example, 98 could be written as 98 or +98. \r\n  [#] -73\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n## * or {0,}\r\n\r\nJust like `?` matches something that’s optional, `*` matches something that’s optional and yet it can have more than 1 occurrences. So, `r"BA*T"` will match `"BT"`, `"BAT"` as well as `"BAAAAAAAAT"`.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "BA*T", "BT")\r\n<_sre.SRE_Match object; span=(0, 2), match='BT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAT")\r\n<_sre.SRE_Match object; span=(0, 3), match='BAT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAAAAAT")\r\n<_sre.SRE_Match object; span=(0, 7), match='BAAAAAT'>\r\n```\r\n\r\n--mcquiz\r\nWhich of the following would match regex `\\w\\s*:\\s*\\w`:\r\n  [#] Potatoes: 4\r\n  [#] Potatoes:4\r\n  [#] Potatoes    :     4\r\n  [#] 4: Potatoes\r\n  [ ] Potatoes ~::~ 4\r\n  [ ] :Potatoes:\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match the sentences that mention cat followed by dog. Hint: use repetition of `.` to match word & space characters.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [ ] The dog looked at the cat with confusion.\r\n  [ ] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n--\r\n\r\n--regexquiz\r\nWrite a regex that would match sentences that mention cat and dog in any order (i.e. word cat could come before or after the word dog). Hint: Use the `|` operator.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [#] The dog looked at the cat with confusion.\r\n  [#] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n  [ ] The dog went wild.\r\n--\r\n\r\n## + or {1,}\r\n\r\nJust like `*` matches 0 or more occurrences, `+` matches 1 or more occurrences. That means the preceding pattern is not optional. There has to be at least one instance but it can repeat any number of times. Where is it useful? Let’s say we want to match `Yikes` as well as `Yiiiiiiiikkkkkes` in our text. They eventually mean the same thing with different intensity. We could do something like this:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "Yi+k+es", "Yikes" )\r\n<_sre.SRE_Match object; span=(0, 5), match='Yikes'>\r\n>>>\r\n>>> re.search( "Yi+k+es", "Yiiiiiiiiikkkkkes" )\r\n<_sre.SRE_Match object; span=(0, 17), match='Yiiiiiiiiikkkkkes'>\r\n>>>\r\n```\r\n\r\nHow do you find out the names of movies that have at least 2 words? Something along the lines of `\\w+\\s+\\w+` would do the trick.\r\n\r\n--regexquiz\r\nWrite a regex to match movies with at least three words in their name.\r\n  [#] Gone With The Wind\r\n  [ ] Superman\r\n  [#] La La Land\r\n  [#] The Sixth Sense\r\n  [ ] Braveheart\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match movies with at least four words in their name. Note: you have to match `:` as part of characters between words. Hint: you can use `[]` or `|` for matching characters between words.\r\n  [#] Gone With The Wind\r\n  [#] Star Wars: The Last Jedi\r\n  [#] 2010: the year we make contact\r\n  [ ] Superman\r\n  [ ] Shawshank Redemption\r\n  [#] 2001: A Space Odyssey\r\n--\r\n\r\n--regexquiz\r\nWrite a regex to match the sentences that mention two years.\r\n  [#] 1984 comes before 1999.\r\n  [#] 2004 comes after 2001.\r\n  [ ] In 2015, I bought 2 cars.\r\n  [ ] There was a flood in 1999.\r\n--\r\n\r\n\r\n\r\n	1	2017-07-05 00:01:35.564596	2017-07-05 01:29:06.086429
28	regex-split-findall-content	Regex - Split/FindAll	2	We'll run through a few more methods in the `re` module.\r\n\r\n## re.split()\r\n\r\nThe `re.split()` method splits a strings based on a regex. Example:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.split(r"\\W+", "apple banana mango pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana, mango, pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana , mango   , pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n```\r\n\r\nWhile you can use the string's `split()` method, the regex one just becomes more powerful since it can handle so many variations of the separator.\r\n\r\n--offline-exercise:f9965145-d7b0-46a5-a506-47afb703ffb0\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nUse the `re.split()` mmethod to split a string that has list of ingredients and their quantity for a recipe. The format is `ingredient: quantity`.\r\n\r\nHere is what you can use for testing:\r\n\r\n* `Onion: 2` should give you `['Onion', '2']`.\r\n* `Onion  :   2` should give you `['Onion', '2']`.\r\n* `Onion:2` should give you `['Onion', '2']`.\r\n* `Onion: `, `:2` and `Onion` should not match.\r\n--\r\n\r\n## re.findall()\r\n\r\nThe method `re.findall()` is useful when you are trying to find multiple occurrences of a pattern within text. For example, if we want to find all years mentioned in a given text, `findall()` would be pretty helpful. Example:\r\n\r\n```Python\r\n>>> text = "The growth was more in 2001 compred to 2002."\r\n>>> re.findall(r"\\d+", text)\r\n['2001', '2002']\r\n```\r\n\r\n--offline-exercise:f84447b8-31cf-489c-8e6f-017263fa859e\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nUse the `re.findall()` method to find all five letter words in given text. Here is how you can test your code:\r\n\r\n* `There was less death in 2004.` should give you `['There', 'death']`.\r\n* `This is superb.` should give you nothing.\r\n--\r\n\r\n	1	2017-07-08 22:04:22.346269	2017-07-09 01:21:08.054637
18	regex-matching-boundaries	Regex - Matching Boundaries	1	Let's say, we want to match the text which has the word `cat` in it. We could use the regex `cat`. This regex would match `cat is fat`, `the cat jumped over the wall` etc. But it would also match `he was herding the cattle` :(\r\n\r\nIf we modify the regex to `cat\\s`, we can avoid matching `he was herding the cattle`. But it would still match `this muscat is funny`.\r\n\r\nHow about `\\scat\\s` as the regex? The problem is that it would not match `cat jumped` or `this is my cat.`.\r\n\r\nRegex has the ability to match boundaries of words & lines that would help us in this scenario. Let's see how...	1	2017-07-06 02:12:44.261177	2017-07-06 02:12:44.261226
13	regex-matching-m-to-n-occurrence	Regex - Matching m To n Occurrences	7	In regex, the general purpose method of matching certain number of occurrences is to use `{m,n}`. `\\d{2,4}` would match at least 2 and at most 4 occurrences of `\\d`.\r\n\r\nEarlier, we wrote the regex `\\d\\d\\d\\d` for matching a year in movie name. The same could be re-written as `\\d{4,4}` which matches at least 4 and at most 4 occurrences of `\\d`. It could be further shortened to `\\d{4}`.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{4}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2001: A Space Odyssey")\r\n<_sre.SRE_Match object; span=(0, 4), match='2001'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n<_sre.SRE_Match object; span=(11, 15), match='1992'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Gone With The Wind")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "E=mc2")\r\n>>> \r\n```\r\n\r\n--regexquiz:2e62b6a3-6843-446e-b199-b2cff2277ead\r\nWrite a regex that matches movie names that have at least 12 letters. Use the `{}` syntax.\r\n  [ ] 1984\r\n  [ ] Superman\r\n  [#] Spiderman Returns\r\n  [#] Star Wars: Return of the Jedi\r\n--\r\n\r\nLet's look at a different problem this time. You want to match numbers 0 to 999. How would you do that? `\\d{1,3}` would do the trick.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\d{1,3}"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "8")\r\n<_sre.SRE_Match object; span=(0, 1), match='8'>\r\n>>> # Matches 1 \\d because only 1 is available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "64")\r\n<_sre.SRE_Match object; span=(0, 2), match='64'>\r\n>>> # Matches 2 \\d because only 2 are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "256")\r\n<_sre.SRE_Match object; span=(0, 3), match='256'>\r\n>>> # Matches 3 \\d because all three are available.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "1024")\r\n<_sre.SRE_Match object; span=(0, 3), match='102'>\r\n>>> # Matches 3 \\d and stops looking for more.\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "abcdef")\r\n>>> # Not even 1 \\d found. So, not a match.\r\n```\r\n\r\nLet's re-work some of the older problems but this time, make use of `{}` operators to specify number of occurrences.\r\n\r\n--mcquiz:4b2aa2ca-eca9-4721-9a87-fa67219966ad\r\nWhich of the following would match regex `[+-]\\d{1,2}`\r\n  [#] +40\r\n  [#] -2\r\n  [#] +324\r\n  [ ] 22\r\n--\r\n\r\n--regexquiz:f8f71c16-f771-4ed5-afeb-43858df03a07\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. Use the `{m,n}` convention to specify occurrences. Hint: `-` has 0 to 1 occurrence while `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [ ] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz:123cc9d9-c4a1-43c4-9394-225b1ab1d76f\r\nWrite a regex that would match numbers -999 to 999. So, it should match -999, -998, …, 998, 999. The positive numbers could be prefixed with +. So, 64 could also be written as +64. Use the `{m,n}` convention to specify occurrences. Hint: in this case, `[+-]` have 0 to 1 occurrence and `\\d` has 1 to 3 occurrences.\r\n  [#] -733\r\n  [#] 4\r\n  [#] 33\r\n  [#] +42\r\n  [ ] AB\r\n  [ ] def\r\n--\r\n\r\n--regexquiz:cf65ce5a-a047-400f-a31a-a33629f832ab\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long.\r\n  [ ] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] Spinderman Returns\r\n  [ ] The Ghosts\r\n--\r\n\r\n--regexquiz:10edf34a-f317-42ca-98a0-cb1d6995c7c8\r\nFind movies with a word which is at least 4 letter long followed by another word which is at least 3 letter long or vice versa (i.e. a 3 letter long word is followed by a 4 letter long word). Hint: you'll need to use the OR (`|`) operator.\r\n  [#] Bat Whispers\r\n  [ ] Cat and Dog\r\n  [#] King Rat\r\n  [#] The Ghosts\r\n--\r\n\r\n## m To n Roundup\r\n\r\n`{m,n}` has four variations:\r\n\r\n* `{m,n}` matches at least m and at most n occurrences.\r\n* `{m}` matches exactly m occurrences.\r\n* `{m,}` matches at least m occurrneces (no upper bound).\r\n* `{,n}` matches at least 0 and at most n occurrences.\r\n\r\n	1	2017-07-05 00:01:35.564596	2017-07-09 01:16:35.789319
16	regex-matching-0-or-more-occurrences	Regex - * (Matching 0 or More Occurrences)	3	`*` stands for `{0,}` which means at least 0 and at most infinite matches. `BA*T` would match `BT`, `BAT`, `BAAAAAAAAAAAAAAAAAAAAAT` etc.\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.search( "BA*T", "BT")\r\n<_sre.SRE_Match object; span=(0, 2), match='BT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAT")\r\n<_sre.SRE_Match object; span=(0, 3), match='BAT'>\r\n>>>\r\n>>> re.search( "BA*T", "BAAAAAT")\r\n<_sre.SRE_Match object; span=(0, 7), match='BAAAAAT'>\r\n```\r\n\r\n--mcquiz:14376373-e7c1-494e-a8f2-531f565e2bf7\r\nWhich of the following would match regex `\\w\\s*:\\s*\\w`:\r\n  [#] Potatoes: 4\r\n  [#] Potatoes:4\r\n  [#] Potatoes    :     4\r\n  [#] 4: Potatoes\r\n  [ ] Potatoes ~::~ 4\r\n  [ ] :Potatoes:\r\n--\r\n\r\n--regexquiz:dc76c54b-5968-4a3b-a02f-260a10651451\r\nWrite a regex that matches `http` and `https` urls that end with `.com` or `.org` domains. Hint: you'll need `.*`.\r\n  [#] http://www.google.com\r\n  [#] http://yahoo.org\r\n  [#] http://www.facebook.com/profile\r\n  [#] http://www.wattpad.com/tags/fiction\r\n  [ ] ftp://www.google.com\r\n  [ ] http://www.yahoo.net\r\n  [#] https://www.facebook.com\r\n  [ ] https://www.photo.net\r\n--\r\n\r\n--regexquiz:dba74cbc-9b45-4215-8603-2f519c3d0bae\r\nWrite a regex that would match the sentences that mention cat followed by dog. Hint: use repetition of `.` to match word & space characters.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [ ] The dog looked at the cat with confusion.\r\n  [ ] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n--\r\n\r\n--regexquiz:5ee02aed-22c0-48de-a012-f393b69c9bee\r\nWrite a regex that would match sentences that mention cat and dog in any order (i.e. word cat could come before or after the word dog). Hint: Use the `|` operator.\r\n  [#] The cat chased the dog.\r\n  [#] The cat ran away from the dog.\r\n  [#] The dog looked at the cat with confusion.\r\n  [#] The dog was friendly to the cat.\r\n  [ ] The cat drank milk.\r\n  [ ] The dog went wild.\r\n--\r\n	1	2017-07-06 00:43:32.697962	2017-07-09 01:17:54.956073
21	regex-beyond-match	Regex - Beyond Match	1	So far, our focus was to become proficient at writing regex patterns. We'll learn a few more things about writing patterns but before that, let's take a break and focus on what you can do *after* you have found a match.	1	2017-07-08 01:50:57.984556	2017-07-08 01:50:57.984593
19	regex-matching-word-boundaries	Regex - Matching Word Boundaries	5	In regex, `\\b` matches word boundary. What does it mean? Let's first define what a word is.\r\n\r\nIn regex, a word is an unbroken sequence of `[A-Za-z0-9_]` or `\\w`. The sentence `cat jumped` has two words: `cat` and `jumped`. OTOH, `key:value` has two words: `key` and `value`. Even `http-proto` has two words: `http` and `proto`.\r\n\r\nSymbol `\\b` matches at the start and end of word boundary. The regex `\\bcat\\b` would match sentences that have word `cat`. Let's give it a try:\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\bcat\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "cat is fat")\r\n<_sre.SRE_Match object; span=(0, 3), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "the cat jumped over the wall.")\r\n<_sre.SRE_Match object; span=(4, 7), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this is my cat.")\r\n<_sre.SRE_Match object; span=(11, 14), match='cat'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "he was herding the cattle.")\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "this muscat is funny.")\r\n>>> \r\n```\r\n\r\n--mcquiz:66532415-dbad-42db-8664-17bb962fd21c\r\nHow many words (as per regex definition) are there in `http://www.google.com/search`?\r\n  [ ] 3\r\n  [ ] 4\r\n  [#] 5\r\n  [ ] 6\r\n--\r\n\r\n--regexquiz:67d4ece9-9a4b-4f0e-b733-5ced60ce9bb8\r\nWrite a regex to match sentences that mention animal dog.\r\n  [#] a dog was barking.\r\n  [#] dog is a loyal animal.\r\n  [#] this is my dog.\r\n  [ ] is it a dogfish?\r\n  [ ] dogfood is about using your own software.\r\n--\r\n\r\n--regexquiz:de6b8d33-1db6-4bd4-92dc-51856f2eb37b\r\nWrite a regex that matches sentences with at least one word that has exactly 5 letters.\r\n  [#] I am a super human.\r\n  [#] Spice route is not spicy.\r\n  [ ] Spiderman returns is not interesting.\r\n  [ ] Cat can jump.\r\n  [#] Cat can't climb.\r\n--\r\n\r\n--regexquiz:584051c2-5cb3-444c-819c-8da6333804a0\r\nWrite a regex that matches sentences that have a year in 4 digit format.\r\n  [#] In year 2000, there was an earthquake.\r\n  [#] 1984.\r\n  [#] In 2020, I'll be 20 years old.\r\n  [ ] I am 20 years old now.\r\n  [ ] 123456789 is a really long number.\r\n--\r\n	1	2017-07-06 02:12:44.261177	2017-07-09 01:18:35.471233
20	regex-matching-line-boundaries	Regex - Matching Line Boundaries	8	Just like words have boundaris that we can match with `\\b`, lines also have boundaries that we can match with `^` (start of line) and `$` (end of line).\r\n\r\nLet's say we want to match movie names that start with a year. So, we should match `2001: A Space Odyssey` but not `Dracula A.D. 1972`. We could use the pattern `^\\d{4}\\b` to do just that.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"^\\d{4}\\b"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n<_sre.SRE_Match object; span=(0, 4), match='2009'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "44500 Max")\r\n>>> # Not a match\r\n>>>\r\n```\r\n\r\nSimilarly, we can use the pattern `\\b\\d{4}$` to match movie names that end with a year.\r\n\r\n```Python\r\n>>> import re\r\n>>> REGEX_PATTERN = r"\\b\\d{4}$"\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Broadway Melody of 1940")\r\n<_sre.SRE_Match object; span=(19, 23), match='1940'>\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "2009: Lost Memories")\r\n>>> # Not a match\r\n>>> \r\n>>> re.search(REGEX_PATTERN, "Amityville 1992: It's About Time")\r\n>>> # Not a match\r\n>>>\r\n>>> re.search(REGEX_PATTERN, "Super 23123")\r\n>>> # Not a match\r\n>>> \r\n```\r\n\r\n--mcquiz:72adb2e8-b01c-4f29-8109-7d380d120d8c\r\nWhich of the following would match the regex `^\\d{4}$`:\r\n  [#] 1984\r\n  [#] 1971\r\n  [#] 2081\r\n  [ ] AM1200\r\n  [ ] Class of 1999\r\n  [ ] 2001: A Space Odyssey\r\n  [ ] Daleks' Invasion Earth: 2150 A.D.\r\n--\r\n\r\n--regexquiz:169bd30c-ca2c-468b-9319-5caf27f1efa7\r\nWrite a regex to match movie names that have only a single word:\r\n  [#] Superman\r\n  [#] 1984\r\n  [ ] Spiderman Returns\r\n  [ ] 2001: A Space Odyssey\r\n  [#] AM1200\r\n  [ ] I.Q.\r\n--\r\n\r\n--regexquiz:5424bec4-03d0-4ab5-a8e4-3db4fda08841\r\nWrite a regex to match movie names that do not have any whitespace character (Hint: `\\S`).\r\n  [#] Superman\r\n  [#] I.Q.\r\n  [ ] Spiderman Returns\r\n--\r\n\r\n--regexquiz:6c7ed823-0cc1-40de-a671-e988e9d44597\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] http://www.yahoo.com\r\n  [#] http://www.wattpad.com\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz:90bcd660-49e7-42fa-9f4a-64bb28720165\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://www.wattpad.com\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz:695ab476-a23b-4cf2-a876-71c2a16bbeff\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz:f2a8586f-01bb-4a33-93d4-45070c51530a\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com/tags/children\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n--\r\n\r\n--regexquiz:e0d044cd-2577-431d-96da-ab139d9798f1\r\nWrite a regex to match valid urls.\r\n  [#] http://www.google.com\r\n  [#] https://www.yahoo.com\r\n  [#] https://en.wikipedia.org/\r\n  [#] https://www.wattpad.com/tags/children\r\n  [ ] http:// google.com\r\n  [ ] A url looks like http://www.google.com\r\n  [#] http://localhost:8000/test-page.html\r\n--\r\n\r\n	1	2017-07-06 02:12:44.261177	2017-07-09 01:19:07.767289
23	regex-extract-content-full-match	Regex - Extract Content Full Match	2	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, but also which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\nYou should refer to the documentation of [Match Object](file:///Users/mangarg/Downloads/python-3.6.2rc1-docs-html/library/re.html#match-objects) on Python documentation.\r\n\r\n--offline-exercise:1fb6bc2e-29b5-41a9-83e4-9f39dd92aa68\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n--offline-exercise:f006ebc6-89b8-4171-9d63-bc6f8f7f5835\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that use an Adverb (words that end with ly). For example: strictly, deadly, objectively etc.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Strictly Ballroom` should give you `Strictly`.\r\n* `Tough and Deadly` should give you `Deadly`.\r\n* `Heavenly Creatures` should give you `Heavenly`.\r\n* `Superman` should not be a match.\r\n--\r\n\r\n--offline-exercise:42f6e7f4-8066-4422-81dd-7d18cb81298a\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module.\r\n* Define a regex to match sentences that have an email address (user@domain.com). For simplicity, assume that `user` and `domain` can have only the word characters and `-`.\r\n* Extract the matching email address from the Match Object returned `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `smith@yahoo.com - Steve Smith` should give you `smith@yahoo.com`.\r\n* `hi@turtleprogrammer.com - Someone Out There` should give you `hi@turtleprogrammer.com`.\r\n* `rama@gmail.com` should give you `rama@gmail.com`.\r\n* `rama @gmail.com` should not be a match.\r\n--\r\n\r\n	1	2017-07-08 14:23:19.285163	2017-07-09 01:19:33.547879
22	regex-extract-content	Regex - Extract Content	13	Let's revisit the problem of identifying year in a movie name. We created regex `\\b\\d{4}\\b` and it matches `2009: Lost Memories` but not `Superman`. What if you want to solve a slightly differnet problem. Not only that you want to find out if a movie name has year, but also which year it is. Let's step through the code for this line by line.\r\n\r\nFirst, you import the `re` module:\r\n\r\n```Python\r\n>>> import re\r\n```\r\n\r\nNext, you search for the regex in movie name. This time, you store the return value in a variable.\r\n\r\n```Python\r\n>>> match = re.search(r"\\b\\d{4}\\b", "2009: Lost Memories")\r\n```\r\n\r\nFinally, `match.group()` would give you the piece of text that matched your regex:\r\n\r\n```Python\r\n>>> match.group()\r\n'2009'\r\n```\r\n\r\nYou should refer to the documentation of [Match Object](file:///Users/mangarg/Downloads/python-3.6.2rc1-docs-html/library/re.html#match-objects) on Python documentation.\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that start with a five letter word.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Sense and Sensibility` should give you `Sense`.\r\n* `Gumby: The Movie` should give you `Gumby`.\r\n* `Jason's Lyric` should give you `Jason`.\r\n* `Superman` should not be a match.\r\n* `2009: Lost Memories` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module\r\n* Define a regex to match movie names that use an Adverb (words that end with ly). For example: strictly, deadly, objectively etc.\r\n* Extract the matching word from the Match Object returned by `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `Strictly Ballroom` should give you `Strictly`.\r\n* `Tough and Deadly` should give you `Deadly`.\r\n* `Heavenly Creatures` should give you `Heavenly`.\r\n* `Superman` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\n* Import the `re` module.\r\n* Define a regex to match sentences that have an email address (user@domain.com). For simplicity, assume that `user` and `domain` can have only the word characters and `-`.\r\n* Extract the matching email address from the Match Object returned `re.search()`. Use `.group()` on returned object.\r\n\r\nHere is how you should test your code:\r\n\r\n* `smith@yahoo.com - Steve Smith` should give you `smith@yahoo.com`.\r\n* `hi@turtleprogrammer.com - Someone Out There` should give you `hi@turtleprogrammer.com`.\r\n* `rama@gmail.com` should give you `rama@gmail.com`.\r\n* `rama @gmail.com` should not be a match.\r\n--\r\n\r\n	1	2017-07-08 01:50:57.984556	2017-07-08 14:19:53.962153
24	regex-extract-content-nested-match	Regex - Extract Content (Nested Match)	8	Let's look at another problem of extracting content. This time, we are given a list of people's names (e.g. `Ram Kripal`, `John Smith`, `Lee Cheung` etc). We need to extract the first name and the last name.\r\n\r\nOne approach is to define two regex: one for extracting first name and another for extracting last name.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> first_name_match = re.search(r"^\\w+", "Ram Kripal")\r\n>>> first_name_match.group()\r\n'Ram'\r\n>>> last_name_match = re.search(r"\\w+$", "Ram Kripal")\r\n>>> last_name_match.group()\r\n'Kripal'\r\n```\r\n\r\nThis is not very efficient as we had to create two separate regex. Regex allows us to create multiple groups within a single regex. Then, we can extract content corresponding to each of those groups.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group() # same as name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nIn this case, each pattern defined within `()` becomes yet another match group. The full match is always the group 0. After that, each `()` leads to the next group number.\r\n\r\nWe can modify this example to also handle middle name as well.\r\n\r\n```Python\r\n>>> import re\r\n>>> \r\n>>> # first example of a person with middle name\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Prakash Kripal")\r\n>>> name_match.group(0)\r\n'Ram Prakash Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Prakash'\r\n>>> name_match.group(3)\r\n'Kripal'\r\n>>> \r\n>>> # next example of a person without middle name. same regex.\r\n>>> name_match = re.search(r"(\\w+) (\\w*)\\b\\s?(\\w+)", "Ram Kripal")\r\n>>> name_match.group(0)\r\n'Ram Kripal'\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n''\r\n>>> name_match.group(3)\r\n'Kripal'\r\n\r\n```\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and match groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and match groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `<proto>://<host>.<site>.com`. Using regex (and match groups), you need to extract the proto, host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `http`, `www` and `google`.\r\n* `https://en.wikipedia.org` should give you `https`, `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `http`, `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of ingredients and quantity for a recipe. It's in the format `<ingredient>: <quantity> <metric>`. Using regex (and match groups), you need to extract the ingredient, quantity and metric. Metric is optional.\r\n\r\nHere is how you can test it:\r\n\r\n* `Onion: 2` should give you `Onion` and `2`.\r\n* `Olive Oil: 1 tbsp` should give you `Olive Oil`, `1` and `tbsp`.\r\n* `Salt  :   1    tbsp` should give you `Salt`, `1` and `tbsp`.\r\n* `Water:`, `Pepper: tbsp` should not match.\r\n--\r\n\r\n	1	2017-07-08 14:23:19.285163	2017-07-08 18:06:13.335607
26	regex-extract-content-named-groups	Regex - Extract Content (Named Groups)	8	While it's possible (and easy) to use numbered groups to extract content, it can get unwiedly in complex regex when there are too many nested groups. It's much cleaner to be able to name the groups for which we want to extract the content.\r\n\r\nLet's rework the problem of extracting first name and last name from a name. This is what we did earlier:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(\\w+) (\\w+)", "Ram Kripal")\r\n>>> name_match.group(1)\r\n'Ram'\r\n>>> name_match.group(2)\r\n'Kripal'\r\n```\r\n\r\nWe can instead use the `(?P<group_name>...)` syntax:\r\n\r\n```Python\r\n>>> name_match = re.search(r"(?P<first_name>\\w+) (?P<last_name>\\w+)", "Ram Kripal")\r\n>>> name_match.group('first_name')\r\n'Ram'\r\n>>> name_match.group('last_name')\r\n'Kripal'\r\n```\r\n\r\nIf you notice, we rewrote `(\\w+)` as `(?P<first_name>\\w+)` which can be broken down as:\r\n\r\n* `(` - start of the group.\r\n* `?P` - declaration that we'll give a name to the group.\r\n* `<first_name>` - name of the group.\r\n* `\\w+` - pattern. \r\n* `)` - end of the group\r\n\r\n--offline-exercise:21c05233-af76-41ea-8f32-0994dc758022\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nFrom the [previous section](/topic/regex-extract-content-nested-groups), modify the regex to extract first, middle and last names to use named groups. The group names should be first_name, middle_name and last_name.\r\n\r\nHere is how you can test it:\r\n\r\n* `George Bernard Shaw` should give you `George`, `Bernard`, `Shaw`.\r\n* `Ram Prakash Kripal` should give you `Ram`, `Prakash`, `Kripal`.\r\n* `John Smith` should give you `John`, blank middle name, `Smith`.\r\n* `Lee` and `Raja Shekhar Chandra Reddy` should not match.\r\n--\r\n\r\n--offline-exercise:ea476223-38e5-49fd-b70a-79d62746bc9a\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://www.<site>.com`. Using regex (and named groups), you need to extract the site name.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `google`.\r\n* `http://www.yahoo.com` should give you `yahoo`.\r\n* `http://www.facebook.com` should give you `facebook`.\r\n* `www.facebook.com` should not be a match.\r\n* `facebook.com` should not be a match.\r\n--\r\n\r\n--offline-exercise:dca25a5b-8579-4aad-ba20-1b7fc072c5f2\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nYou are given a list of URLs. All of them follow the pattern `http://<host>.<site>.com`. Using regex (and named groups), you need to extract the host and site names.\r\n\r\nHere is how you can test it:\r\n\r\n* `http://www.google.com` should give you `www` and `google`.\r\n* `http://en.wikipedia.org` should give you `en` and `wikipedia`.\r\n* `http://mail.google.com` should give you `mail` and `google`.\r\n* `www.facebook.com` and `facebook.com` should not match.\r\n--\r\n\r\n\r\n	1	2017-07-08 21:02:17.717593	2017-07-09 01:20:54.058433
27	regex-split-substitute-findall-content	Regex - Split/Substitute/FindAll	1	We'll run through a few more methods in the `re` module.\r\n\r\n## re.split()\r\n\r\nThe `re.split()` method splits a strings based on a regex. Example:\r\n\r\n```Python\r\n>>> import re\r\n>>>\r\n>>> re.split(r"\\W+", "apple banana mango pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana, mango, pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n>>>\r\n>>> re.split(r"\\W+", "apple, banana , mango   , pickle")\r\n['apple', 'banana', 'mango', 'pickle']\r\n```\r\n\r\nWhile you can use the string's `split()` method, the regex one just becomes more powerful since it can handle so many variations of the separator.\r\n\r\n--offline-exercise\r\nThis exercise needs to be done offline on your computer. You can use IDLE, PyCharm or any other Python environment for the same.\r\n\r\nUse the `re.split()` mmethod to split a string that has list of ingredients and their quantity for a recipe. The format is `ingredient: quantity`.\r\n\r\nHere is what you can use for testing:\r\n\r\n* `Onion: 2` should give you `['Onion', '2']`.\r\n* `Onion  :   2` should give you `['Onion', '2']`.\r\n* `Onion:2` should give you `['Onion', '2']`.\r\n* `Onion: `, `:2` and `Onion` should not match.\r\n--\r\n\r\n\r\n\r\n\r\n	1	2017-07-08 21:51:31.167733	2017-07-08 21:51:31.167782
\.


--
-- Name: topics_id_seq; Type: SEQUENCE SET; Schema: public; Owner: turtleprogrammer
--

SELECT pg_catalog.setval('topics_id_seq', 28, true);


--
-- Data for Name: users; Type: TABLE DATA; Schema: public; Owner: turtleprogrammer
--

COPY users (id, email, name, avatar, active, superuser, created_at, updated_at) FROM stdin;
1	manasgarg@gmail.com	Manas Garg	https://lh5.googleusercontent.com/-xWt1x_QePE8/AAAAAAAAAAI/AAAAAAAAAyc/EQvJajrcCX4/photo.jpg	t	t	2017-07-02 21:17:16.672572	2017-07-02 21:17:16.6726
\.


--
-- Name: users_id_seq; Type: SEQUENCE SET; Schema: public; Owner: turtleprogrammer
--

SELECT pg_catalog.setval('users_id_seq', 1, true);


--
-- Name: exercise_history exercise_history_pkey; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY exercise_history
    ADD CONSTRAINT exercise_history_pkey PRIMARY KEY (user_id, exercise_id);


--
-- Name: topic_drafts topic_drafts_pkey; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topic_drafts
    ADD CONSTRAINT topic_drafts_pkey PRIMARY KEY (topic_id, author_id);


--
-- Name: topic_history topic_history_pkey; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topic_history
    ADD CONSTRAINT topic_history_pkey PRIMARY KEY (id);


--
-- Name: topics topics_pkey; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topics
    ADD CONSTRAINT topics_pkey PRIMARY KEY (id);


--
-- Name: topics topics_slug_key; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topics
    ADD CONSTRAINT topics_slug_key UNIQUE (slug);


--
-- Name: users users_email_key; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_email_key UNIQUE (email);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: topic_drafts topic_drafts_author_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topic_drafts
    ADD CONSTRAINT topic_drafts_author_id_fkey FOREIGN KEY (author_id) REFERENCES users(id);


--
-- Name: topic_drafts topic_drafts_topic_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topic_drafts
    ADD CONSTRAINT topic_drafts_topic_id_fkey FOREIGN KEY (topic_id) REFERENCES topics(id);


--
-- Name: topic_history topic_history_author_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topic_history
    ADD CONSTRAINT topic_history_author_id_fkey FOREIGN KEY (author_id) REFERENCES users(id);


--
-- Name: topic_history topic_history_topic_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topic_history
    ADD CONSTRAINT topic_history_topic_id_fkey FOREIGN KEY (topic_id) REFERENCES topics(id);


--
-- Name: topics topics_author_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: turtleprogrammer
--

ALTER TABLE ONLY topics
    ADD CONSTRAINT topics_author_id_fkey FOREIGN KEY (author_id) REFERENCES users(id);


--
-- PostgreSQL database dump complete
--

